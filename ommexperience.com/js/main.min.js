function PxLoaderTexture(e, t, i) {
    var r = this,
        n = null;
    this.texture = new THREE.Object3D, this.tags = t, this.priority = i, this.start = function(t) {
        n = t, r.texture = THREE.ImageUtils.loadTexture(e, null, function() {
            r.texture.minFilter = THREE.LinearFilter, r.texture.maxFilter = THREE.LinearFilter, n.onLoad(r)
        })
    }, this.getName = function() {
        return e
    }, this.bind = function(e, t) {
        r.img.addEventListener ? r.img.addEventListener(e, t, !1) : r.img.attachEvent && r.img.attachEvent("on" + e, t)
    }, this.unbind = function(e, t) {
        r.img.removeEventListener ? r.img.removeEventListener(e, t, !1) : r.img.detachEvent && r.img.detachEvent("on" + e, t)
    }
}
var THREE = {
    REVISION: "71"
};
"object" == typeof module && (module.exports = THREE), void 0 === Math.sign && (Math.sign = function(e) {
        return 0 > e ? -1 : e > 0 ? 1 : +e
    }), THREE.log = function() {
        console.log.apply(console, arguments)
    }, THREE.warn = function() {
        console.warn.apply(console, arguments)
    }, THREE.error = function() {
        console.error.apply(console, arguments)
    }, THREE.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    }, THREE.CullFaceNone = 0, THREE.CullFaceBack = 1, THREE.CullFaceFront = 2, THREE.CullFaceFrontBack = 3, THREE.FrontFaceDirectionCW = 0, THREE.FrontFaceDirectionCCW = 1, THREE.BasicShadowMap = 0, THREE.PCFShadowMap = 1, THREE.PCFSoftShadowMap = 2, THREE.FrontSide = 0, THREE.BackSide = 1, THREE.DoubleSide = 2, THREE.NoShading = 0, THREE.FlatShading = 1, THREE.SmoothShading = 2, THREE.NoColors = 0, THREE.FaceColors = 1, THREE.VertexColors = 2, THREE.NoBlending = 0, THREE.NormalBlending = 1, THREE.AdditiveBlending = 2, THREE.SubtractiveBlending = 3, THREE.MultiplyBlending = 4, THREE.CustomBlending = 5, THREE.AddEquation = 100, THREE.SubtractEquation = 101, THREE.ReverseSubtractEquation = 102, THREE.MinEquation = 103, THREE.MaxEquation = 104, THREE.ZeroFactor = 200, THREE.OneFactor = 201, THREE.SrcColorFactor = 202, THREE.OneMinusSrcColorFactor = 203, THREE.SrcAlphaFactor = 204, THREE.OneMinusSrcAlphaFactor = 205, THREE.DstAlphaFactor = 206, THREE.OneMinusDstAlphaFactor = 207, THREE.DstColorFactor = 208, THREE.OneMinusDstColorFactor = 209, THREE.SrcAlphaSaturateFactor = 210, THREE.MultiplyOperation = 0, THREE.MixOperation = 1, THREE.AddOperation = 2, THREE.UVMapping = 300, THREE.CubeReflectionMapping = 301, THREE.CubeRefractionMapping = 302, THREE.EquirectangularReflectionMapping = 303, THREE.EquirectangularRefractionMapping = 304, THREE.SphericalReflectionMapping = 305, THREE.RepeatWrapping = 1e3, THREE.ClampToEdgeWrapping = 1001, THREE.MirroredRepeatWrapping = 1002, THREE.NearestFilter = 1003, THREE.NearestMipMapNearestFilter = 1004, THREE.NearestMipMapLinearFilter = 1005, THREE.LinearFilter = 1006, THREE.LinearMipMapNearestFilter = 1007, THREE.LinearMipMapLinearFilter = 1008, THREE.UnsignedByteType = 1009, THREE.ByteType = 1010, THREE.ShortType = 1011, THREE.UnsignedShortType = 1012, THREE.IntType = 1013, THREE.UnsignedIntType = 1014, THREE.FloatType = 1015, THREE.HalfFloatType = 1025, THREE.UnsignedShort4444Type = 1016, THREE.UnsignedShort5551Type = 1017, THREE.UnsignedShort565Type = 1018, THREE.AlphaFormat = 1019, THREE.RGBFormat = 1020, THREE.RGBAFormat = 1021, THREE.LuminanceFormat = 1022, THREE.LuminanceAlphaFormat = 1023, THREE.RGBEFormat = THREE.RGBAFormat, THREE.RGB_S3TC_DXT1_Format = 2001, THREE.RGBA_S3TC_DXT1_Format = 2002, THREE.RGBA_S3TC_DXT3_Format = 2003, THREE.RGBA_S3TC_DXT5_Format = 2004, THREE.RGB_PVRTC_4BPPV1_Format = 2100, THREE.RGB_PVRTC_2BPPV1_Format = 2101, THREE.RGBA_PVRTC_4BPPV1_Format = 2102, THREE.RGBA_PVRTC_2BPPV1_Format = 2103, THREE.Projector = function() {
        THREE.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(e, t) {
            THREE.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(t)
        }, this.unprojectVector = function(e, t) {
            THREE.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(t)
        }, this.pickingRay = function(e, t) {
            THREE.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    }, THREE.CanvasRenderer = function() {
        THREE.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElement("canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
    }, THREE.Color = function(e) {
        return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(e)
    }, THREE.Color.prototype = {
        constructor: THREE.Color,
        r: 1,
        g: 1,
        b: 1,
        set: function(e) {
            return e instanceof THREE.Color ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
        },
        setHex: function(e) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
        },
        setRGB: function(e, t, i) {
            return this.r = e, this.g = t, this.b = i, this
        },
        setHSL: function(e, t, i) {
            if (0 === t) this.r = this.g = this.b = i;
            else {
                var r = function(e, t, i) {
                    return 0 > i && (i += 1), i > 1 && (i -= 1), 1 / 6 > i ? e + 6 * (t - e) * i : .5 > i ? t : 2 / 3 > i ? e + 6 * (t - e) * (2 / 3 - i) : e
                };
                t = .5 >= i ? i * (1 + t) : i + t - i * t, i = 2 * i - t, this.r = r(i, t, e + 1 / 3), this.g = r(i, t, e), this.b = r(i, t, e - 1 / 3)
            }
            return this
        },
        setStyle: function(e) {
            return /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(e) ? (e = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(e), this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, this) : /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(e) ? (e = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(e), this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, this) : /^\#([0-9a-f]{6})$/i.test(e) ? (e = /^\#([0-9a-f]{6})$/i.exec(e), this.setHex(parseInt(e[1], 16)), this) : /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(e) ? (e = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(e), this.setHex(parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3], 16)), this) : /^(\w+)$/i.test(e) ? (this.setHex(THREE.ColorKeywords[e]), this) : void 0
        },
        copy: function(e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        },
        copyGammaToLinear: function(e, t) {
            return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
        },
        copyLinearToGamma: function(e, t) {
            void 0 === t && (t = 2);
            var i = t > 0 ? 1 / t : 1;
            return this.r = Math.pow(e.r, i), this.g = Math.pow(e.g, i), this.b = Math.pow(e.b, i), this
        },
        convertGammaToLinear: function() {
            var e = this.r,
                t = this.g,
                i = this.b;
            return this.r = e * e, this.g = t * t, this.b = i * i, this
        },
        convertLinearToGamma: function() {
            return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(e) {
            e = e || {
                h: 0,
                s: 0,
                l: 0
            };
            var t = this.r,
                i = this.g,
                r = this.b,
                n = Math.max(t, i, r),
                o = Math.min(t, i, r),
                a, s = (o + n) / 2;
            if (o === n) o = a = 0;
            else {
                var l = n - o,
                    o = .5 >= s ? l / (n + o) : l / (2 - n - o);
                switch (n) {
                    case t:
                        a = (i - r) / l + (r > i ? 6 : 0);
                        break;
                    case i:
                        a = (r - t) / l + 2;
                        break;
                    case r:
                        a = (t - i) / l + 4
                }
                a /= 6
            }
            return e.h = a, e.s = o, e.l = s, e
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function(e, t, i) {
            var r = this.getHSL();
            return r.h += e, r.s += t, r.l += i, this.setHSL(r.h, r.s, r.l), this
        },
        add: function(e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        },
        addColors: function(e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        },
        addScalar: function(e) {
            return this.r += e, this.g += e, this.b += e, this
        },
        multiply: function(e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        },
        multiplyScalar: function(e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        },
        lerp: function(e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        },
        equals: function(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        },
        fromArray: function(e) {
            return this.r = e[0], this.g = e[1], this.b = e[2], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        },
        clone: function() {
            return (new THREE.Color).setRGB(this.r, this.g, this.b)
        }
    }, THREE.ColorKeywords = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }, THREE.Quaternion = function(e, t, i, r) {
        this._x = e || 0, this._y = t || 0, this._z = i || 0, this._w = void 0 !== r ? r : 1
    }, THREE.Quaternion.prototype = {
        constructor: THREE.Quaternion,
        _x: 0,
        _y: 0,
        _z: 0,
        _w: 0,
        get x() {
            return this._x
        },
        set x(e) {
            this._x = e, this.onChangeCallback()
        },
        get y() {
            return this._y
        },
        set y(e) {
            this._y = e, this.onChangeCallback()
        },
        get z() {
            return this._z
        },
        set z(e) {
            this._z = e, this.onChangeCallback()
        },
        get w() {
            return this._w
        },
        set w(e) {
            this._w = e, this.onChangeCallback()
        },
        set: function(e, t, i, r) {
            return this._x = e, this._y = t, this._z = i, this._w = r, this.onChangeCallback(), this
        },
        copy: function(e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
        },
        setFromEuler: function(e, t) {
            if (!1 == e instanceof THREE.Euler) throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var i = Math.cos(e._x / 2),
                r = Math.cos(e._y / 2),
                n = Math.cos(e._z / 2),
                o = Math.sin(e._x / 2),
                a = Math.sin(e._y / 2),
                s = Math.sin(e._z / 2);
            return "XYZ" === e.order ? (this._x = o * r * n + i * a * s, this._y = i * a * n - o * r * s, this._z = i * r * s + o * a * n, this._w = i * r * n - o * a * s) : "YXZ" === e.order ? (this._x = o * r * n + i * a * s, this._y = i * a * n - o * r * s, this._z = i * r * s - o * a * n, this._w = i * r * n + o * a * s) : "ZXY" === e.order ? (this._x = o * r * n - i * a * s, this._y = i * a * n + o * r * s, this._z = i * r * s + o * a * n, this._w = i * r * n - o * a * s) : "ZYX" === e.order ? (this._x = o * r * n - i * a * s, this._y = i * a * n + o * r * s, this._z = i * r * s - o * a * n, this._w = i * r * n + o * a * s) : "YZX" === e.order ? (this._x = o * r * n + i * a * s, this._y = i * a * n + o * r * s, this._z = i * r * s - o * a * n, this._w = i * r * n - o * a * s) : "XZY" === e.order && (this._x = o * r * n - i * a * s, this._y = i * a * n - o * r * s, this._z = i * r * s + o * a * n, this._w = i * r * n + o * a * s), !1 !== t && this.onChangeCallback(), this
        },
        setFromAxisAngle: function(e, t) {
            var i = t / 2,
                r = Math.sin(i);
            return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(e) {
            var t = e.elements,
                i = t[0];
            e = t[4];
            var r = t[8],
                n = t[1],
                o = t[5],
                a = t[9],
                s = t[2],
                l = t[6],
                t = t[10],
                h = i + o + t;
            return h > 0 ? (i = .5 / Math.sqrt(h + 1), this._w = .25 / i, this._x = (l - a) * i, this._y = (r - s) * i, this._z = (n - e) * i) : i > o && i > t ? (i = 2 * Math.sqrt(1 + i - o - t), this._w = (l - a) / i, this._x = .25 * i, this._y = (e + n) / i, this._z = (r + s) / i) : o > t ? (i = 2 * Math.sqrt(1 + o - i - t), this._w = (r - s) / i, this._x = (e + n) / i, this._y = .25 * i, this._z = (a + l) / i) : (i = 2 * Math.sqrt(1 + t - i - o), this._w = (n - e) / i, this._x = (r + s) / i, this._y = (a + l) / i, this._z = .25 * i), this.onChangeCallback(), this
        },
        setFromUnitVectors: function() {
            var e, t;
            return function(i, r) {
                return void 0 === e && (e = new THREE.Vector3), t = i.dot(r) + 1, 1e-6 > t ? (t = 0, Math.abs(i.x) > Math.abs(i.z) ? e.set(-i.y, i.x, 0) : e.set(0, -i.z, i.y)) : e.crossVectors(i, r), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize(), this
            }
        }(),
        inverse: function() {
            return this.conjugate().normalize(), this
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
        },
        dot: function(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var e = this.length();
            return 0 === e ? (this._z = this._y = this._x = 0, this._w = 1) : (e = 1 / e, this._x *= e, this._y *= e, this._z *= e, this._w *= e), this.onChangeCallback(), this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (THREE.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        },
        multiplyQuaternions: function(e, t) {
            var i = e._x,
                r = e._y,
                n = e._z,
                o = e._w,
                a = t._x,
                s = t._y,
                l = t._z,
                h = t._w;
            return this._x = i * h + o * a + r * l - n * s, this._y = r * h + o * s + n * a - i * l, this._z = n * h + o * l + i * s - r * a, this._w = o * h - i * a - r * s - n * l, this.onChangeCallback(), this
        },
        multiplyVector3: function(e) {
            return THREE.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
        },
        slerp: function(e, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(e);
            var i = this._x,
                r = this._y,
                n = this._z,
                o = this._w,
                a = o * e._w + i * e._x + r * e._y + n * e._z;
            if (0 > a ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = i, this._y = r, this._z = n, this;
            var s = Math.acos(a),
                l = Math.sqrt(1 - a * a);
            return .001 > Math.abs(l) ? (this._w = .5 * (o + this._w), this._x = .5 * (i + this._x), this._y = .5 * (r + this._y), this._z = .5 * (n + this._z), this) : (a = Math.sin((1 - t) * s) / l, s = Math.sin(t * s) / l, this._w = o * a + this._w * s, this._x = i * a + this._x * s, this._y = r * a + this._y * s, this._z = n * a + this._z * s, this.onChangeCallback(), this)
        },
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
        },
        onChange: function(e) {
            return this.onChangeCallback = e, this
        },
        onChangeCallback: function() {},
        clone: function() {
            return new THREE.Quaternion(this._x, this._y, this._z, this._w)
        }
    }, THREE.Quaternion.slerp = function(e, t, i, r) {
        return i.copy(e).slerp(t, r)
    }, THREE.Vector2 = function(e, t) {
        this.x = e || 0, this.y = t || 0
    }, THREE.Vector2.prototype = {
        constructor: THREE.Vector2,
        set: function(e, t) {
            return this.x = e, this.y = t, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this
        },
        add: function(e, t) {
            return void 0 !== t ? (THREE.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (THREE.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        },
        multiply: function(e) {
            return this.x *= e.x, this.y *= e.y, this
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this
        },
        divide: function(e) {
            return this.x /= e.x, this.y /= e.y, this
        },
        divideScalar: function(e) {
            return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e) : this.y = this.x = 0, this
        },
        min: function(e) {
            return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this
        },
        max: function(e) {
            return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this
        },
        clamp: function(e, t) {
            return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this
        },
        clampScalar: function() {
            var e, t;
            return function(i, r) {
                return void 0 === e && (e = new THREE.Vector2, t = new THREE.Vector2), e.set(i, i), t.set(r, r), this.clamp(e, t)
            }
        }(),
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x;
            return e = this.y - e.y, t * t + e * e
        },
        setLength: function(e) {
            var t = this.length();
            return 0 !== t && e !== t && this.multiplyScalar(e / t), this
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e), this
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
        },
        fromAttribute: function(e, t, i) {
            return void 0 === i && (i = 0), t = t * e.itemSize + i, this.x = e.array[t], this.y = e.array[t + 1], this
        },
        clone: function() {
            return new THREE.Vector2(this.x, this.y)
        }
    }, THREE.Vector3 = function(e, t, i) {
        this.x = e || 0, this.y = t || 0, this.z = i || 0
    }, THREE.Vector3.prototype = {
        constructor: THREE.Vector3,
        set: function(e, t, i) {
            return this.x = e, this.y = t, this.z = i, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setZ: function(e) {
            return this.z = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        },
        add: function(e, t) {
            return void 0 !== t ? (THREE.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this.z += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (THREE.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this.z -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (THREE.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        },
        multiplyVectors: function(e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        },
        applyEuler: function() {
            var e;
            return function(t) {
                return !1 == t instanceof THREE.Euler && THREE.error("THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order."), void 0 === e && (e = new THREE.Quaternion), this.applyQuaternion(e.setFromEuler(t)), this
            }
        }(),
        applyAxisAngle: function() {
            var e;
            return function(t, i) {
                return void 0 === e && (e = new THREE.Quaternion), this.applyQuaternion(e.setFromAxisAngle(t, i)), this
            }
        }(),
        applyMatrix3: function(e) {
            var t = this.x,
                i = this.y,
                r = this.z;
            return e = e.elements, this.x = e[0] * t + e[3] * i + e[6] * r, this.y = e[1] * t + e[4] * i + e[7] * r, this.z = e[2] * t + e[5] * i + e[8] * r, this
        },
        applyMatrix4: function(e) {
            var t = this.x,
                i = this.y,
                r = this.z;
            return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * r + e[12], this.y = e[1] * t + e[5] * i + e[9] * r + e[13], this.z = e[2] * t + e[6] * i + e[10] * r + e[14], this
        },
        applyProjection: function(e) {
            var t = this.x,
                i = this.y,
                r = this.z;
            e = e.elements;
            var n = 1 / (e[3] * t + e[7] * i + e[11] * r + e[15]);
            return this.x = (e[0] * t + e[4] * i + e[8] * r + e[12]) * n, this.y = (e[1] * t + e[5] * i + e[9] * r + e[13]) * n, this.z = (e[2] * t + e[6] * i + e[10] * r + e[14]) * n, this
        },
        applyQuaternion: function(e) {
            var t = this.x,
                i = this.y,
                r = this.z,
                n = e.x,
                o = e.y,
                a = e.z;
            e = e.w;
            var s = e * t + o * r - a * i,
                l = e * i + a * t - n * r,
                h = e * r + n * i - o * t,
                t = -n * t - o * i - a * r;
            return this.x = s * e + t * -n + l * -a - h * -o, this.y = l * e + t * -o + h * -n - s * -a, this.z = h * e + t * -a + s * -o - l * -n, this
        },
        project: function() {
            var e;
            return function(t) {
                return void 0 === e && (e = new THREE.Matrix4), e.multiplyMatrices(t.projectionMatrix, e.getInverse(t.matrixWorld)), this.applyProjection(e)
            }
        }(),
        unproject: function() {
            var e;
            return function(t) {
                return void 0 === e && (e = new THREE.Matrix4), e.multiplyMatrices(t.matrixWorld, e.getInverse(t.projectionMatrix)), this.applyProjection(e)
            }
        }(),
        transformDirection: function(e) {
            var t = this.x,
                i = this.y,
                r = this.z;
            return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * r, this.y = e[1] * t + e[5] * i + e[9] * r, this.z = e[2] * t + e[6] * i + e[10] * r, this.normalize(), this
        },
        divide: function(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        },
        divideScalar: function(e) {
            return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e, this.z *= e) : this.z = this.y = this.x = 0, this
        },
        min: function(e) {
            return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this
        },
        max: function(e) {
            return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this
        },
        clamp: function(e, t) {
            return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this.z < e.z ? this.z = e.z : this.z > t.z && (this.z = t.z), this
        },
        clampScalar: function() {
            var e, t;
            return function(i, r) {
                return void 0 === e && (e = new THREE.Vector3, t = new THREE.Vector3), e.set(i, i, i), t.set(r, r, r), this.clamp(e, t)
            }
        }(),
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        setLength: function(e) {
            var t = this.length();
            return 0 !== t && e !== t && this.multiplyScalar(e / t), this
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e), this
        },
        cross: function(e, t) {
            if (void 0 !== t) return THREE.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t);
            var i = this.x,
                r = this.y,
                n = this.z;
            return this.x = r * e.z - n * e.y, this.y = n * e.x - i * e.z, this.z = i * e.y - r * e.x, this
        },
        crossVectors: function(e, t) {
            var i = e.x,
                r = e.y,
                n = e.z,
                o = t.x,
                a = t.y,
                s = t.z;
            return this.x = r * s - n * a, this.y = n * o - i * s, this.z = i * a - r * o, this
        },
        projectOnVector: function() {
            var e, t;
            return function(i) {
                return void 0 === e && (e = new THREE.Vector3), e.copy(i).normalize(), t = this.dot(e), this.copy(e).multiplyScalar(t)
            }
        }(),
        projectOnPlane: function() {
            var e;
            return function(t) {
                return void 0 === e && (e = new THREE.Vector3), e.copy(this).projectOnVector(t), this.sub(e)
            }
        }(),
        reflect: function() {
            var e;
            return function(t) {
                return void 0 === e && (e = new THREE.Vector3), this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
            }
        }(),
        angleTo: function(e) {
            return e = this.dot(e) / (this.length() * e.length()), Math.acos(THREE.Math.clamp(e, -1, 1))
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x,
                i = this.y - e.y;
            return e = this.z - e.z, t * t + i * i + e * e
        },
        setEulerFromRotationMatrix: function(e, t) {
            THREE.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function(e, t) {
            THREE.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(e) {
            return THREE.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function(e) {
            return THREE.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function(e, t) {
            return THREE.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
        },
        setFromMatrixPosition: function(e) {
            return this.x = e.elements[12], this.y = e.elements[13], this.z = e.elements[14], this
        },
        setFromMatrixScale: function(e) {
            var t = this.set(e.elements[0], e.elements[1], e.elements[2]).length(),
                i = this.set(e.elements[4], e.elements[5], e.elements[6]).length();
            return e = this.set(e.elements[8], e.elements[9], e.elements[10]).length(), this.x = t, this.y = i, this.z = e, this
        },
        setFromMatrixColumn: function(e, t) {
            var i = 4 * e,
                r = t.elements;
            return this.x = r[i], this.y = r[i + 1], this.z = r[i + 2], this
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
        },
        fromAttribute: function(e, t, i) {
            return void 0 === i && (i = 0), t = t * e.itemSize + i, this.x = e.array[t], this.y = e.array[t + 1], this.z = e.array[t + 2], this
        },
        clone: function() {
            return new THREE.Vector3(this.x, this.y, this.z)
        }
    }, THREE.Vector4 = function(e, t, i, r) {
        this.x = e || 0, this.y = t || 0, this.z = i || 0, this.w = void 0 !== r ? r : 1
    }, THREE.Vector4.prototype = {
        constructor: THREE.Vector4,
        set: function(e, t, i, r) {
            return this.x = e, this.y = t, this.z = i, this.w = r, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setZ: function(e) {
            return this.z = e, this
        },
        setW: function(e) {
            return this.w = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw Error("index is out of range: " + e)
            }
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
        },
        add: function(e, t) {
            return void 0 !== t ? (THREE.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (THREE.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        },
        applyMatrix4: function(e) {
            var t = this.x,
                i = this.y,
                r = this.z,
                n = this.w;
            return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * r + e[12] * n, this.y = e[1] * t + e[5] * i + e[9] * r + e[13] * n, this.z = e[2] * t + e[6] * i + e[10] * r + e[14] * n, this.w = e[3] * t + e[7] * i + e[11] * r + e[15] * n, this
        },
        divideScalar: function(e) {
            return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e, this.z *= e, this.w *= e) : (this.z = this.y = this.x = 0, this.w = 1), this
        },
        setAxisAngleFromQuaternion: function(e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return 1e-4 > t ? (this.x = 1, this.z = this.y = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
        },
        setAxisAngleFromRotationMatrix: function(e) {
            var t, i, r;
            e = e.elements;
            var n = e[0];
            r = e[4];
            var o = e[8],
                a = e[1],
                s = e[5],
                l = e[9];
            i = e[2], t = e[6];
            var h = e[10];
            return .01 > Math.abs(r - a) && .01 > Math.abs(o - i) && .01 > Math.abs(l - t) ? .1 > Math.abs(r + a) && .1 > Math.abs(o + i) && .1 > Math.abs(l + t) && .1 > Math.abs(n + s + h - 3) ? (this.set(1, 0, 0, 0), this) : (e = Math.PI, n = (n + 1) / 2, s = (s + 1) / 2, h = (h + 1) / 2, r = (r + a) / 4, o = (o + i) / 4, l = (l + t) / 4, n > s && n > h ? .01 > n ? (t = 0, r = i = .707106781) : (t = Math.sqrt(n), i = r / t, r = o / t) : s > h ? .01 > s ? (t = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(s), t = r / i, r = l / i) : .01 > h ? (i = t = .707106781, r = 0) : (r = Math.sqrt(h), t = o / r, i = l / r), this.set(t, i, r, e), this) : (e = Math.sqrt((t - l) * (t - l) + (o - i) * (o - i) + (a - r) * (a - r)), .001 > Math.abs(e) && (e = 1), this.x = (t - l) / e, this.y = (o - i) / e, this.z = (a - r) / e, this.w = Math.acos((n + s + h - 1) / 2), this)
        },
        min: function(e) {
            return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this.w > e.w && (this.w = e.w), this
        },
        max: function(e) {
            return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this.w < e.w && (this.w = e.w), this
        },
        clamp: function(e, t) {
            return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this.z < e.z ? this.z = e.z : this.z > t.z && (this.z = t.z), this.w < e.w ? this.w = e.w : this.w > t.w && (this.w = t.w), this
        },
        clampScalar: function() {
            var e, t;
            return function(i, r) {
                return void 0 === e && (e = new THREE.Vector4, t = new THREE.Vector4), e.set(i, i, i, i), t.set(r, r, r, r), this.clamp(e, t)
            }
        }(),
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function() {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        setLength: function(e) {
            var t = this.length();
            return 0 !== t && e !== t && this.multiplyScalar(e / t), this
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e), this
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
        },
        fromAttribute: function(e, t, i) {
            return void 0 === i && (i = 0), t = t * e.itemSize + i, this.x = e.array[t], this.y = e.array[t + 1], this.z = e.array[t + 2], this.w = e.array[t + 3], this
        },
        clone: function() {
            return new THREE.Vector4(this.x, this.y, this.z, this.w)
        }
    }, THREE.Euler = function(e, t, i, r) {
        this._x = e || 0, this._y = t || 0, this._z = i || 0, this._order = r || THREE.Euler.DefaultOrder
    }, THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), THREE.Euler.DefaultOrder = "XYZ", THREE.Euler.prototype = {
        constructor: THREE.Euler,
        _x: 0,
        _y: 0,
        _z: 0,
        _order: THREE.Euler.DefaultOrder,
        get x() {
            return this._x
        },
        set x(e) {
            this._x = e, this.onChangeCallback()
        },
        get y() {
            return this._y
        },
        set y(e) {
            this._y = e, this.onChangeCallback()
        },
        get z() {
            return this._z
        },
        set z(e) {
            this._z = e, this.onChangeCallback()
        },
        get order() {
            return this._order
        },
        set order(e) {
            this._order = e, this.onChangeCallback()
        },
        set: function(e, t, i, r) {
            return this._x = e, this._y = t, this._z = i, this._order = r || this._order, this.onChangeCallback(), this
        },
        copy: function(e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(e, t, i) {
            var r = THREE.Math.clamp,
                n = e.elements;
            e = n[0];
            var o = n[4],
                a = n[8],
                s = n[1],
                l = n[5],
                h = n[9],
                u = n[2],
                c = n[6],
                n = n[10];
            return t = t || this._order, "XYZ" === t ? (this._y = Math.asin(r(a, -1, 1)), .99999 > Math.abs(a) ? (this._x = Math.atan2(-h, n), this._z = Math.atan2(-o, e)) : (this._x = Math.atan2(c, l), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-r(h, -1, 1)), .99999 > Math.abs(h) ? (this._y = Math.atan2(a, n), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-u, e), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(r(c, -1, 1)), .99999 > Math.abs(c) ? (this._y = Math.atan2(-u, n), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(s, e))) : "ZYX" === t ? (this._y = Math.asin(-r(u, -1, 1)), .99999 > Math.abs(u) ? (this._x = Math.atan2(c, n), this._z = Math.atan2(s, e)) : (this._x = 0, this._z = Math.atan2(-o, l))) : "YZX" === t ? (this._z = Math.asin(r(s, -1, 1)), .99999 > Math.abs(s) ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-u, e)) : (this._x = 0, this._y = Math.atan2(a, n))) : "XZY" === t ? (this._z = Math.asin(-r(o, -1, 1)), .99999 > Math.abs(o) ? (this._x = Math.atan2(c, l), this._y = Math.atan2(a, e)) : (this._x = Math.atan2(-h, n), this._y = 0)) : THREE.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== i && this.onChangeCallback(), this
        },
        setFromQuaternion: function() {
            var e;
            return function(t, i, r) {
                return void 0 === e && (e = new THREE.Matrix4), e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, i, r), this
            }
        }(),
        setFromVector3: function(e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        },
        reorder: function() {
            var e = new THREE.Quaternion;
            return function(t) {
                e.setFromEuler(this), this.setFromQuaternion(e, t)
            }
        }(),
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        },
        fromArray: function(e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
        },
        toVector3: function(e) {
            return e ? e.set(this._x, this._y, this._z) : new THREE.Vector3(this._x, this._y, this._z)
        },
        onChange: function(e) {
            return this.onChangeCallback = e, this
        },
        onChangeCallback: function() {},
        clone: function() {
            return new THREE.Euler(this._x, this._y, this._z, this._order)
        }
    }, THREE.Line3 = function(e, t) {
        this.start = void 0 !== e ? e : new THREE.Vector3, this.end = void 0 !== t ? t : new THREE.Vector3
    }, THREE.Line3.prototype = {
        constructor: THREE.Line3,
        set: function(e, t) {
            return this.start.copy(e), this.end.copy(t), this
        },
        copy: function(e) {
            return this.start.copy(e.start), this.end.copy(e.end), this
        },
        center: function(e) {
            return (e || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(e) {
            return (e || new THREE.Vector3).subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(e, t) {
            var i = t || new THREE.Vector3;
            return this.delta(i).multiplyScalar(e).add(this.start)
        },
        closestPointToPointParameter: function() {
            var e = new THREE.Vector3,
                t = new THREE.Vector3;
            return function(i, r) {
                e.subVectors(i, this.start), t.subVectors(this.end, this.start);
                var n = t.dot(t),
                    n = t.dot(e) / n;
                return r && (n = THREE.Math.clamp(n, 0, 1)), n
            }
        }(),
        closestPointToPoint: function(e, t, i) {
            return e = this.closestPointToPointParameter(e, t), i = i || new THREE.Vector3, this.delta(i).multiplyScalar(e).add(this.start)
        },
        applyMatrix4: function(e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
        },
        equals: function(e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        },
        clone: function() {
            return (new THREE.Line3).copy(this)
        }
    }, THREE.Box2 = function(e, t) {
        this.min = void 0 !== e ? e : new THREE.Vector2(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new THREE.Vector2(-1 / 0, -1 / 0)
    }, THREE.Box2.prototype = {
        constructor: THREE.Box2,
        set: function(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; i > t; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function() {
            var e = new THREE.Vector2;
            return function(t, i) {
                var r = e.copy(i).multiplyScalar(.5);
                return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
            }
        }(),
        copy: function(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        empty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        center: function(e) {
            return (e || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(.5)
        },
        size: function(e) {
            return (e || new THREE.Vector2).subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function(e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        containsPoint: function(e) {
            return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y ? !1 : !0
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y ? !0 : !1
        },
        getParameter: function(e, t) {
            return (t || new THREE.Vector2).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        },
        isIntersectionBox: function(e) {
            return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y ? !1 : !0
        },
        clampPoint: function(e, t) {
            return (t || new THREE.Vector2).copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var e = new THREE.Vector2;
            return function(t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        intersect: function(e) {
            return this.min.max(e.min), this.max.min(e.max), this
        },
        union: function(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        translate: function(e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        },
        clone: function() {
            return (new THREE.Box2).copy(this)
        }
    }, THREE.Box3 = function(e, t) {
        this.min = void 0 !== e ? e : new THREE.Vector3(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0)
    }, THREE.Box3.prototype = {
        constructor: THREE.Box3,
        set: function(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; i > t; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function() {
            var e = new THREE.Vector3;
            return function(t, i) {
                var r = e.copy(i).multiplyScalar(.5);
                return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
            }
        }(),
        setFromObject: function() {
            var e = new THREE.Vector3;
            return function(t) {
                var i = this;
                return t.updateMatrixWorld(!0), this.makeEmpty(), t.traverse(function(t) {
                    var r = t.geometry;
                    if (void 0 !== r)
                        if (r instanceof THREE.Geometry)
                            for (var n = r.vertices, r = 0, o = n.length; o > r; r++) e.copy(n[r]), e.applyMatrix4(t.matrixWorld), i.expandByPoint(e);
                        else if (r instanceof THREE.BufferGeometry && void 0 !== r.attributes.position)
                        for (n = r.attributes.position.array, r = 0, o = n.length; o > r; r += 3) e.set(n[r], n[r + 1], n[r + 2]), e.applyMatrix4(t.matrixWorld), i.expandByPoint(e)
                }), this
            }
        }(),
        copy: function(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        empty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        center: function(e) {
            return (e || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(.5)
        },
        size: function(e) {
            return (e || new THREE.Vector3).subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function(e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        containsPoint: function(e) {
            return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z ? !1 : !0
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z ? !0 : !1
        },
        getParameter: function(e, t) {
            return (t || new THREE.Vector3).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        },
        isIntersectionBox: function(e) {
            return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z ? !1 : !0
        },
        clampPoint: function(e, t) {
            return (t || new THREE.Vector3).copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var e = new THREE.Vector3;
            return function(t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        getBoundingSphere: function() {
            var e = new THREE.Vector3;
            return function(t) {
                return t = t || new THREE.Sphere, t.center = this.center(), t.radius = .5 * this.size(e).length(), t
            }
        }(),
        intersect: function(e) {
            return this.min.max(e.min), this.max.min(e.max), this
        },
        union: function(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        applyMatrix4: function() {
            var e = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
            return function(t) {
                return e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.makeEmpty(), this.setFromPoints(e), this
            }
        }(),
        translate: function(e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        },
        clone: function() {
            return (new THREE.Box3).copy(this)
        }
    }, THREE.Matrix3 = function() {
        this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), 0 < arguments.length && THREE.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }, THREE.Matrix3.prototype = {
        constructor: THREE.Matrix3,
        set: function(e, t, i, r, n, o, a, s, l) {
            var h = this.elements;
            return h[0] = e, h[3] = t, h[6] = i, h[1] = r, h[4] = n, h[7] = o, h[2] = a, h[5] = s, h[8] = l, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        copy: function(e) {
            return e = e.elements, this.set(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]), this
        },
        multiplyVector3: function(e) {
            return THREE.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
        },
        multiplyVector3Array: function(e) {
            return THREE.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(e)
        },
        applyToVector3Array: function() {
            var e = new THREE.Vector3;
            return function(t, i, r) {
                void 0 === i && (i = 0), void 0 === r && (r = t.length);
                for (var n = 0; r > n; n += 3, i += 3) e.x = t[i], e.y = t[i + 1], e.z = t[i + 2], e.applyMatrix3(this), t[i] = e.x, t[i + 1] = e.y, t[i + 2] = e.z;
                return t
            }
        }(),
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        },
        determinant: function() {
            var e = this.elements,
                t = e[0],
                i = e[1],
                r = e[2],
                n = e[3],
                o = e[4],
                a = e[5],
                s = e[6],
                l = e[7],
                e = e[8];
            return t * o * e - t * a * l - i * n * e + i * a * s + r * n * l - r * o * s
        },
        getInverse: function(e, t) {
            var i = e.elements,
                r = this.elements;
            if (r[0] = i[10] * i[5] - i[6] * i[9], r[1] = -i[10] * i[1] + i[2] * i[9], r[2] = i[6] * i[1] - i[2] * i[5], r[3] = -i[10] * i[4] + i[6] * i[8], r[4] = i[10] * i[0] - i[2] * i[8], r[5] = -i[6] * i[0] + i[2] * i[4], r[6] = i[9] * i[4] - i[5] * i[8], r[7] = -i[9] * i[0] + i[1] * i[8], r[8] = i[5] * i[0] - i[1] * i[4], i = i[0] * r[0] + i[1] * r[3] + i[2] * r[6], 0 === i) {
                if (t) throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
                return THREE.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0"), this.identity(), this
            }
            return this.multiplyScalar(1 / i), this
        },
        transpose: function() {
            var e, t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
        },
        flattenToArrayOffset: function(e, t) {
            var i = this.elements;
            return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
        },
        getNormalMatrix: function(e) {
            return this.getInverse(e).transpose(), this
        },
        transposeIntoArray: function(e) {
            var t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        },
        fromArray: function(e) {
            return this.elements.set(e), this
        },
        toArray: function() {
            var e = this.elements;
            return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]]
        },
        clone: function() {
            return (new THREE.Matrix3).fromArray(this.elements)
        }
    }, THREE.Matrix4 = function() {
        this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), 0 < arguments.length && THREE.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }, THREE.Matrix4.prototype = {
        constructor: THREE.Matrix4,
        set: function(e, t, i, r, n, o, a, s, l, h, u, c, p, d, f, m) {
            var E = this.elements;
            return E[0] = e, E[4] = t, E[8] = i, E[12] = r, E[1] = n, E[5] = o, E[9] = a, E[13] = s, E[2] = l, E[6] = h, E[10] = u, E[14] = c, E[3] = p, E[7] = d, E[11] = f, E[15] = m, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        copy: function(e) {
            return this.elements.set(e.elements), this
        },
        extractPosition: function(e) {
            return THREE.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
        },
        copyPosition: function(e) {
            var t = this.elements;
            return e = e.elements, t[12] = e[12], t[13] = e[13], t[14] = e[14], this
        },
        extractBasis: function(e, t, i) {
            var r = this.elements;
            return e.set(r[0], r[1], r[2]), t.set(r[4], r[5], r[6]), i.set(r[8], r[9], r[10]), this
        },
        makeBasis: function(e, t, i) {
            return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function() {
            var e = new THREE.Vector3;
            return function(t) {
                var i = this.elements;
                t = t.elements;
                var r = 1 / e.set(t[0], t[1], t[2]).length(),
                    n = 1 / e.set(t[4], t[5], t[6]).length(),
                    o = 1 / e.set(t[8], t[9], t[10]).length();
                return i[0] = t[0] * r, i[1] = t[1] * r, i[2] = t[2] * r, i[4] = t[4] * n, i[5] = t[5] * n, i[6] = t[6] * n, i[8] = t[8] * o, i[9] = t[9] * o, i[10] = t[10] * o, this
            }
        }(),
        makeRotationFromEuler: function(e) {
            !1 == e instanceof THREE.Euler && THREE.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var t = this.elements,
                i = e.x,
                r = e.y,
                n = e.z,
                o = Math.cos(i),
                i = Math.sin(i),
                a = Math.cos(r),
                r = Math.sin(r),
                s = Math.cos(n),
                n = Math.sin(n);
            if ("XYZ" === e.order) {
                e = o * s;
                var l = o * n,
                    h = i * s,
                    u = i * n;
                t[0] = a * s, t[4] = -a * n, t[8] = r, t[1] = l + h * r, t[5] = e - u * r, t[9] = -i * a, t[2] = u - e * r, t[6] = h + l * r, t[10] = o * a
            } else "YXZ" === e.order ? (e = a * s, l = a * n, h = r * s, u = r * n, t[0] = e + u * i, t[4] = h * i - l, t[8] = o * r, t[1] = o * n, t[5] = o * s, t[9] = -i, t[2] = l * i - h, t[6] = u + e * i, t[10] = o * a) : "ZXY" === e.order ? (e = a * s, l = a * n, h = r * s, u = r * n, t[0] = e - u * i, t[4] = -o * n, t[8] = h + l * i, t[1] = l + h * i, t[5] = o * s, t[9] = u - e * i, t[2] = -o * r, t[6] = i, t[10] = o * a) : "ZYX" === e.order ? (e = o * s, l = o * n, h = i * s, u = i * n, t[0] = a * s, t[4] = h * r - l, t[8] = e * r + u, t[1] = a * n, t[5] = u * r + e, t[9] = l * r - h, t[2] = -r, t[6] = i * a, t[10] = o * a) : "YZX" === e.order ? (e = o * a, l = o * r, h = i * a, u = i * r, t[0] = a * s, t[4] = u - e * n, t[8] = h * n + l, t[1] = n, t[5] = o * s, t[9] = -i * s, t[2] = -r * s, t[6] = l * n + h, t[10] = e - u * n) : "XZY" === e.order && (e = o * a, l = o * r, h = i * a, u = i * r, t[0] = a * s, t[4] = -n, t[8] = r * s, t[1] = e * n + u, t[5] = o * s, t[9] = l * n - h, t[2] = h * n - l, t[6] = i * s, t[10] = u * n + e);
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        setRotationFromQuaternion: function(e) {
            return THREE.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
        },
        makeRotationFromQuaternion: function(e) {
            var t = this.elements,
                i = e.x,
                r = e.y,
                n = e.z,
                o = e.w,
                a = i + i,
                s = r + r,
                l = n + n;
            e = i * a;
            var h = i * s,
                i = i * l,
                u = r * s,
                r = r * l,
                n = n * l,
                a = o * a,
                s = o * s,
                o = o * l;
            return t[0] = 1 - (u + n), t[4] = h - o, t[8] = i + s, t[1] = h + o, t[5] = 1 - (e + n), t[9] = r - a, t[2] = i - s, t[6] = r + a, t[10] = 1 - (e + u), t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        lookAt: function() {
            var e = new THREE.Vector3,
                t = new THREE.Vector3,
                i = new THREE.Vector3;
            return function(r, n, o) {
                var a = this.elements;
                return i.subVectors(r, n).normalize(), 0 === i.length() && (i.z = 1), e.crossVectors(o, i).normalize(), 0 === e.length() && (i.x += 1e-4, e.crossVectors(o, i).normalize()), t.crossVectors(i, e), a[0] = e.x, a[4] = t.x, a[8] = i.x, a[1] = e.y, a[5] = t.y, a[9] = i.y, a[2] = e.z, a[6] = t.z, a[10] = i.z, this
            }
        }(),
        multiply: function(e, t) {
            return void 0 !== t ? (THREE.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        },
        multiplyMatrices: function(e, t) {
            var i = e.elements,
                r = t.elements,
                n = this.elements,
                o = i[0],
                a = i[4],
                s = i[8],
                l = i[12],
                h = i[1],
                u = i[5],
                c = i[9],
                p = i[13],
                d = i[2],
                f = i[6],
                m = i[10],
                E = i[14],
                v = i[3],
                g = i[7],
                y = i[11],
                i = i[15],
                T = r[0],
                x = r[4],
                _ = r[8],
                R = r[12],
                b = r[1],
                H = r[5],
                w = r[9],
                M = r[13],
                S = r[2],
                C = r[6],
                A = r[10],
                P = r[14],
                L = r[3],
                D = r[7],
                O = r[11],
                r = r[15];
            return n[0] = o * T + a * b + s * S + l * L, n[4] = o * x + a * H + s * C + l * D, n[8] = o * _ + a * w + s * A + l * O, n[12] = o * R + a * M + s * P + l * r, n[1] = h * T + u * b + c * S + p * L, n[5] = h * x + u * H + c * C + p * D, n[9] = h * _ + u * w + c * A + p * O, n[13] = h * R + u * M + c * P + p * r, n[2] = d * T + f * b + m * S + E * L, n[6] = d * x + f * H + m * C + E * D, n[10] = d * _ + f * w + m * A + E * O, n[14] = d * R + f * M + m * P + E * r, n[3] = v * T + g * b + y * S + i * L, n[7] = v * x + g * H + y * C + i * D, n[11] = v * _ + g * w + y * A + i * O, n[15] = v * R + g * M + y * P + i * r, this
        },
        multiplyToArray: function(e, t, i) {
            var r = this.elements;
            return this.multiplyMatrices(e, t), i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3], i[4] = r[4], i[5] = r[5], i[6] = r[6], i[7] = r[7], i[8] = r[8], i[9] = r[9], i[10] = r[10], i[11] = r[11], i[12] = r[12], i[13] = r[13], i[14] = r[14], i[15] = r[15], this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        },
        multiplyVector3: function(e) {
            return THREE.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), e.applyProjection(this)
        },
        multiplyVector4: function(e) {
            return THREE.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        multiplyVector3Array: function(e) {
            return THREE.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(e)
        },
        applyToVector3Array: function() {
            var e = new THREE.Vector3;
            return function(t, i, r) {
                void 0 === i && (i = 0), void 0 === r && (r = t.length);
                for (var n = 0; r > n; n += 3, i += 3) e.x = t[i], e.y = t[i + 1], e.z = t[i + 2], e.applyMatrix4(this), t[i] = e.x, t[i + 1] = e.y, t[i + 2] = e.z;
                return t
            }
        }(),
        rotateAxis: function(e) {
            THREE.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
        },
        crossVector: function(e) {
            return THREE.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        determinant: function() {
            var e = this.elements,
                t = e[0],
                i = e[4],
                r = e[8],
                n = e[12],
                o = e[1],
                a = e[5],
                s = e[9],
                l = e[13],
                h = e[2],
                u = e[6],
                c = e[10],
                p = e[14];
            return e[3] * (+n * s * u - r * l * u - n * a * c + i * l * c + r * a * p - i * s * p) + e[7] * (+t * s * p - t * l * c + n * o * c - r * o * p + r * l * h - n * s * h) + e[11] * (+t * l * u - t * a * p - n * o * u + i * o * p + n * a * h - i * l * h) + e[15] * (-r * a * h - t * s * u + t * a * c + r * o * u - i * o * c + i * s * h)
        },
        transpose: function() {
            var e = this.elements,
                t;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        },
        flattenToArrayOffset: function(e, t) {
            var i = this.elements;
            return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
        },
        getPosition: function() {
            var e = new THREE.Vector3;
            return function() {
                THREE.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
                var t = this.elements;
                return e.set(t[12], t[13], t[14])
            }
        }(),
        setPosition: function(e) {
            var t = this.elements;
            return t[12] = e.x, t[13] = e.y, t[14] = e.z, this
        },
        getInverse: function(e, t) {
            var i = this.elements,
                r = e.elements,
                n = r[0],
                o = r[4],
                a = r[8],
                s = r[12],
                l = r[1],
                h = r[5],
                u = r[9],
                c = r[13],
                p = r[2],
                d = r[6],
                f = r[10],
                m = r[14],
                E = r[3],
                v = r[7],
                g = r[11],
                r = r[15];
            if (i[0] = u * m * v - c * f * v + c * d * g - h * m * g - u * d * r + h * f * r, i[4] = s * f * v - a * m * v - s * d * g + o * m * g + a * d * r - o * f * r, i[8] = a * c * v - s * u * v + s * h * g - o * c * g - a * h * r + o * u * r, i[12] = s * u * d - a * c * d - s * h * f + o * c * f + a * h * m - o * u * m, i[1] = c * f * E - u * m * E - c * p * g + l * m * g + u * p * r - l * f * r, i[5] = a * m * E - s * f * E + s * p * g - n * m * g - a * p * r + n * f * r, i[9] = s * u * E - a * c * E - s * l * g + n * c * g + a * l * r - n * u * r, i[13] = a * c * p - s * u * p + s * l * f - n * c * f - a * l * m + n * u * m, i[2] = h * m * E - c * d * E + c * p * v - l * m * v - h * p * r + l * d * r, i[6] = s * d * E - o * m * E - s * p * v + n * m * v + o * p * r - n * d * r, i[10] = o * c * E - s * h * E + s * l * v - n * c * v - o * l * r + n * h * r, i[14] = s * h * p - o * c * p - s * l * d + n * c * d + o * l * m - n * h * m, i[3] = u * d * E - h * f * E - u * p * v + l * f * v + h * p * g - l * d * g, i[7] = o * f * E - a * d * E + a * p * v - n * f * v - o * p * g + n * d * g, i[11] = a * h * E - o * u * E - a * l * v + n * u * v + o * l * g - n * h * g, i[15] = o * u * p - a * h * p + a * l * d - n * u * d - o * l * f + n * h * f, i = n * i[0] + l * i[4] + p * i[8] + E * i[12], 0 == i) {
                if (t) throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
                return THREE.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"), this.identity(), this
            }
            return this.multiplyScalar(1 / i), this
        },
        translate: function(e) {
            THREE.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function(e) {
            THREE.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function(e) {
            THREE.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function(e) {
            THREE.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function(e, t) {
            THREE.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        scale: function(e) {
            var t = this.elements,
                i = e.x,
                r = e.y;
            return e = e.z, t[0] *= i, t[4] *= r, t[8] *= e, t[1] *= i, t[5] *= r, t[9] *= e, t[2] *= i, t[6] *= r, t[10] *= e, t[3] *= i, t[7] *= r, t[11] *= e, this
        },
        getMaxScaleOnAxis: function() {
            var e = this.elements;
            return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], Math.max(e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10])))
        },
        makeTranslation: function(e, t, i) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
        },
        makeRotationX: function(e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function(e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function(e) {
            var t = Math.cos(e);
            return e = Math.sin(e), this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function(e, t) {
            var i = Math.cos(t),
                r = Math.sin(t),
                n = 1 - i,
                o = e.x,
                a = e.y,
                s = e.z,
                l = n * o,
                h = n * a;
            return this.set(l * o + i, l * a - r * s, l * s + r * a, 0, l * a + r * s, h * a + i, h * s - r * o, 0, l * s - r * a, h * s + r * o, n * s * s + i, 0, 0, 0, 0, 1), this
        },
        makeScale: function(e, t, i) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
        },
        compose: function(e, t, i) {
            return this.makeRotationFromQuaternion(t), this.scale(i), this.setPosition(e), this
        },
        decompose: function() {
            var e = new THREE.Vector3,
                t = new THREE.Matrix4;
            return function(i, r, n) {
                var o = this.elements,
                    a = e.set(o[0], o[1], o[2]).length(),
                    s = e.set(o[4], o[5], o[6]).length(),
                    l = e.set(o[8], o[9], o[10]).length();
                0 > this.determinant() && (a = -a), i.x = o[12], i.y = o[13], i.z = o[14], t.elements.set(this.elements), i = 1 / a;
                var o = 1 / s,
                    h = 1 / l;
                return t.elements[0] *= i, t.elements[1] *= i, t.elements[2] *= i, t.elements[4] *= o, t.elements[5] *= o, t.elements[6] *= o, t.elements[8] *= h, t.elements[9] *= h, t.elements[10] *= h, r.setFromRotationMatrix(t), n.x = a, n.y = s, n.z = l, this
            }
        }(),
        makeFrustum: function(e, t, i, r, n, o) {
            var a = this.elements;
            return a[0] = 2 * n / (t - e), a[4] = 0, a[8] = (t + e) / (t - e), a[12] = 0, a[1] = 0, a[5] = 2 * n / (r - i), a[9] = (r + i) / (r - i), a[13] = 0, a[2] = 0, a[6] = 0, a[10] = -(o + n) / (o - n), a[14] = -2 * o * n / (o - n), a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
        },
        makePerspective: function(e, t, i, r) {
            e = i * Math.tan(THREE.Math.degToRad(.5 * e));
            var n = -e;
            return this.makeFrustum(n * t, e * t, n, e, i, r)
        },
        makeOrthographic: function(e, t, i, r, n, o) {
            var a = this.elements,
                s = t - e,
                l = i - r,
                h = o - n;
            return a[0] = 2 / s, a[4] = 0, a[8] = 0, a[12] = -((t + e) / s), a[1] = 0, a[5] = 2 / l, a[9] = 0, a[13] = -((i + r) / l), a[2] = 0, a[6] = 0, a[10] = -2 / h, a[14] = -((o + n) / h), a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
        },
        fromArray: function(e) {
            return this.elements.set(e), this
        },
        toArray: function() {
            var e = this.elements;
            return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]]
        },
        clone: function() {
            return (new THREE.Matrix4).fromArray(this.elements)
        }
    }, THREE.Ray = function(e, t) {
        this.origin = void 0 !== e ? e : new THREE.Vector3, this.direction = void 0 !== t ? t : new THREE.Vector3
    }, THREE.Ray.prototype = {
        constructor: THREE.Ray,
        set: function(e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        },
        copy: function(e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        },
        at: function(e, t) {
            return (t || new THREE.Vector3).copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        recast: function() {
            var e = new THREE.Vector3;
            return function(t) {
                return this.origin.copy(this.at(t, e)), this
            }
        }(),
        closestPointToPoint: function(e, t) {
            var i = t || new THREE.Vector3;
            i.subVectors(e, this.origin);
            var r = i.dot(this.direction);
            return 0 > r ? i.copy(this.origin) : i.copy(this.direction).multiplyScalar(r).add(this.origin)
        },
        distanceToPoint: function() {
            var e = new THREE.Vector3;
            return function(t) {
                var i = e.subVectors(t, this.origin).dot(this.direction);
                return 0 > i ? this.origin.distanceTo(t) : (e.copy(this.direction).multiplyScalar(i).add(this.origin), e.distanceTo(t))
            }
        }(),
        distanceSqToSegment: function() {
            var e = new THREE.Vector3,
                t = new THREE.Vector3,
                i = new THREE.Vector3;
            return function(r, n, o, a) {
                e.copy(r).add(n).multiplyScalar(.5), t.copy(n).sub(r).normalize(), i.copy(this.origin).sub(e);
                var s = .5 * r.distanceTo(n),
                    l = -this.direction.dot(t),
                    h = i.dot(this.direction),
                    u = -i.dot(t),
                    c = i.lengthSq(),
                    p = Math.abs(1 - l * l),
                    d;
                return p > 0 ? (r = l * u - h, n = l * h - u, d = s * p, r >= 0 ? n >= -d ? d >= n ? (s = 1 / p, r *= s, n *= s, l = r * (r + l * n + 2 * h) + n * (l * r + n + 2 * u) + c) : (n = s, r = Math.max(0, -(l * n + h)), l = -r * r + n * (n + 2 * u) + c) : (n = -s, r = Math.max(0, -(l * n + h)), l = -r * r + n * (n + 2 * u) + c) : -d >= n ? (r = Math.max(0, -(-l * s + h)), n = r > 0 ? -s : Math.min(Math.max(-s, -u), s), l = -r * r + n * (n + 2 * u) + c) : d >= n ? (r = 0, n = Math.min(Math.max(-s, -u), s), l = n * (n + 2 * u) + c) : (r = Math.max(0, -(l * s + h)), n = r > 0 ? s : Math.min(Math.max(-s, -u), s), l = -r * r + n * (n + 2 * u) + c)) : (n = l > 0 ? -s : s, r = Math.max(0, -(l * n + h)), l = -r * r + n * (n + 2 * u) + c), o && o.copy(this.direction).multiplyScalar(r).add(this.origin), a && a.copy(t).multiplyScalar(n).add(e), l
            }
        }(),
        isIntersectionSphere: function(e) {
            return this.distanceToPoint(e.center) <= e.radius
        },
        intersectSphere: function() {
            var e = new THREE.Vector3;
            return function(t, i) {
                e.subVectors(t.center, this.origin);
                var r = e.dot(this.direction),
                    n = e.dot(e) - r * r,
                    o = t.radius * t.radius;
                return n > o ? null : (o = Math.sqrt(o - n), n = r - o, r += o, 0 > n && 0 > r ? null : 0 > n ? this.at(r, i) : this.at(n, i))
            }
        }(),
        isIntersectionPlane: function(e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || 0 > e.normal.dot(this.direction) * t ? !0 : !1
        },
        distanceToPlane: function(e) {
            var t = e.normal.dot(this.direction);
            return 0 == t ? 0 == e.distanceToPoint(this.origin) ? 0 : null : (e = -(this.origin.dot(e.normal) + e.constant) / t, e >= 0 ? e : null)
        },
        intersectPlane: function(e, t) {
            var i = this.distanceToPlane(e);
            return null === i ? null : this.at(i, t)
        },
        isIntersectionBox: function() {
            var e = new THREE.Vector3;
            return function(t) {
                return null !== this.intersectBox(t, e)
            }
        }(),
        intersectBox: function(e, t) {
            var i, r, n, o, a;
            r = 1 / this.direction.x, o = 1 / this.direction.y, a = 1 / this.direction.z;
            var s = this.origin;
            return r >= 0 ? (i = (e.min.x - s.x) * r, r *= e.max.x - s.x) : (i = (e.max.x - s.x) * r, r *= e.min.x - s.x), o >= 0 ? (n = (e.min.y - s.y) * o, o *= e.max.y - s.y) : (n = (e.max.y - s.y) * o, o *= e.min.y - s.y), i > o || n > r ? null : ((n > i || i !== i) && (i = n), (r > o || r !== r) && (r = o), a >= 0 ? (n = (e.min.z - s.z) * a, a *= e.max.z - s.z) : (n = (e.max.z - s.z) * a, a *= e.min.z - s.z), i > a || n > r ? null : ((n > i || i !== i) && (i = n), (r > a || r !== r) && (r = a), 0 > r ? null : this.at(i >= 0 ? i : r, t)))
        },
        intersectTriangle: function() {
            var e = new THREE.Vector3,
                t = new THREE.Vector3,
                i = new THREE.Vector3,
                r = new THREE.Vector3;
            return function(n, o, a, s, l) {
                if (t.subVectors(o, n), i.subVectors(a, n), r.crossVectors(t, i), o = this.direction.dot(r), o > 0) {
                    if (s) return null;
                    s = 1
                } else {
                    if (!(0 > o)) return null;
                    s = -1, o = -o
                }
                return e.subVectors(this.origin, n), n = s * this.direction.dot(i.crossVectors(e, i)), 0 > n ? null : (a = s * this.direction.dot(t.cross(e)), 0 > a || n + a > o ? null : (n = -s * e.dot(r), 0 > n ? null : this.at(n / o, l)))
            }
        }(),
        applyMatrix4: function(e) {
            return this.direction.add(this.origin).applyMatrix4(e), this.origin.applyMatrix4(e), this.direction.sub(this.origin), this.direction.normalize(), this
        },
        equals: function(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        },
        clone: function() {
            return (new THREE.Ray).copy(this)
        }
    }, THREE.Sphere = function(e, t) {
        this.center = void 0 !== e ? e : new THREE.Vector3, this.radius = void 0 !== t ? t : 0
    }, THREE.Sphere.prototype = {
        constructor: THREE.Sphere,
        set: function(e, t) {
            return this.center.copy(e), this.radius = t, this
        },
        setFromPoints: function() {
            var e = new THREE.Box3;
            return function(t, i) {
                var r = this.center;
                void 0 !== i ? r.copy(i) : e.setFromPoints(t).center(r);
                for (var n = 0, o = 0, a = t.length; a > o; o++) n = Math.max(n, r.distanceToSquared(t[o]));
                return this.radius = Math.sqrt(n), this
            }
        }(),
        copy: function(e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        },
        empty: function() {
            return 0 >= this.radius
        },
        containsPoint: function(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(e) {
            return e.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        },
        clampPoint: function(e, t) {
            var i = this.center.distanceToSquared(e),
                r = t || new THREE.Vector3;
            return r.copy(e), i > this.radius * this.radius && (r.sub(this.center).normalize(), r.multiplyScalar(this.radius).add(this.center)), r
        },
        getBoundingBox: function(e) {
            return e = e || new THREE.Box3, e.set(this.center, this.center), e.expandByScalar(this.radius), e
        },
        applyMatrix4: function(e) {
            return this.center.applyMatrix4(e), this.radius *= e.getMaxScaleOnAxis(), this
        },
        translate: function(e) {
            return this.center.add(e), this
        },
        equals: function(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        },
        clone: function() {
            return (new THREE.Sphere).copy(this)
        }
    }, THREE.Frustum = function(e, t, i, r, n, o) {
        this.planes = [void 0 !== e ? e : new THREE.Plane, void 0 !== t ? t : new THREE.Plane, void 0 !== i ? i : new THREE.Plane, void 0 !== r ? r : new THREE.Plane, void 0 !== n ? n : new THREE.Plane, void 0 !== o ? o : new THREE.Plane]
    }, THREE.Frustum.prototype = {
        constructor: THREE.Frustum,
        set: function(e, t, i, r, n, o) {
            var a = this.planes;
            return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(r), a[4].copy(n), a[5].copy(o), this
        },
        copy: function(e) {
            for (var t = this.planes, i = 0; 6 > i; i++) t[i].copy(e.planes[i]);
            return this
        },
        setFromMatrix: function(e) {
            var t = this.planes,
                i = e.elements;
            e = i[0];
            var r = i[1],
                n = i[2],
                o = i[3],
                a = i[4],
                s = i[5],
                l = i[6],
                h = i[7],
                u = i[8],
                c = i[9],
                p = i[10],
                d = i[11],
                f = i[12],
                m = i[13],
                E = i[14],
                i = i[15];
            return t[0].setComponents(o - e, h - a, d - u, i - f).normalize(), t[1].setComponents(o + e, h + a, d + u, i + f).normalize(), t[2].setComponents(o + r, h + s, d + c, i + m).normalize(), t[3].setComponents(o - r, h - s, d - c, i - m).normalize(), t[4].setComponents(o - n, h - l, d - p, i - E).normalize(), t[5].setComponents(o + n, h + l, d + p, i + E).normalize(), this
        },
        intersectsObject: function() {
            var e = new THREE.Sphere;
            return function(t) {
                var i = t.geometry;
                return null === i.boundingSphere && i.computeBoundingSphere(), e.copy(i.boundingSphere), e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
            }
        }(),
        intersectsSphere: function(e) {
            var t = this.planes,
                i = e.center;
            e = -e.radius;
            for (var r = 0; 6 > r; r++)
                if (t[r].distanceToPoint(i) < e) return !1;
            return !0
        },
        intersectsBox: function() {
            var e = new THREE.Vector3,
                t = new THREE.Vector3;
            return function(i) {
                for (var r = this.planes, n = 0; 6 > n; n++) {
                    var o = r[n];
                    e.x = 0 < o.normal.x ? i.min.x : i.max.x, t.x = 0 < o.normal.x ? i.max.x : i.min.x, e.y = 0 < o.normal.y ? i.min.y : i.max.y, t.y = 0 < o.normal.y ? i.max.y : i.min.y, e.z = 0 < o.normal.z ? i.min.z : i.max.z, t.z = 0 < o.normal.z ? i.max.z : i.min.z;
                    var a = o.distanceToPoint(e),
                        o = o.distanceToPoint(t);
                    if (0 > a && 0 > o) return !1
                }
                return !0
            }
        }(),
        containsPoint: function(e) {
            for (var t = this.planes, i = 0; 6 > i; i++)
                if (0 > t[i].distanceToPoint(e)) return !1;
            return !0
        },
        clone: function() {
            return (new THREE.Frustum).copy(this)
        }
    }, THREE.Plane = function(e, t) {
        this.normal = void 0 !== e ? e : new THREE.Vector3(1, 0, 0), this.constant = void 0 !== t ? t : 0
    }, THREE.Plane.prototype = {
        constructor: THREE.Plane,
        set: function(e, t) {
            return this.normal.copy(e), this.constant = t, this
        },
        setComponents: function(e, t, i, r) {
            return this.normal.set(e, t, i), this.constant = r, this
        },
        setFromNormalAndCoplanarPoint: function(e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        },
        setFromCoplanarPoints: function() {
            var e = new THREE.Vector3,
                t = new THREE.Vector3;
            return function(i, r, n) {
                return r = e.subVectors(n, r).cross(t.subVectors(i, r)).normalize(), this.setFromNormalAndCoplanarPoint(r, i), this
            }
        }(),
        copy: function(e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        },
        normalize: function() {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function(e) {
            return this.normal.dot(e) + this.constant
        },
        distanceToSphere: function(e) {
            return this.distanceToPoint(e.center) - e.radius
        },
        projectPoint: function(e, t) {
            return this.orthoPoint(e, t).sub(e).negate()
        },
        orthoPoint: function(e, t) {
            var i = this.distanceToPoint(e);
            return (t || new THREE.Vector3).copy(this.normal).multiplyScalar(i)
        },
        isIntersectionLine: function(e) {
            var t = this.distanceToPoint(e.start);
            return e = this.distanceToPoint(e.end), 0 > t && e > 0 || 0 > e && t > 0
        },
        intersectLine: function() {
            var e = new THREE.Vector3;
            return function(t, i) {
                var r = i || new THREE.Vector3,
                    n = t.delta(e),
                    o = this.normal.dot(n);
                return 0 != o ? (o = -(t.start.dot(this.normal) + this.constant) / o, 0 > o || o > 1 ? void 0 : r.copy(n).multiplyScalar(o).add(t.start)) : 0 == this.distanceToPoint(t.start) ? r.copy(t.start) : void 0
            }
        }(),
        coplanarPoint: function(e) {
            return (e || new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var e = new THREE.Vector3,
                t = new THREE.Vector3,
                i = new THREE.Matrix3;
            return function(r, n) {
                var o = n || i.getNormalMatrix(r),
                    o = e.copy(this.normal).applyMatrix3(o),
                    a = this.coplanarPoint(t);
                return a.applyMatrix4(r), this.setFromNormalAndCoplanarPoint(o, a), this
            }
        }(),
        translate: function(e) {
            return this.constant -= e.dot(this.normal), this
        },
        equals: function(e) {
            return e.normal.equals(this.normal) && e.constant == this.constant
        },
        clone: function() {
            return (new THREE.Plane).copy(this)
        }
    }, THREE.Math = {
        generateUUID: function() {
            var e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                t = Array(36),
                i = 0,
                r;
            return function() {
                for (var n = 0; 36 > n; n++) 8 == n || 13 == n || 18 == n || 23 == n ? t[n] = "-" : 14 == n ? t[n] = "4" : (2 >= i && (i = 33554432 + 16777216 * Math.random() | 0), r = 15 & i, i >>= 4, t[n] = e[19 == n ? 3 & r | 8 : r]);
                return t.join("")
            }
        }(),
        clamp: function(e, t, i) {
            return t > e ? t : e > i ? i : e
        },
        clampBottom: function(e, t) {
            return t > e ? t : e
        },
        mapLinear: function(e, t, i, r, n) {
            return r + (e - t) * (n - r) / (i - t)
        },
        smoothstep: function(e, t, i) {
            return t >= e ? 0 : e >= i ? 1 : (e = (e - t) / (i - t), e * e * (3 - 2 * e))
        },
        smootherstep: function(e, t, i) {
            return t >= e ? 0 : e >= i ? 1 : (e = (e - t) / (i - t), e * e * e * (e * (6 * e - 15) + 10))
        },
        random16: function() {
            return (65280 * Math.random() + 255 * Math.random()) / 65535
        },
        randInt: function(e, t) {
            return Math.floor(this.randFloat(e, t))
        },
        randFloat: function(e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function(e) {
            return e * (.5 - Math.random())
        },
        degToRad: function() {
            var e = Math.PI / 180;
            return function(t) {
                return t * e
            }
        }(),
        radToDeg: function() {
            var e = 180 / Math.PI;
            return function(t) {
                return t * e
            }
        }(),
        isPowerOfTwo: function(e) {
            return 0 === (e & e - 1) && 0 !== e
        },
        nextPowerOfTwo: function(e) {
            return e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, e++, e
        }
    }, THREE.Spline = function(e) {
        function t(e, t, i, r, n, o, a) {
            return e = .5 * (i - e), r = .5 * (r - t), (2 * (t - i) + e + r) * a + (-3 * (t - i) - 2 * e - r) * o + e * n + t
        }
        this.points = e;
        var i = [],
            r = {
                x: 0,
                y: 0,
                z: 0
            },
            n, o, a, s, l, h, u, c, p;
        this.initFromArray = function(e) {
            this.points = [];
            for (var t = 0; t < e.length; t++) this.points[t] = {
                x: e[t][0],
                y: e[t][1],
                z: e[t][2]
            }
        }, this.getPoint = function(e) {
            return n = (this.points.length - 1) * e, o = Math.floor(n), a = n - o, i[0] = 0 === o ? o : o - 1, i[1] = o, i[2] = o > this.points.length - 2 ? this.points.length - 1 : o + 1, i[3] = o > this.points.length - 3 ? this.points.length - 1 : o + 2, h = this.points[i[0]], u = this.points[i[1]], c = this.points[i[2]], p = this.points[i[3]], s = a * a, l = a * s, r.x = t(h.x, u.x, c.x, p.x, a, s, l), r.y = t(h.y, u.y, c.y, p.y, a, s, l), r.z = t(h.z, u.z, c.z, p.z, a, s, l), r
        }, this.getControlPointsArray = function() {
            var e, t, i = this.points.length,
                r = [];
            for (e = 0; i > e; e++) t = this.points[e], r[e] = [t.x, t.y, t.z];
            return r
        }, this.getLength = function(e) {
            var t, i, r, n = t = t = 0,
                o = new THREE.Vector3,
                a = new THREE.Vector3,
                s = [],
                l = 0;
            for (s[0] = 0, e || (e = 100), i = this.points.length * e, o.copy(this.points[0]), e = 1; i > e; e++) t = e / i, r = this.getPoint(t), a.copy(r), l += a.distanceTo(o), o.copy(r), t *= this.points.length - 1, t = Math.floor(t), t != n && (s[t] = l, n = t);
            return s[s.length] = l, {
                chunks: s,
                total: l
            }
        }, this.reparametrizeByArcLength = function(e) {
            var t, i, r, n, o, a, s = [],
                l = new THREE.Vector3,
                h = this.getLength();
            for (s.push(l.copy(this.points[0]).clone()), t = 1; t < this.points.length; t++) {
                for (i = h.chunks[t] - h.chunks[t - 1], a = Math.ceil(e * i / h.total), n = (t - 1) / (this.points.length - 1), o = t / (this.points.length - 1), i = 1; a - 1 > i; i++) r = n + 1 / a * i * (o - n), r = this.getPoint(r), s.push(l.copy(r).clone());
                s.push(l.copy(this.points[t]).clone())
            }
            this.points = s
        }
    }, THREE.Triangle = function(e, t, i) {
        this.a = void 0 !== e ? e : new THREE.Vector3, this.b = void 0 !== t ? t : new THREE.Vector3, this.c = void 0 !== i ? i : new THREE.Vector3
    }, THREE.Triangle.normal = function() {
        var e = new THREE.Vector3;
        return function(t, i, r, n) {
            return n = n || new THREE.Vector3, n.subVectors(r, i), e.subVectors(t, i), n.cross(e), t = n.lengthSq(), t > 0 ? n.multiplyScalar(1 / Math.sqrt(t)) : n.set(0, 0, 0)
        }
    }(), THREE.Triangle.barycoordFromPoint = function() {
        var e = new THREE.Vector3,
            t = new THREE.Vector3,
            i = new THREE.Vector3;
        return function(r, n, o, a, s) {
            e.subVectors(a, n), t.subVectors(o, n), i.subVectors(r, n), r = e.dot(e), n = e.dot(t), o = e.dot(i);
            var l = t.dot(t);
            a = t.dot(i);
            var h = r * l - n * n;
            return s = s || new THREE.Vector3, 0 == h ? s.set(-2, -1, -1) : (h = 1 / h, l = (l * o - n * a) * h, r = (r * a - n * o) * h, s.set(1 - l - r, r, l))
        }
    }(), THREE.Triangle.containsPoint = function() {
        var e = new THREE.Vector3;
        return function(t, i, r, n) {
            return t = THREE.Triangle.barycoordFromPoint(t, i, r, n, e), 0 <= t.x && 0 <= t.y && 1 >= t.x + t.y
        }
    }(), THREE.Triangle.prototype = {
        constructor: THREE.Triangle,
        set: function(e, t, i) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
        },
        setFromPointsAndIndices: function(e, t, i, r) {
            return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this
        },
        copy: function(e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        },
        area: function() {
            var e = new THREE.Vector3,
                t = new THREE.Vector3;
            return function() {
                return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
            }
        }(),
        midpoint: function(e) {
            return (e || new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        normal: function(e) {
            return THREE.Triangle.normal(this.a, this.b, this.c, e)
        },
        plane: function(e) {
            return (e || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c)
        },
        barycoordFromPoint: function(e, t) {
            return THREE.Triangle.barycoordFromPoint(e, this.a, this.b, this.c, t)
        },
        containsPoint: function(e) {
            return THREE.Triangle.containsPoint(e, this.a, this.b, this.c)
        },
        equals: function(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        },
        clone: function() {
            return (new THREE.Triangle).copy(this)
        }
    }, THREE.Clock = function(e) {
        this.autoStart = void 0 !== e ? e : !0, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
    }, THREE.Clock.prototype = {
        constructor: THREE.Clock,
        start: function() {
            this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), this.running = !0
        },
        stop: function() {
            this.getElapsedTime(), this.running = !1
        },
        getElapsedTime: function() {
            return this.getDelta(), this.elapsedTime
        },
        getDelta: function() {
            var e = 0;
            if (this.autoStart && !this.running && this.start(), this.running) {
                var t = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(),
                    e = .001 * (t - this.oldTime);
                this.oldTime = t, this.elapsedTime += e
            }
            return e
        }
    }, THREE.EventDispatcher = function() {}, THREE.EventDispatcher.prototype = {
        constructor: THREE.EventDispatcher,
        apply: function(e) {
            e.addEventListener = THREE.EventDispatcher.prototype.addEventListener, e.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener, e.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener, e.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
        },
        addEventListener: function(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var i = this._listeners;
            void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t)
        },
        hasEventListener: function(e, t) {
            if (void 0 === this._listeners) return !1;
            var i = this._listeners;
            return void 0 !== i[e] && -1 !== i[e].indexOf(t) ? !0 : !1
        },
        removeEventListener: function(e, t) {
            if (void 0 !== this._listeners) {
                var i = this._listeners[e];
                if (void 0 !== i) {
                    var r = i.indexOf(t); - 1 !== r && i.splice(r, 1)
                }
            }
        },
        dispatchEvent: function(e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    for (var i = [], r = t.length, n = 0; r > n; n++) i[n] = t[n];
                    for (n = 0; r > n; n++) i[n].call(this, e)
                }
            }
        }
    },
    function(e) {
        e.Raycaster = function(t, i, r, n) {
            this.ray = new e.Ray(t, i), this.near = r || 0, this.far = n || 1 / 0, this.params = {
                Sprite: {},
                Mesh: {},
                PointCloud: {
                    threshold: 1
                },
                LOD: {},
                Line: {}
            }
        };
        var t = function(e, t) {
                return e.distance - t.distance
            },
            i = function(e, t, r, n) {
                if (e.raycast(t, r), !0 === n) {
                    e = e.children, n = 0;
                    for (var o = e.length; o > n; n++) i(e[n], t, r, !0)
                }
            };
        e.Raycaster.prototype = {
            constructor: e.Raycaster,
            precision: 1e-4,
            linePrecision: 1,
            set: function(e, t) {
                this.ray.set(e, t)
            },
            setFromCamera: function(t, i) {
                i instanceof e.PerspectiveCamera ? (this.ray.origin.copy(i.position), this.ray.direction.set(t.x, t.y, .5).unproject(i).sub(i.position).normalize()) : i instanceof e.OrthographicCamera ? (this.ray.origin.set(t.x, t.y, -1).unproject(i), this.ray.direction.set(0, 0, -1).transformDirection(i.matrixWorld)) : e.error("THREE.Raycaster: Unsupported camera type.")
            },
            intersectObject: function(e, r) {
                var n = [];
                return i(e, this, n, r), n.sort(t), n
            },
            intersectObjects: function(r, n) {
                var o = [];
                if (!1 == r instanceof Array) return e.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), o;
                for (var a = 0, s = r.length; s > a; a++) i(r[a], this, o, n);
                return o.sort(t), o
            }
        }
    }(THREE), THREE.Object3D = function() {
        Object.defineProperty(this, "id", {
            value: THREE.Object3DIdCount++
        }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Object3D", this.parent = void 0, this.children = [], this.up = THREE.Object3D.DefaultUp.clone();
        var e = new THREE.Vector3,
            t = new THREE.Euler,
            i = new THREE.Quaternion,
            r = new THREE.Vector3(1, 1, 1);
        t.onChange(function() {
            i.setFromEuler(t, !1)
        }), i.onChange(function() {
            t.setFromQuaternion(i, void 0, !1)
        }), Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: e
            },
            rotation: {
                enumerable: !0,
                value: t
            },
            quaternion: {
                enumerable: !0,
                value: i
            },
            scale: {
                enumerable: !0,
                value: r
            }
        }), this.rotationAutoUpdate = !0, this.matrix = new THREE.Matrix4, this.matrixWorld = new THREE.Matrix4, this.matrixAutoUpdate = !0, this.matrixWorldNeedsUpdate = !1, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }, THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0), THREE.Object3D.prototype = {
        constructor: THREE.Object3D,
        get eulerOrder() {
            return THREE.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), this.rotation.order
        },
        set eulerOrder(e) {
            THREE.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order."), this.rotation.order = e
        },
        get useQuaternion() {
            THREE.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        set useQuaternion(e) {
            THREE.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        applyMatrix: function(e) {
            this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        setRotationFromAxisAngle: function(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function(e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function(e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function(e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: function() {
            var e = new THREE.Quaternion;
            return function(t, i) {
                return e.setFromAxisAngle(t, i), this.quaternion.multiply(e), this
            }
        }(),
        rotateX: function() {
            var e = new THREE.Vector3(1, 0, 0);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateY: function() {
            var e = new THREE.Vector3(0, 1, 0);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateZ: function() {
            var e = new THREE.Vector3(0, 0, 1);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        translateOnAxis: function() {
            var e = new THREE.Vector3;
            return function(t, i) {
                return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(i)), this
            }
        }(),
        translate: function(e, t) {
            return THREE.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
        },
        translateX: function() {
            var e = new THREE.Vector3(1, 0, 0);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateY: function() {
            var e = new THREE.Vector3(0, 1, 0);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateZ: function() {
            var e = new THREE.Vector3(0, 0, 1);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        localToWorld: function(e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function() {
            var e = new THREE.Matrix4;
            return function(t) {
                return t.applyMatrix4(e.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function() {
            var e = new THREE.Matrix4;
            return function(t) {
                e.lookAt(t, this.position, this.up), this.quaternion.setFromRotationMatrix(e)
            }
        }(),
        add: function(e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            return e === this ? (THREE.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e instanceof THREE.Object3D ? (void 0 !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
                type: "added"
            }), this.children.push(e)) : THREE.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
        },
        remove: function(e) {
            if (1 < arguments.length)
                for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
            t = this.children.indexOf(e), -1 !== t && (e.parent = void 0, e.dispatchEvent({
                type: "removed"
            }), this.children.splice(t, 1))
        },
        getChildByName: function(e) {
            return THREE.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
        },
        getObjectById: function(e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function(e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function(e, t) {
            if (this[e] === t) return this;
            for (var i = 0, r = this.children.length; r > i; i++) {
                var n = this.children[i].getObjectByProperty(e, t);
                if (void 0 !== n) return n
            }
        },
        getWorldPosition: function(e) {
            return e = e || new THREE.Vector3, this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function() {
            var e = new THREE.Vector3,
                t = new THREE.Vector3;
            return function(i) {
                return i = i || new THREE.Quaternion, this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, i, t), i
            }
        }(),
        getWorldRotation: function() {
            var e = new THREE.Quaternion;
            return function(t) {
                return t = t || new THREE.Euler, this.getWorldQuaternion(e), t.setFromQuaternion(e, this.rotation.order, !1)
            }
        }(),
        getWorldScale: function() {
            var e = new THREE.Vector3,
                t = new THREE.Quaternion;
            return function(i) {
                return i = i || new THREE.Vector3, this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, i), i
            }
        }(),
        getWorldDirection: function() {
            var e = new THREE.Quaternion;
            return function(t) {
                return t = t || new THREE.Vector3, this.getWorldQuaternion(e), t.set(0, 0, 1).applyQuaternion(e)
            }
        }(),
        raycast: function() {},
        traverse: function(e) {
            e(this);
            for (var t = 0, i = this.children.length; i > t; t++) this.children[t].traverse(e)
        },
        traverseVisible: function(e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = 0, i = this.children.length; i > t; t++) this.children[t].traverseVisible(e)
            }
        },
        traverseAncestors: function(e) {
            this.parent && (e(this.parent), this.parent.traverseAncestors(e))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(e) {
            !0 === this.matrixAutoUpdate && this.updateMatrix(), (!0 === this.matrixWorldNeedsUpdate || !0 === e) && (void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
            for (var t = 0, i = this.children.length; i > t; t++) this.children[t].updateMatrixWorld(e)
        },
        toJSON: function() {
            var e = {
                    metadata: {
                        version: 4.3,
                        type: "Object",
                        generator: "ObjectExporter"
                    }
                },
                t = {},
                i = {},
                r = function(t) {
                    if (void 0 === e.materials && (e.materials = []), void 0 === i[t.uuid]) {
                        var r = t.toJSON();
                        delete r.metadata, i[t.uuid] = r, e.materials.push(r)
                    }
                    return t.uuid
                },
                n = function(i) {
                    var o = {};
                    if (o.uuid = i.uuid, o.type = i.type, "" !== i.name && (o.name = i.name), "{}" !== JSON.stringify(i.userData) && (o.userData = i.userData), !0 !== i.visible && (o.visible = i.visible), i instanceof THREE.PerspectiveCamera) o.fov = i.fov, o.aspect = i.aspect, o.near = i.near, o.far = i.far;
                    else if (i instanceof THREE.OrthographicCamera) o.left = i.left, o.right = i.right, o.top = i.top, o.bottom = i.bottom, o.near = i.near, o.far = i.far;
                    else if (i instanceof THREE.AmbientLight) o.color = i.color.getHex();
                    else if (i instanceof THREE.DirectionalLight) o.color = i.color.getHex(), o.intensity = i.intensity;
                    else if (i instanceof THREE.PointLight) o.color = i.color.getHex(), o.intensity = i.intensity, o.distance = i.distance, o.decay = i.decay;
                    else if (i instanceof THREE.SpotLight) o.color = i.color.getHex(), o.intensity = i.intensity, o.distance = i.distance, o.angle = i.angle, o.exponent = i.exponent, o.decay = i.decay;
                    else if (i instanceof THREE.HemisphereLight) o.color = i.color.getHex(), o.groundColor = i.groundColor.getHex();
                    else if (i instanceof THREE.Mesh || i instanceof THREE.Line || i instanceof THREE.PointCloud) {
                        var a = i.geometry;
                        if (void 0 === e.geometries && (e.geometries = []), void 0 === t[a.uuid]) {
                            var s = a.toJSON();
                            delete s.metadata, t[a.uuid] = s, e.geometries.push(s)
                        }
                        o.geometry = a.uuid, o.material = r(i.material), i instanceof THREE.Line && (o.mode = i.mode)
                    } else i instanceof THREE.Sprite && (o.material = r(i.material));
                    if (o.matrix = i.matrix.toArray(), 0 < i.children.length)
                        for (o.children = [], a = 0; a < i.children.length; a++) o.children.push(n(i.children[a]));
                    return o
                };
            return e.object = n(this), e
        },
        clone: function(e, t) {
            if (void 0 === e && (e = new THREE.Object3D), void 0 === t && (t = !0), e.name = this.name, e.up.copy(this.up), e.position.copy(this.position), e.quaternion.copy(this.quaternion), e.scale.copy(this.scale), e.rotationAutoUpdate = this.rotationAutoUpdate, e.matrix.copy(this.matrix), e.matrixWorld.copy(this.matrixWorld), e.matrixAutoUpdate = this.matrixAutoUpdate, e.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate, e.visible = this.visible, e.castShadow = this.castShadow, e.receiveShadow = this.receiveShadow, e.frustumCulled = this.frustumCulled, e.userData = JSON.parse(JSON.stringify(this.userData)), !0 === t)
                for (var i = 0; i < this.children.length; i++) e.add(this.children[i].clone());
            return e
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype), THREE.Object3DIdCount = 0, THREE.Face3 = function(e, t, i, r, n, o) {
        this.a = e, this.b = t, this.c = i, this.normal = r instanceof THREE.Vector3 ? r : new THREE.Vector3, this.vertexNormals = r instanceof Array ? r : [], this.color = n instanceof THREE.Color ? n : new THREE.Color, this.vertexColors = n instanceof Array ? n : [], this.vertexTangents = [], this.materialIndex = void 0 !== o ? o : 0
    }, THREE.Face3.prototype = {
        constructor: THREE.Face3,
        clone: function() {
            var e = new THREE.Face3(this.a, this.b, this.c);
            e.normal.copy(this.normal), e.color.copy(this.color), e.materialIndex = this.materialIndex;
            for (var t = 0, i = this.vertexNormals.length; i > t; t++) e.vertexNormals[t] = this.vertexNormals[t].clone();
            for (t = 0, i = this.vertexColors.length; i > t; t++) e.vertexColors[t] = this.vertexColors[t].clone();
            for (t = 0, i = this.vertexTangents.length; i > t; t++) e.vertexTangents[t] = this.vertexTangents[t].clone();
            return e
        }
    }, THREE.Face4 = function(e, t, i, r, n, o, a) {
        return THREE.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new THREE.Face3(e, t, i, n, o, a)
    }, THREE.BufferAttribute = function(e, t) {
        this.array = e, this.itemSize = t, this.needsUpdate = !1
    }, THREE.BufferAttribute.prototype = {
        constructor: THREE.BufferAttribute,
        get length() {
            return this.array.length
        },
        copyAt: function(e, t, i) {
            e *= this.itemSize, i *= t.itemSize;
            for (var r = 0, n = this.itemSize; n > r; r++) this.array[e + r] = t.array[i + r];
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        },
        setX: function(e, t) {
            return this.array[e * this.itemSize] = t, this
        },
        setY: function(e, t) {
            return this.array[e * this.itemSize + 1] = t, this
        },
        setZ: function(e, t) {
            return this.array[e * this.itemSize + 2] = t, this
        },
        setXY: function(e, t, i) {
            return e *= this.itemSize, this.array[e] = t, this.array[e + 1] = i, this
        },
        setXYZ: function(e, t, i, r) {
            return e *= this.itemSize, this.array[e] = t, this.array[e + 1] = i, this.array[e + 2] = r, this
        },
        setXYZW: function(e, t, i, r, n) {
            return e *= this.itemSize, this.array[e] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = n, this
        },
        clone: function() {
            return new THREE.BufferAttribute(new this.array.constructor(this.array), this.itemSize)
        }
    }, THREE.Int8Attribute = function(e, t) {
        return THREE.warn("THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
    }, THREE.Uint8Attribute = function(e, t) {
        return THREE.warn("THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
    }, THREE.Uint8ClampedAttribute = function(e, t) {
        return THREE.warn("THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
    }, THREE.Int16Attribute = function(e, t) {
        return THREE.warn("THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
    }, THREE.Uint16Attribute = function(e, t) {
        return THREE.warn("THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
    }, THREE.Int32Attribute = function(e, t) {
        return THREE.warn("THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
    }, THREE.Uint32Attribute = function(e, t) {
        return THREE.warn("THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
    }, THREE.Float32Attribute = function(e, t) {
        return THREE.warn("THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
    }, THREE.Float64Attribute = function(e, t) {
        return THREE.warn("THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead."), new THREE.BufferAttribute(e, t)
    }, THREE.DynamicBufferAttribute = function(e, t) {
        THREE.BufferAttribute.call(this, e, t), this.updateRange = {
            offset: 0,
            count: -1
        }
    }, THREE.DynamicBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype), THREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute, THREE.DynamicBufferAttribute.prototype.clone = function() {
        return new THREE.DynamicBufferAttribute(new this.array.constructor(this.array), this.itemSize)
    }, THREE.BufferGeometry = function() {
        Object.defineProperty(this, "id", {
            value: THREE.GeometryIdCount++
        }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "BufferGeometry", this.attributes = {}, this.attributesKeys = [], this.offsets = this.drawcalls = [], this.boundingSphere = this.boundingBox = null
    }, THREE.BufferGeometry.prototype = {
        constructor: THREE.BufferGeometry,
        addAttribute: function(e, t, i) {
            !1 == t instanceof THREE.BufferAttribute ? (THREE.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.attributes[e] = {
                array: t,
                itemSize: i
            }) : (this.attributes[e] = t, this.attributesKeys = Object.keys(this.attributes))
        },
        getAttribute: function(e) {
            return this.attributes[e]
        },
        addDrawCall: function(e, t, i) {
            this.drawcalls.push({
                start: e,
                count: t,
                index: void 0 !== i ? i : 0
            })
        },
        applyMatrix: function(e) {
            var t = this.attributes.position;
            void 0 !== t && (e.applyToVector3Array(t.array), t.needsUpdate = !0), t = this.attributes.normal, void 0 !== t && ((new THREE.Matrix3).getNormalMatrix(e).applyToVector3Array(t.array), t.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere()
        },
        center: function() {
            this.computeBoundingBox();
            var e = this.boundingBox.center().negate();
            return this.applyMatrix((new THREE.Matrix4).setPosition(e)), e
        },
        fromGeometry: function(e, t) {
            t = t || {
                vertexColors: THREE.NoColors
            };
            var i = e.vertices,
                r = e.faces,
                n = e.faceVertexUvs,
                o = t.vertexColors,
                a = 0 < n[0].length,
                s = 3 == r[0].vertexNormals.length,
                l = new Float32Array(9 * r.length);
            this.addAttribute("position", new THREE.BufferAttribute(l, 3));
            var h = new Float32Array(9 * r.length);
            if (this.addAttribute("normal", new THREE.BufferAttribute(h, 3)), o !== THREE.NoColors) {
                var u = new Float32Array(9 * r.length);
                this.addAttribute("color", new THREE.BufferAttribute(u, 3))
            }
            if (!0 === a) {
                var c = new Float32Array(6 * r.length);
                this.addAttribute("uv", new THREE.BufferAttribute(c, 2))
            }
            for (var p = 0, d = 0, f = 0; p < r.length; p++, d += 6, f += 9) {
                var m = r[p],
                    E = i[m.a],
                    v = i[m.b],
                    g = i[m.c];
                l[f] = E.x, l[f + 1] = E.y, l[f + 2] = E.z, l[f + 3] = v.x, l[f + 4] = v.y, l[f + 5] = v.z, l[f + 6] = g.x, l[f + 7] = g.y, l[f + 8] = g.z, !0 === s ? (E = m.vertexNormals[0], v = m.vertexNormals[1], g = m.vertexNormals[2], h[f] = E.x, h[f + 1] = E.y, h[f + 2] = E.z, h[f + 3] = v.x, h[f + 4] = v.y, h[f + 5] = v.z, h[f + 6] = g.x, h[f + 7] = g.y, h[f + 8] = g.z) : (E = m.normal, h[f] = E.x, h[f + 1] = E.y, h[f + 2] = E.z, h[f + 3] = E.x, h[f + 4] = E.y, h[f + 5] = E.z, h[f + 6] = E.x, h[f + 7] = E.y, h[f + 8] = E.z), o === THREE.FaceColors ? (m = m.color, u[f] = m.r, u[f + 1] = m.g, u[f + 2] = m.b, u[f + 3] = m.r, u[f + 4] = m.g, u[f + 5] = m.b, u[f + 6] = m.r, u[f + 7] = m.g, u[f + 8] = m.b) : o === THREE.VertexColors && (E = m.vertexColors[0], v = m.vertexColors[1], m = m.vertexColors[2], u[f] = E.r, u[f + 1] = E.g, u[f + 2] = E.b, u[f + 3] = v.r, u[f + 4] = v.g, u[f + 5] = v.b, u[f + 6] = m.r, u[f + 7] = m.g, u[f + 8] = m.b), !0 === a && (m = n[0][p][0], E = n[0][p][1], v = n[0][p][2], c[d] = m.x, c[d + 1] = m.y, c[d + 2] = E.x, c[d + 3] = E.y, c[d + 4] = v.x, c[d + 5] = v.y)
            }
            return this.computeBoundingSphere(), this
        },
        computeBoundingBox: function() {
            var e = new THREE.Vector3;
            return function() {
                null === this.boundingBox && (this.boundingBox = new THREE.Box3);
                var t = this.attributes.position.array;
                if (t) {
                    var i = this.boundingBox;
                    i.makeEmpty();
                    for (var r = 0, n = t.length; n > r; r += 3) e.set(t[r], t[r + 1], t[r + 2]), i.expandByPoint(e)
                }(void 0 === t || 0 === t.length) && (this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0)), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && THREE.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.')
            }
        }(),
        computeBoundingSphere: function() {
            var e = new THREE.Box3,
                t = new THREE.Vector3;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
                var i = this.attributes.position.array;
                if (i) {
                    e.makeEmpty();
                    for (var r = this.boundingSphere.center, n = 0, o = i.length; o > n; n += 3) t.set(i[n], i[n + 1], i[n + 2]), e.expandByPoint(t);
                    e.center(r);
                    for (var a = 0, n = 0, o = i.length; o > n; n += 3) t.set(i[n], i[n + 1], i[n + 2]), a = Math.max(a, r.distanceToSquared(t));
                    this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && THREE.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var e = this.attributes;
            if (e.position) {
                var t = e.position.array;
                if (void 0 === e.normal) this.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(t.length), 3));
                else
                    for (var i = e.normal.array, r = 0, n = i.length; n > r; r++) i[r] = 0;
                var i = e.normal.array,
                    o, a, s, l = new THREE.Vector3,
                    h = new THREE.Vector3,
                    u = new THREE.Vector3,
                    c = new THREE.Vector3,
                    p = new THREE.Vector3;
                if (e.index)
                    for (var d = e.index.array, f = 0 < this.offsets.length ? this.offsets : [{
                            start: 0,
                            count: d.length,
                            index: 0
                        }], m = 0, E = f.length; E > m; ++m) {
                        n = f[m].start, o = f[m].count;
                        for (var v = f[m].index, r = n, n = n + o; n > r; r += 3) o = 3 * (v + d[r]), a = 3 * (v + d[r + 1]), s = 3 * (v + d[r + 2]), l.fromArray(t, o), h.fromArray(t, a), u.fromArray(t, s), c.subVectors(u, h), p.subVectors(l, h), c.cross(p), i[o] += c.x, i[o + 1] += c.y, i[o + 2] += c.z, i[a] += c.x, i[a + 1] += c.y, i[a + 2] += c.z, i[s] += c.x, i[s + 1] += c.y, i[s + 2] += c.z
                    } else
                        for (r = 0, n = t.length; n > r; r += 9) l.fromArray(t, r), h.fromArray(t, r + 3), u.fromArray(t, r + 6), c.subVectors(u, h), p.subVectors(l, h), c.cross(p), i[r] = c.x, i[r + 1] = c.y, i[r + 2] = c.z, i[r + 3] = c.x, i[r + 4] = c.y, i[r + 5] = c.z, i[r + 6] = c.x, i[r + 7] = c.y, i[r + 8] = c.z;
                this.normalizeNormals(), e.normal.needsUpdate = !0
            }
        },
        computeTangents: function() {
            function e(e, t, i) {
                c.fromArray(r, 3 * e), p.fromArray(r, 3 * t), d.fromArray(r, 3 * i), f.fromArray(o, 2 * e), m.fromArray(o, 2 * t), E.fromArray(o, 2 * i), v = p.x - c.x, g = d.x - c.x, y = p.y - c.y, T = d.y - c.y, x = p.z - c.z, _ = d.z - c.z, R = m.x - f.x, b = E.x - f.x, H = m.y - f.y, w = E.y - f.y, M = 1 / (R * w - b * H), S.set((w * v - H * g) * M, (w * y - H * T) * M, (w * x - H * _) * M), C.set((R * g - b * v) * M, (R * T - b * y) * M, (R * _ - b * x) * M), l[e].add(S), l[t].add(S), l[i].add(S), h[e].add(C), h[t].add(C), h[i].add(C)
            }

            function t(e) {
                B.fromArray(n, 3 * e), z.copy(B), I = l[e], U.copy(I), U.sub(B.multiplyScalar(B.dot(I))).normalize(), N.crossVectors(z, I), j = N.dot(h[e]), V = 0 > j ? -1 : 1, s[4 * e] = U.x, s[4 * e + 1] = U.y, s[4 * e + 2] = U.z, s[4 * e + 3] = V
            }
            if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv) THREE.warn("THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
            else {
                var i = this.attributes.index.array,
                    r = this.attributes.position.array,
                    n = this.attributes.normal.array,
                    o = this.attributes.uv.array,
                    a = r.length / 3;
                void 0 === this.attributes.tangent && this.addAttribute("tangent", new THREE.BufferAttribute(new Float32Array(4 * a), 4));
                for (var s = this.attributes.tangent.array, l = [], h = [], u = 0; a > u; u++) l[u] = new THREE.Vector3, h[u] = new THREE.Vector3;
                var c = new THREE.Vector3,
                    p = new THREE.Vector3,
                    d = new THREE.Vector3,
                    f = new THREE.Vector2,
                    m = new THREE.Vector2,
                    E = new THREE.Vector2,
                    v, g, y, T, x, _, R, b, H, w, M, S = new THREE.Vector3,
                    C = new THREE.Vector3,
                    A, P, L, D, O;
                0 === this.drawcalls.length && this.addDrawCall(0, i.length, 0);
                var F = this.drawcalls,
                    u = 0;
                for (P = F.length; P > u; ++u) {
                    A = F[u].start, L = F[u].count;
                    var k = F[u].index,
                        a = A;
                    for (A += L; A > a; a += 3) L = k + i[a], D = k + i[a + 1], O = k + i[a + 2], e(L, D, O)
                }
                var U = new THREE.Vector3,
                    N = new THREE.Vector3,
                    B = new THREE.Vector3,
                    z = new THREE.Vector3,
                    V, I, j, u = 0;
                for (P = F.length; P > u; ++u)
                    for (A = F[u].start, L = F[u].count, k = F[u].index, a = A, A += L; A > a; a += 3) L = k + i[a], D = k + i[a + 1], O = k + i[a + 2], t(L), t(D), t(O)
            }
        },
        computeOffsets: function(e) {
            void 0 === e && (e = 65535);
            for (var t = this.attributes.index.array, i = this.attributes.position.array, r = t.length / 3, n = new Uint16Array(t.length), o = 0, a = 0, s = [{
                    start: 0,
                    count: 0,
                    index: 0
                }], l = s[0], h = 0, u = 0, c = new Int32Array(6), p = new Int32Array(i.length), d = new Int32Array(i.length), f = 0; f < i.length; f++) p[f] = -1, d[f] = -1;
            for (i = 0; r > i; i++) {
                for (var m = u = 0; 3 > m; m++) f = t[3 * i + m], -1 == p[f] ? (c[2 * m] = f, c[2 * m + 1] = -1, u++) : p[f] < l.index ? (c[2 * m] = f, c[2 * m + 1] = -1, h++) : (c[2 * m] = f, c[2 * m + 1] = p[f]);
                if (a + u > l.index + e)
                    for (l = {
                            start: o,
                            count: 0,
                            index: a
                        }, s.push(l), u = 0; 6 > u; u += 2) m = c[u + 1], m > -1 && m < l.index && (c[u + 1] = -1);
                for (u = 0; 6 > u; u += 2) f = c[u], m = c[u + 1], -1 === m && (m = a++), p[f] = m, d[m] = f, n[o++] = m - l.index, l.count++
            }
            return this.reorderBuffers(n, d, a), this.drawcalls = this.offsets = s
        },
        merge: function(e, t) {
            if (!1 != e instanceof THREE.BufferGeometry) {
                void 0 === t && (t = 0);
                var i = this.attributes,
                    r;
                for (r in i)
                    if (void 0 !== e.attributes[r])
                        for (var n = i[r].array, o = e.attributes[r], a = o.array, s = 0, o = o.itemSize * t; s < a.length; s++, o++) n[o] = a[s];
                return this
            }
            THREE.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
        },
        normalizeNormals: function() {
            for (var e = this.attributes.normal.array, t, i, r, n = 0, o = e.length; o > n; n += 3) t = e[n], i = e[n + 1], r = e[n + 2], t = 1 / Math.sqrt(t * t + i * i + r * r), e[n] *= t, e[n + 1] *= t, e[n + 2] *= t
        },
        reorderBuffers: function(e, t, i) {
            var r = {},
                n;
            for (n in this.attributes) "index" != n && (r[n] = new this.attributes[n].array.constructor(this.attributes[n].itemSize * i));
            for (var o = 0; i > o; o++) {
                var a = t[o];
                for (n in this.attributes)
                    if ("index" != n)
                        for (var s = this.attributes[n].array, l = this.attributes[n].itemSize, h = r[n], u = 0; l > u; u++) h[o * l + u] = s[a * l + u]
            }
            this.attributes.index.array = e;
            for (n in this.attributes) "index" != n && (this.attributes[n].array = r[n], this.attributes[n].numItems = this.attributes[n].itemSize * i)
        },
        toJSON: function() {
            var e = {
                    metadata: {
                        version: 4,
                        type: "BufferGeometry",
                        generator: "BufferGeometryExporter"
                    },
                    uuid: this.uuid,
                    type: this.type,
                    data: {
                        attributes: {}
                    }
                },
                t = this.attributes,
                i = this.offsets,
                r = this.boundingSphere,
                n;
            for (n in t) {
                var o = t[n],
                    a = Array.prototype.slice.call(o.array);
                e.data.attributes[n] = {
                    itemSize: o.itemSize,
                    type: o.array.constructor.name,
                    array: a
                }
            }
            return 0 < i.length && (e.data.offsets = JSON.parse(JSON.stringify(i))), null !== r && (e.data.boundingSphere = {
                center: r.center.toArray(),
                radius: r.radius
            }), e
        },
        clone: function() {
            var e = new THREE.BufferGeometry,
                t;
            for (t in this.attributes) e.addAttribute(t, this.attributes[t].clone());
            t = 0;
            for (var i = this.offsets.length; i > t; t++) {
                var r = this.offsets[t];
                e.offsets.push({
                    start: r.start,
                    index: r.index,
                    count: r.count
                })
            }
            return e
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype), THREE.Geometry = function() {
        Object.defineProperty(this, "id", {
            value: THREE.GeometryIdCount++
        }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphColors = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.hasTangents = !1, this.dynamic = !0, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1
    }, THREE.Geometry.prototype = {
        constructor: THREE.Geometry,
        applyMatrix: function(e) {
            for (var t = (new THREE.Matrix3).getNormalMatrix(e), i = 0, r = this.vertices.length; r > i; i++) this.vertices[i].applyMatrix4(e);
            for (i = 0, r = this.faces.length; r > i; i++) {
                e = this.faces[i], e.normal.applyMatrix3(t).normalize();
                for (var n = 0, o = e.vertexNormals.length; o > n; n++) e.vertexNormals[n].applyMatrix3(t).normalize()
            }
            null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0
        },
        fromBufferGeometry: function(e) {
            for (var t = this, i = e.attributes, r = i.position.array, n = void 0 !== i.index ? i.index.array : void 0, o = void 0 !== i.normal ? i.normal.array : void 0, a = void 0 !== i.color ? i.color.array : void 0, s = void 0 !== i.uv ? i.uv.array : void 0, l = [], h = [], u = i = 0; i < r.length; i += 3, u += 2) t.vertices.push(new THREE.Vector3(r[i], r[i + 1], r[i + 2])), void 0 !== o && l.push(new THREE.Vector3(o[i], o[i + 1], o[i + 2])), void 0 !== a && t.colors.push(new THREE.Color(a[i], a[i + 1], a[i + 2])), void 0 !== s && h.push(new THREE.Vector2(s[u], s[u + 1]));
            var c = function(e, i, r) {
                var n = void 0 !== o ? [l[e].clone(), l[i].clone(), l[r].clone()] : [],
                    u = void 0 !== a ? [t.colors[e].clone(), t.colors[i].clone(), t.colors[r].clone()] : [];
                t.faces.push(new THREE.Face3(e, i, r, n, u)), void 0 !== s && t.faceVertexUvs[0].push([h[e].clone(), h[i].clone(), h[r].clone()])
            };
            if (void 0 !== n)
                if (r = e.drawcalls, 0 < r.length)
                    for (i = 0; i < r.length; i++)
                        for (var u = r[i], p = u.start, d = u.count, f = u.index, u = p, p = p + d; p > u; u += 3) c(f + n[u], f + n[u + 1], f + n[u + 2]);
                else
                    for (i = 0; i < n.length; i += 3) c(n[i], n[i + 1], n[i + 2]);
            else
                for (i = 0; i < r.length / 3; i += 3) c(i, i + 1, i + 2);
            return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
        },
        center: function() {
            this.computeBoundingBox();
            var e = this.boundingBox.center().negate();
            return this.applyMatrix((new THREE.Matrix4).setPosition(e)), e
        },
        computeFaceNormals: function() {
            for (var e = new THREE.Vector3, t = new THREE.Vector3, i = 0, r = this.faces.length; r > i; i++) {
                var n = this.faces[i],
                    o = this.vertices[n.a],
                    a = this.vertices[n.b];
                e.subVectors(this.vertices[n.c], a), t.subVectors(o, a), e.cross(t), e.normalize(), n.normal.copy(e)
            }
        },
        computeVertexNormals: function(e) {
            var t, i, r;
            for (r = Array(this.vertices.length), t = 0, i = this.vertices.length; i > t; t++) r[t] = new THREE.Vector3;
            if (e) {
                var n, o, a, s = new THREE.Vector3,
                    l = new THREE.Vector3;
                for (e = 0, t = this.faces.length; t > e; e++) i = this.faces[e], n = this.vertices[i.a], o = this.vertices[i.b], a = this.vertices[i.c], s.subVectors(a, o), l.subVectors(n, o), s.cross(l), r[i.a].add(s), r[i.b].add(s), r[i.c].add(s)
            } else
                for (e = 0, t = this.faces.length; t > e; e++) i = this.faces[e], r[i.a].add(i.normal), r[i.b].add(i.normal), r[i.c].add(i.normal);
            for (t = 0, i = this.vertices.length; i > t; t++) r[t].normalize();
            for (e = 0, t = this.faces.length; t > e; e++) i = this.faces[e], i.vertexNormals[0] = r[i.a].clone(), i.vertexNormals[1] = r[i.b].clone(), i.vertexNormals[2] = r[i.c].clone()
        },
        computeMorphNormals: function() {
            var e, t, i, r, n;
            for (i = 0, r = this.faces.length; r > i; i++)
                for (n = this.faces[i], n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []), e = 0, t = n.vertexNormals.length; t > e; e++) n.__originalVertexNormals[e] ? n.__originalVertexNormals[e].copy(n.vertexNormals[e]) : n.__originalVertexNormals[e] = n.vertexNormals[e].clone();
            var o = new THREE.Geometry;
            for (o.faces = this.faces, e = 0, t = this.morphTargets.length; t > e; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [], n = this.morphNormals[e].faceNormals;
                    var a = this.morphNormals[e].vertexNormals,
                        s, l;
                    for (i = 0, r = this.faces.length; r > i; i++) s = new THREE.Vector3, l = {
                        a: new THREE.Vector3,
                        b: new THREE.Vector3,
                        c: new THREE.Vector3
                    }, n.push(s), a.push(l)
                }
                for (a = this.morphNormals[e], o.vertices = this.morphTargets[e].vertices, o.computeFaceNormals(), o.computeVertexNormals(), i = 0, r = this.faces.length; r > i; i++) n = this.faces[i], s = a.faceNormals[i], l = a.vertexNormals[i], s.copy(n.normal), l.a.copy(n.vertexNormals[0]), l.b.copy(n.vertexNormals[1]), l.c.copy(n.vertexNormals[2])
            }
            for (i = 0, r = this.faces.length; r > i; i++) n = this.faces[i], n.normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals
        },
        computeTangents: function() {
            var e, t, i, r, n, o, a, s, l, h, u, c, p, d, f, m, E, v = [],
                g = [];
            i = new THREE.Vector3;
            var y = new THREE.Vector3,
                T = new THREE.Vector3,
                x = new THREE.Vector3,
                _ = new THREE.Vector3;
            for (e = 0, t = this.vertices.length; t > e; e++) v[e] = new THREE.Vector3, g[e] = new THREE.Vector3;
            for (e = 0, t = this.faces.length; t > e; e++) n = this.faces[e], o = this.faceVertexUvs[0][e], r = n.a, E = n.b, n = n.c, a = this.vertices[r], s = this.vertices[E], l = this.vertices[n], h = o[0], u = o[1], c = o[2], o = s.x - a.x, p = l.x - a.x, d = s.y - a.y, f = l.y - a.y, s = s.z - a.z, a = l.z - a.z, l = u.x - h.x, m = c.x - h.x, u = u.y - h.y, h = c.y - h.y, c = 1 / (l * h - m * u), i.set((h * o - u * p) * c, (h * d - u * f) * c, (h * s - u * a) * c), y.set((l * p - m * o) * c, (l * f - m * d) * c, (l * a - m * s) * c), v[r].add(i), v[E].add(i), v[n].add(i), g[r].add(y), g[E].add(y), g[n].add(y);
            for (y = ["a", "b", "c", "d"], e = 0, t = this.faces.length; t > e; e++)
                for (n = this.faces[e], i = 0; i < Math.min(n.vertexNormals.length, 3); i++) _.copy(n.vertexNormals[i]), r = n[y[i]], E = v[r], T.copy(E), T.sub(_.multiplyScalar(_.dot(E))).normalize(), x.crossVectors(n.vertexNormals[i], E), r = x.dot(g[r]), r = 0 > r ? -1 : 1, n.vertexTangents[i] = new THREE.Vector4(T.x, T.y, T.z, r);
            this.hasTangents = !0
        },
        computeLineDistances: function() {
            for (var e = 0, t = this.vertices, i = 0, r = t.length; r > i; i++) i > 0 && (e += t[i].distanceTo(t[i - 1])), this.lineDistances[i] = e
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new THREE.Box3), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(e, t, i) {
            if (!1 == e instanceof THREE.Geometry) THREE.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e);
            else {
                var r, n = this.vertices.length,
                    o = this.vertices,
                    a = e.vertices,
                    s = this.faces,
                    l = e.faces,
                    h = this.faceVertexUvs[0];
                e = e.faceVertexUvs[0], void 0 === i && (i = 0), void 0 !== t && (r = (new THREE.Matrix3).getNormalMatrix(t));
                for (var u = 0, c = a.length; c > u; u++) {
                    var p = a[u].clone();
                    void 0 !== t && p.applyMatrix4(t), o.push(p)
                }
                for (u = 0, c = l.length; c > u; u++) {
                    var a = l[u],
                        d, f = a.vertexNormals,
                        m = a.vertexColors,
                        p = new THREE.Face3(a.a + n, a.b + n, a.c + n);
                    for (p.normal.copy(a.normal), void 0 !== r && p.normal.applyMatrix3(r).normalize(), t = 0, o = f.length; o > t; t++) d = f[t].clone(), void 0 !== r && d.applyMatrix3(r).normalize(), p.vertexNormals.push(d);
                    for (p.color.copy(a.color), t = 0, o = m.length; o > t; t++) d = m[t], p.vertexColors.push(d.clone());
                    p.materialIndex = a.materialIndex + i, s.push(p)
                }
                for (u = 0, c = e.length; c > u; u++)
                    if (i = e[u], r = [], void 0 !== i) {
                        for (t = 0, o = i.length; o > t; t++) r.push(i[t].clone());
                        h.push(r)
                    }
            }
        },
        mergeMesh: function(e) {
            !1 == e instanceof THREE.Mesh ? THREE.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e) : (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix))
        },
        mergeVertices: function() {
            var e = {},
                t = [],
                i = [],
                r, n = Math.pow(10, 4),
                o, a;
            for (o = 0, a = this.vertices.length; a > o; o++) r = this.vertices[o], r = Math.round(r.x * n) + "_" + Math.round(r.y * n) + "_" + Math.round(r.z * n), void 0 === e[r] ? (e[r] = o, t.push(this.vertices[o]), i[o] = t.length - 1) : i[o] = i[e[r]];
            for (e = [], o = 0, a = this.faces.length; a > o; o++)
                for (n = this.faces[o], n.a = i[n.a], n.b = i[n.b], n.c = i[n.c], n = [n.a, n.b, n.c], r = 0; 3 > r; r++)
                    if (n[r] == n[(r + 1) % 3]) {
                        e.push(o);
                        break
                    }
            for (o = e.length - 1; o >= 0; o--)
                for (n = e[o], this.faces.splice(n, 1), i = 0, a = this.faceVertexUvs.length; a > i; i++) this.faceVertexUvs[i].splice(n, 1);
            return o = this.vertices.length - t.length, this.vertices = t, o
        },
        toJSON: function() {
            function e(e, t, i) {
                return i ? e | 1 << t : e & ~(1 << t)
            }

            function t(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 !== h[t] ? h[t] : (h[t] = l.length / 3, l.push(e.x, e.y, e.z), h[t])
            }

            function i(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 !== c[t] ? c[t] : (c[t] = u.length, u.push(e.getHex()), c[t])
            }

            function r(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 !== d[t] ? d[t] : (d[t] = p.length / 2, p.push(e.x, e.y), d[t])
            }
            var n = {
                metadata: {
                    version: 4,
                    type: "BufferGeometry",
                    generator: "BufferGeometryExporter"
                },
                uuid: this.uuid,
                type: this.type
            };
            if ("" !== this.name && (n.name = this.name), void 0 !== this.parameters) {
                var o = this.parameters,
                    a;
                for (a in o) void 0 !== o[a] && (n[a] = o[a]);
                return n
            }
            for (o = [], a = 0; a < this.vertices.length; a++) {
                var s = this.vertices[a];
                o.push(s.x, s.y, s.z)
            }
            var s = [],
                l = [],
                h = {},
                u = [],
                c = {},
                p = [],
                d = {};
            for (a = 0; a < this.faces.length; a++) {
                var f = this.faces[a],
                    m = void 0 !== this.faceVertexUvs[0][a],
                    E = 0 < f.normal.length(),
                    v = 0 < f.vertexNormals.length,
                    g = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
                    y = 0 < f.vertexColors.length,
                    T = 0,
                    T = e(T, 0, 0),
                    T = e(T, 1, !1),
                    T = e(T, 2, !1),
                    T = e(T, 3, m),
                    T = e(T, 4, E),
                    T = e(T, 5, v),
                    T = e(T, 6, g),
                    T = e(T, 7, y);
                s.push(T), s.push(f.a, f.b, f.c), m && (m = this.faceVertexUvs[0][a], s.push(r(m[0]), r(m[1]), r(m[2]))), E && s.push(t(f.normal)), v && (E = f.vertexNormals, s.push(t(E[0]), t(E[1]), t(E[2]))), g && s.push(i(f.color)), y && (f = f.vertexColors, s.push(i(f[0]), i(f[1]), i(f[2])))
            }
            return n.data = {}, n.data.vertices = o, n.data.normals = l, 0 < u.length && (n.data.colors = u), 0 < p.length && (n.data.uvs = [p]), n.data.faces = s, n
        },
        clone: function() {
            for (var e = new THREE.Geometry, t = this.vertices, i = 0, r = t.length; r > i; i++) e.vertices.push(t[i].clone());
            for (t = this.faces, i = 0, r = t.length; r > i; i++) e.faces.push(t[i].clone());
            for (i = 0, r = this.faceVertexUvs.length; r > i; i++) {
                t = this.faceVertexUvs[i], void 0 === e.faceVertexUvs[i] && (e.faceVertexUvs[i] = []);
                for (var n = 0, o = t.length; o > n; n++) {
                    for (var a = t[n], s = [], l = 0, h = a.length; h > l; l++) s.push(a[l].clone());
                    e.faceVertexUvs[i].push(s)
                }
            }
            return e
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype), THREE.GeometryIdCount = 0, THREE.Camera = function() {
        THREE.Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new THREE.Matrix4, this.projectionMatrix = new THREE.Matrix4
    }, THREE.Camera.prototype = Object.create(THREE.Object3D.prototype), THREE.Camera.prototype.constructor = THREE.Camera, THREE.Camera.prototype.getWorldDirection = function() {
        var e = new THREE.Quaternion;
        return function(t) {
            return t = t || new THREE.Vector3, this.getWorldQuaternion(e), t.set(0, 0, -1).applyQuaternion(e)
        }
    }(), THREE.Camera.prototype.lookAt = function() {
        var e = new THREE.Matrix4;
        return function(t) {
            e.lookAt(this.position, t, this.up), this.quaternion.setFromRotationMatrix(e)
        }
    }(), THREE.Camera.prototype.clone = function(e) {
        return void 0 === e && (e = new THREE.Camera), THREE.Object3D.prototype.clone.call(this, e), e.matrixWorldInverse.copy(this.matrixWorldInverse), e.projectionMatrix.copy(this.projectionMatrix), e
    }, THREE.CubeCamera = function(e, t, i) {
        THREE.Object3D.call(this), this.type = "CubeCamera";
        var r = new THREE.PerspectiveCamera(90, 1, e, t);
        r.up.set(0, -1, 0), r.lookAt(new THREE.Vector3(1, 0, 0)), this.add(r);
        var n = new THREE.PerspectiveCamera(90, 1, e, t);
        n.up.set(0, -1, 0), n.lookAt(new THREE.Vector3(-1, 0, 0)), this.add(n);
        var o = new THREE.PerspectiveCamera(90, 1, e, t);
        o.up.set(0, 0, 1), o.lookAt(new THREE.Vector3(0, 1, 0)), this.add(o);
        var a = new THREE.PerspectiveCamera(90, 1, e, t);
        a.up.set(0, 0, -1), a.lookAt(new THREE.Vector3(0, -1, 0)), this.add(a);
        var s = new THREE.PerspectiveCamera(90, 1, e, t);
        s.up.set(0, -1, 0), s.lookAt(new THREE.Vector3(0, 0, 1)), this.add(s);
        var l = new THREE.PerspectiveCamera(90, 1, e, t);
        l.up.set(0, -1, 0), l.lookAt(new THREE.Vector3(0, 0, -1)), this.add(l), this.renderTarget = new THREE.WebGLRenderTargetCube(i, i, {
            format: THREE.RGBFormat,
            magFilter: THREE.LinearFilter,
            minFilter: THREE.LinearFilter
        }), this.updateCubeMap = function(e, t) {
            var i = this.renderTarget,
                h = i.generateMipmaps;
            i.generateMipmaps = !1, i.activeCubeFace = 0, e.render(t, r, i), i.activeCubeFace = 1, e.render(t, n, i), i.activeCubeFace = 2, e.render(t, o, i), i.activeCubeFace = 3, e.render(t, a, i), i.activeCubeFace = 4, e.render(t, s, i), i.generateMipmaps = h, i.activeCubeFace = 5, e.render(t, l, i)
        }
    }, THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype), THREE.CubeCamera.prototype.constructor = THREE.CubeCamera, THREE.OrthographicCamera = function(e, t, i, r, n, o) {
        THREE.Camera.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = void 0 !== n ? n : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
    }, THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype), THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera, THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
        var e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            i = (this.right + this.left) / 2,
            r = (this.top + this.bottom) / 2;
        this.projectionMatrix.makeOrthographic(i - e, i + e, r + t, r - t, this.near, this.far)
    }, THREE.OrthographicCamera.prototype.clone = function() {
        var e = new THREE.OrthographicCamera;
        return THREE.Camera.prototype.clone.call(this, e), e.zoom = this.zoom, e.left = this.left, e.right = this.right, e.top = this.top, e.bottom = this.bottom, e.near = this.near, e.far = this.far, e.projectionMatrix.copy(this.projectionMatrix), e
    }, THREE.PerspectiveCamera = function(e, t, i, r) {
        THREE.Camera.call(this), this.type = "PerspectiveCamera", this.zoom = 1, this.fov = void 0 !== e ? e : 50, this.aspect = void 0 !== t ? t : 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== r ? r : 2e3, this.updateProjectionMatrix()
    }, THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype), THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera, THREE.PerspectiveCamera.prototype.setLens = function(e, t) {
        void 0 === t && (t = 24), this.fov = 2 * THREE.Math.radToDeg(Math.atan(t / (2 * e))), this.updateProjectionMatrix()
    }, THREE.PerspectiveCamera.prototype.setViewOffset = function(e, t, i, r, n, o) {
        this.fullWidth = e, this.fullHeight = t, this.x = i, this.y = r, this.width = n, this.height = o, this.updateProjectionMatrix()
    }, THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
        var e = THREE.Math.radToDeg(2 * Math.atan(Math.tan(.5 * THREE.Math.degToRad(this.fov)) / this.zoom));
        if (this.fullWidth) {
            var t = this.fullWidth / this.fullHeight,
                e = Math.tan(THREE.Math.degToRad(.5 * e)) * this.near,
                i = -e,
                r = t * i,
                t = Math.abs(t * e - r),
                i = Math.abs(e - i);
            this.projectionMatrix.makeFrustum(r + this.x * t / this.fullWidth, r + (this.x + this.width) * t / this.fullWidth, e - (this.y + this.height) * i / this.fullHeight, e - this.y * i / this.fullHeight, this.near, this.far)
        } else this.projectionMatrix.makePerspective(e, this.aspect, this.near, this.far)
    }, THREE.PerspectiveCamera.prototype.clone = function() {
        var e = new THREE.PerspectiveCamera;
        return THREE.Camera.prototype.clone.call(this, e), e.zoom = this.zoom, e.fov = this.fov, e.aspect = this.aspect, e.near = this.near, e.far = this.far, e.projectionMatrix.copy(this.projectionMatrix), e
    }, THREE.Light = function(e) {
        THREE.Object3D.call(this), this.type = "Light", this.color = new THREE.Color(e)
    }, THREE.Light.prototype = Object.create(THREE.Object3D.prototype), THREE.Light.prototype.constructor = THREE.Light, THREE.Light.prototype.clone = function(e) {
        return void 0 === e && (e = new THREE.Light), THREE.Object3D.prototype.clone.call(this, e), e.color.copy(this.color), e
    }, THREE.AmbientLight = function(e) {
        THREE.Light.call(this, e), this.type = "AmbientLight"
    }, THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype), THREE.AmbientLight.prototype.constructor = THREE.AmbientLight, THREE.AmbientLight.prototype.clone = function() {
        var e = new THREE.AmbientLight;
        return THREE.Light.prototype.clone.call(this, e), e
    }, THREE.AreaLight = function(e, t) {
        THREE.Light.call(this, e), this.type = "AreaLight", this.normal = new THREE.Vector3(0, -1, 0), this.right = new THREE.Vector3(1, 0, 0), this.intensity = void 0 !== t ? t : 1, this.height = this.width = 1, this.constantAttenuation = 1.5, this.linearAttenuation = .5, this.quadraticAttenuation = .1
    }, THREE.AreaLight.prototype = Object.create(THREE.Light.prototype), THREE.AreaLight.prototype.constructor = THREE.AreaLight, THREE.DirectionalLight = function(e, t) {
        THREE.Light.call(this, e), this.type = "DirectionalLight", this.position.set(0, 1, 0), this.target = new THREE.Object3D, this.intensity = void 0 !== t ? t : 1, this.onlyShadow = this.castShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraLeft = -500, this.shadowCameraTop = this.shadowCameraRight = 500, this.shadowCameraBottom = -500, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapHeight = this.shadowMapWidth = 512, this.shadowCascade = !1, this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1e3), this.shadowCascadeCount = 2, this.shadowCascadeBias = [0, 0, 0], this.shadowCascadeWidth = [512, 512, 512], this.shadowCascadeHeight = [512, 512, 512], this.shadowCascadeNearZ = [-1, .99, .998], this.shadowCascadeFarZ = [.99, .998, 1], this.shadowCascadeArray = [], this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
    }, THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight, THREE.DirectionalLight.prototype.clone = function() {
        var e = new THREE.DirectionalLight;
        return THREE.Light.prototype.clone.call(this, e), e.target = this.target.clone(), e.intensity = this.intensity, e.castShadow = this.castShadow, e.onlyShadow = this.onlyShadow, e.shadowCameraNear = this.shadowCameraNear, e.shadowCameraFar = this.shadowCameraFar, e.shadowCameraLeft = this.shadowCameraLeft, e.shadowCameraRight = this.shadowCameraRight, e.shadowCameraTop = this.shadowCameraTop, e.shadowCameraBottom = this.shadowCameraBottom, e.shadowCameraVisible = this.shadowCameraVisible, e.shadowBias = this.shadowBias, e.shadowDarkness = this.shadowDarkness, e.shadowMapWidth = this.shadowMapWidth, e.shadowMapHeight = this.shadowMapHeight, e.shadowCascade = this.shadowCascade, e.shadowCascadeOffset.copy(this.shadowCascadeOffset), e.shadowCascadeCount = this.shadowCascadeCount, e.shadowCascadeBias = this.shadowCascadeBias.slice(0), e.shadowCascadeWidth = this.shadowCascadeWidth.slice(0), e.shadowCascadeHeight = this.shadowCascadeHeight.slice(0), e.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0), e.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0), e
    }, THREE.HemisphereLight = function(e, t, i) {
        THREE.Light.call(this, e), this.type = "HemisphereLight", this.position.set(0, 100, 0), this.groundColor = new THREE.Color(t), this.intensity = void 0 !== i ? i : 1
    }, THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype), THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight, THREE.HemisphereLight.prototype.clone = function() {
        var e = new THREE.HemisphereLight;
        return THREE.Light.prototype.clone.call(this, e), e.groundColor.copy(this.groundColor), e.intensity = this.intensity, e
    }, THREE.PointLight = function(e, t, i, r) {
        THREE.Light.call(this, e), this.type = "PointLight", this.intensity = void 0 !== t ? t : 1, this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== r ? r : 1
    }, THREE.PointLight.prototype = Object.create(THREE.Light.prototype), THREE.PointLight.prototype.constructor = THREE.PointLight, THREE.PointLight.prototype.clone = function() {
        var e = new THREE.PointLight;
        return THREE.Light.prototype.clone.call(this, e), e.intensity = this.intensity, e.distance = this.distance, e.decay = this.decay, e
    }, THREE.SpotLight = function(e, t, i, r, n, o) {
        THREE.Light.call(this, e), this.type = "SpotLight", this.position.set(0, 1, 0), this.target = new THREE.Object3D, this.intensity = void 0 !== t ? t : 1, this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.exponent = void 0 !== n ? n : 10, this.decay = void 0 !== o ? o : 1, this.onlyShadow = this.castShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraFov = 50, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapHeight = this.shadowMapWidth = 512, this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
    }, THREE.SpotLight.prototype = Object.create(THREE.Light.prototype), THREE.SpotLight.prototype.constructor = THREE.SpotLight, THREE.SpotLight.prototype.clone = function() {
        var e = new THREE.SpotLight;
        return THREE.Light.prototype.clone.call(this, e), e.target = this.target.clone(), e.intensity = this.intensity, e.distance = this.distance, e.angle = this.angle, e.exponent = this.exponent, e.decay = this.decay, e.castShadow = this.castShadow, e.onlyShadow = this.onlyShadow, e.shadowCameraNear = this.shadowCameraNear, e.shadowCameraFar = this.shadowCameraFar, e.shadowCameraFov = this.shadowCameraFov, e.shadowCameraVisible = this.shadowCameraVisible, e.shadowBias = this.shadowBias, e.shadowDarkness = this.shadowDarkness, e.shadowMapWidth = this.shadowMapWidth, e.shadowMapHeight = this.shadowMapHeight, e
    }, THREE.Cache = {
        files: {},
        add: function(e, t) {
            this.files[e] = t
        },
        get: function(e) {
            return this.files[e]
        },
        remove: function(e) {
            delete this.files[e]
        },
        clear: function() {
            this.files = {}
        }
    }, THREE.Loader = function(e) {
        this.statusDomElement = (this.showStatus = e) ? THREE.Loader.prototype.addStatusElement() : null, this.imageLoader = new THREE.ImageLoader, this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
    }, THREE.Loader.prototype = {
        constructor: THREE.Loader,
        crossOrigin: void 0,
        addStatusElement: function() {
            var e = document.createElement("div");
            return e.style.position = "absolute", e.style.right = "0px", e.style.top = "0px", e.style.fontSize = "0.8em", e.style.textAlign = "left", e.style.background = "rgba(0,0,0,0.25)", e.style.color = "#fff", e.style.width = "120px", e.style.padding = "0.5em 0.5em 0.5em 0.5em", e.style.zIndex = 1e3, e.innerHTML = "Loading ...", e
        },
        updateProgress: function(e) {
            var t = "Loaded ",
                t = e.total ? t + ((100 * e.loaded / e.total).toFixed(0) + "%") : t + ((e.loaded / 1024).toFixed(2) + " KB");
            this.statusDomElement.innerHTML = t
        },
        extractUrlBase: function(e) {
            return e = e.split("/"), 1 === e.length ? "./" : (e.pop(), e.join("/") + "/")
        },
        initMaterials: function(e, t) {
            for (var i = [], r = 0; r < e.length; ++r) i[r] = this.createMaterial(e[r], t);
            return i
        },
        needsTangents: function(e) {
            for (var t = 0, i = e.length; i > t; t++)
                if (e[t] instanceof THREE.ShaderMaterial) return !0;
            return !1
        },
        createMaterial: function(e, t) {
            function i(e) {
                return e = Math.log(e) / Math.LN2, Math.pow(2, Math.round(e))
            }

            function r(e, r, n, a, s, l, h) {
                var u = t + n,
                    c, p = THREE.Loader.Handlers.get(u);
                null !== p ? c = p.load(u) : (c = new THREE.Texture, p = o.imageLoader, p.crossOrigin = o.crossOrigin, p.load(u, function(e) {
                    if (!1 === THREE.Math.isPowerOfTwo(e.width) || !1 === THREE.Math.isPowerOfTwo(e.height)) {
                        var t = i(e.width),
                            r = i(e.height),
                            n = document.createElement("canvas");
                        n.width = t, n.height = r, n.getContext("2d").drawImage(e, 0, 0, t, r), c.image = n
                    } else c.image = e;
                    c.needsUpdate = !0
                })), c.sourceFile = n, a && (c.repeat.set(a[0], a[1]), 1 !== a[0] && (c.wrapS = THREE.RepeatWrapping), 1 !== a[1] && (c.wrapT = THREE.RepeatWrapping)), s && c.offset.set(s[0], s[1]), l && (n = {
                    repeat: THREE.RepeatWrapping,
                    mirror: THREE.MirroredRepeatWrapping
                }, void 0 !== n[l[0]] && (c.wrapS = n[l[0]]), void 0 !== n[l[1]] && (c.wrapT = n[l[1]])), h && (c.anisotropy = h), e[r] = c
            }

            function n(e) {
                return (255 * e[0] << 16) + (255 * e[1] << 8) + 255 * e[2]
            }
            var o = this,
                a = "MeshLambertMaterial",
                s = {
                    color: 15658734,
                    opacity: 1,
                    map: null,
                    lightMap: null,
                    normalMap: null,
                    bumpMap: null,
                    wireframe: !1
                };
            if (e.shading) {
                var l = e.shading.toLowerCase();
                "phong" === l ? a = "MeshPhongMaterial" : "basic" === l && (a = "MeshBasicMaterial")
            }
            return void 0 !== e.blending && void 0 !== THREE[e.blending] && (s.blending = THREE[e.blending]), void 0 !== e.transparent && (s.transparent = e.transparent), void 0 !== e.opacity && 1 > e.opacity && (s.transparent = !0), void 0 !== e.depthTest && (s.depthTest = e.depthTest), void 0 !== e.depthWrite && (s.depthWrite = e.depthWrite), void 0 !== e.visible && (s.visible = e.visible), void 0 !== e.flipSided && (s.side = THREE.BackSide), void 0 !== e.doubleSided && (s.side = THREE.DoubleSide), void 0 !== e.wireframe && (s.wireframe = e.wireframe), void 0 !== e.vertexColors && ("face" === e.vertexColors ? s.vertexColors = THREE.FaceColors : e.vertexColors && (s.vertexColors = THREE.VertexColors)), e.colorDiffuse ? s.color = n(e.colorDiffuse) : e.DbgColor && (s.color = e.DbgColor), e.colorSpecular && (s.specular = n(e.colorSpecular)), e.colorEmissive && (s.emissive = n(e.colorEmissive)), void 0 !== e.transparency && (console.warn("THREE.Loader: transparency has been renamed to opacity"), e.opacity = e.transparency), void 0 !== e.opacity && (s.opacity = e.opacity), e.specularCoef && (s.shininess = e.specularCoef), e.mapDiffuse && t && r(s, "map", e.mapDiffuse, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy), e.mapLight && t && r(s, "lightMap", e.mapLight, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy), e.mapBump && t && r(s, "bumpMap", e.mapBump, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy), e.mapNormal && t && r(s, "normalMap", e.mapNormal, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy), e.mapSpecular && t && r(s, "specularMap", e.mapSpecular, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy), e.mapAlpha && t && r(s, "alphaMap", e.mapAlpha, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy), e.mapBumpScale && (s.bumpScale = e.mapBumpScale), e.mapNormalFactor && (s.normalScale = new THREE.Vector2(e.mapNormalFactor, e.mapNormalFactor)), a = new THREE[a](s), void 0 !== e.DbgName && (a.name = e.DbgName), a
        }
    }, THREE.Loader.Handlers = {
        handlers: [],
        add: function(e, t) {
            this.handlers.push(e, t)
        },
        get: function(e) {
            for (var t = 0, i = this.handlers.length; i > t; t += 2) {
                var r = this.handlers[t + 1];
                if (this.handlers[t].test(e)) return r
            }
            return null
        }
    }, THREE.XHRLoader = function(e) {
        this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
    }, THREE.XHRLoader.prototype = {
        constructor: THREE.XHRLoader,
        load: function(e, t, i, r) {
            var n = this,
                o = THREE.Cache.get(e);
            void 0 !== o ? t && t(o) : (o = new XMLHttpRequest, o.open("GET", e, !0), o.addEventListener("load", function(i) {
                THREE.Cache.add(e, this.response), t && t(this.response), n.manager.itemEnd(e)
            }, !1), void 0 !== i && o.addEventListener("progress", function(e) {
                i(e)
            }, !1), void 0 !== r && o.addEventListener("error", function(e) {
                r(e)
            }, !1), void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), void 0 !== this.responseType && (o.responseType = this.responseType), o.send(null), n.manager.itemStart(e))
        },
        setResponseType: function(e) {
            this.responseType = e
        },
        setCrossOrigin: function(e) {
            this.crossOrigin = e
        }
    }, THREE.ImageLoader = function(e) {
        this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
    }, THREE.ImageLoader.prototype = {
        constructor: THREE.ImageLoader,
        load: function(e, t, i, r) {
            var n = this,
                o = THREE.Cache.get(e);
            return void 0 === o ? (o = document.createElement("img"), o.addEventListener("load", function(i) {
                THREE.Cache.add(e, this), t && t(this), n.manager.itemEnd(e)
            }, !1), void 0 !== i && o.addEventListener("progress", function(e) {
                i(e)
            }, !1), void 0 !== r && o.addEventListener("error", function(e) {
                r(e)
            }, !1), void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), o.src = e, n.manager.itemStart(e), o) : void t(o)
        },
        setCrossOrigin: function(e) {
            this.crossOrigin = e
        }
    }, THREE.JSONLoader = function(e) {
        THREE.Loader.call(this, e), this.withCredentials = !1
    }, THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype), THREE.JSONLoader.prototype.constructor = THREE.JSONLoader, THREE.JSONLoader.prototype.load = function(e, t, i) {
        i = i && "string" == typeof i ? i : this.extractUrlBase(e), this.onLoadStart(), this.loadAjaxJSON(this, e, t, i)
    }, THREE.JSONLoader.prototype.loadAjaxJSON = function(e, t, i, r, n) {
        var o = new XMLHttpRequest,
            a = 0;
        o.onreadystatechange = function() {
            if (o.readyState === o.DONE)
                if (200 === o.status || 0 === o.status) {
                    if (o.responseText) {
                        var s = JSON.parse(o.responseText),
                            l = s.metadata;
                        if (void 0 !== l) {
                            if ("object" === l.type) return void THREE.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.");
                            if ("scene" === l.type) return void THREE.error("THREE.JSONLoader: " + t + " seems to be a Scene. Use THREE.SceneLoader instead.")
                        }
                        s = e.parse(s, r), i(s.geometry, s.materials)
                    } else THREE.error("THREE.JSONLoader: " + t + " seems to be unreachable or the file is empty.");
                    e.onLoadComplete()
                } else THREE.error("THREE.JSONLoader: Couldn't load " + t + " (" + o.status + ")");
            else o.readyState === o.LOADING ? n && (0 === a && (a = o.getResponseHeader("Content-Length")), n({
                total: a,
                loaded: o.responseText.length
            })) : o.readyState === o.HEADERS_RECEIVED && void 0 !== n && (a = o.getResponseHeader("Content-Length"))
        }, o.open("GET", t, !0), o.withCredentials = this.withCredentials, o.send(null)
    }, THREE.JSONLoader.prototype.parse = function(e, t) {
        var i = new THREE.Geometry,
            r = void 0 !== e.scale ? 1 / e.scale : 1;
        return function(t) {
                var r, n, o, a, s, l, h, u, c, p, d, f, m, E = e.faces;
                l = e.vertices;
                var v = e.normals,
                    g = e.colors,
                    y = 0;
                if (void 0 !== e.uvs) {
                    for (r = 0; r < e.uvs.length; r++) e.uvs[r].length && y++;
                    for (r = 0; y > r; r++) i.faceVertexUvs[r] = []
                }
                for (a = 0, s = l.length; s > a;) r = new THREE.Vector3, r.x = l[a++] * t, r.y = l[a++] * t, r.z = l[a++] * t, i.vertices.push(r);
                for (a = 0, s = E.length; s > a;)
                    if (t = E[a++], c = 1 & t, o = 2 & t, r = 8 & t, h = 16 & t, p = 32 & t, l = 64 & t, t &= 128, c) {
                        if (c = new THREE.Face3, c.a = E[a], c.b = E[a + 1], c.c = E[a + 3], d = new THREE.Face3, d.a = E[a + 1], d.b = E[a + 2], d.c = E[a + 3], a += 4, o && (o = E[a++], c.materialIndex = o, d.materialIndex = o), o = i.faces.length, r)
                            for (r = 0; y > r; r++)
                                for (f = e.uvs[r], i.faceVertexUvs[r][o] = [], i.faceVertexUvs[r][o + 1] = [], n = 0; 4 > n; n++) u = E[a++], m = f[2 * u], u = f[2 * u + 1], m = new THREE.Vector2(m, u), 2 !== n && i.faceVertexUvs[r][o].push(m), 0 !== n && i.faceVertexUvs[r][o + 1].push(m);
                        if (h && (h = 3 * E[a++], c.normal.set(v[h++], v[h++], v[h]), d.normal.copy(c.normal)), p)
                            for (r = 0; 4 > r; r++) h = 3 * E[a++], p = new THREE.Vector3(v[h++], v[h++], v[h]), 2 !== r && c.vertexNormals.push(p), 0 !== r && d.vertexNormals.push(p);
                        if (l && (l = E[a++], l = g[l], c.color.setHex(l), d.color.setHex(l)), t)
                            for (r = 0; 4 > r; r++) l = E[a++], l = g[l], 2 !== r && c.vertexColors.push(new THREE.Color(l)), 0 !== r && d.vertexColors.push(new THREE.Color(l));
                        i.faces.push(c), i.faces.push(d)
                    } else {
                        if (c = new THREE.Face3, c.a = E[a++], c.b = E[a++], c.c = E[a++], o && (o = E[a++], c.materialIndex = o), o = i.faces.length, r)
                            for (r = 0; y > r; r++)
                                for (f = e.uvs[r], i.faceVertexUvs[r][o] = [], n = 0; 3 > n; n++) u = E[a++], m = f[2 * u], u = f[2 * u + 1], m = new THREE.Vector2(m, u), i.faceVertexUvs[r][o].push(m);
                        if (h && (h = 3 * E[a++], c.normal.set(v[h++], v[h++], v[h])), p)
                            for (r = 0; 3 > r; r++) h = 3 * E[a++], p = new THREE.Vector3(v[h++], v[h++], v[h]), c.vertexNormals.push(p);
                        if (l && (l = E[a++], c.color.setHex(g[l])), t)
                            for (r = 0; 3 > r; r++) l = E[a++], c.vertexColors.push(new THREE.Color(g[l]));
                        i.faces.push(c)
                    }
            }(r),
            function() {
                var t = void 0 !== e.influencesPerVertex ? e.influencesPerVertex : 2;
                if (e.skinWeights)
                    for (var r = 0, n = e.skinWeights.length; n > r; r += t) i.skinWeights.push(new THREE.Vector4(e.skinWeights[r], t > 1 ? e.skinWeights[r + 1] : 0, t > 2 ? e.skinWeights[r + 2] : 0, t > 3 ? e.skinWeights[r + 3] : 0));
                if (e.skinIndices)
                    for (r = 0, n = e.skinIndices.length; n > r; r += t) i.skinIndices.push(new THREE.Vector4(e.skinIndices[r], t > 1 ? e.skinIndices[r + 1] : 0, t > 2 ? e.skinIndices[r + 2] : 0, t > 3 ? e.skinIndices[r + 3] : 0));
                i.bones = e.bones, i.bones && 0 < i.bones.length && (i.skinWeights.length !== i.skinIndices.length || i.skinIndices.length !== i.vertices.length) && THREE.warn("THREE.JSONLoader: When skinning, number of vertices (" + i.vertices.length + "), skinIndices (" + i.skinIndices.length + "), and skinWeights (" + i.skinWeights.length + ") should match."), i.animation = e.animation, i.animations = e.animations
            }(),
            function(t) {
                if (void 0 !== e.morphTargets) {
                    var r, n, o, a, s, l;
                    for (r = 0, n = e.morphTargets.length; n > r; r++)
                        for (i.morphTargets[r] = {}, i.morphTargets[r].name = e.morphTargets[r].name, i.morphTargets[r].vertices = [], s = i.morphTargets[r].vertices, l = e.morphTargets[r].vertices, o = 0, a = l.length; a > o; o += 3) {
                            var h = new THREE.Vector3;
                            h.x = l[o] * t, h.y = l[o + 1] * t, h.z = l[o + 2] * t, s.push(h)
                        }
                }
                if (void 0 !== e.morphColors)
                    for (r = 0, n = e.morphColors.length; n > r; r++)
                        for (i.morphColors[r] = {}, i.morphColors[r].name = e.morphColors[r].name, i.morphColors[r].colors = [], a = i.morphColors[r].colors, s = e.morphColors[r].colors, t = 0, o = s.length; o > t; t += 3) l = new THREE.Color(16755200), l.setRGB(s[t], s[t + 1], s[t + 2]), a.push(l)
            }(r), i.computeFaceNormals(), i.computeBoundingSphere(), void 0 === e.materials || 0 === e.materials.length ? {
                geometry: i
            } : (r = this.initMaterials(e.materials, t), this.needsTangents(r) && i.computeTangents(), {
                geometry: i,
                materials: r
            })
    }, THREE.LoadingManager = function(e, t, i) {
        var r = this,
            n = 0,
            o = 0;
        this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(e) {
            o++
        }, this.itemEnd = function(e) {
            n++, void 0 !== r.onProgress && r.onProgress(e, n, o), n === o && void 0 !== r.onLoad && r.onLoad()
        }
    }, THREE.DefaultLoadingManager = new THREE.LoadingManager, THREE.BufferGeometryLoader = function(e) {
        this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
    }, THREE.BufferGeometryLoader.prototype = {
        constructor: THREE.BufferGeometryLoader,
        load: function(e, t, i, r) {
            var n = this,
                o = new THREE.XHRLoader(n.manager);
            o.setCrossOrigin(this.crossOrigin), o.load(e, function(e) {
                t(n.parse(JSON.parse(e)))
            }, i, r)
        },
        setCrossOrigin: function(e) {
            this.crossOrigin = e
        },
        parse: function(e) {
            var t = new THREE.BufferGeometry,
                i = e.data.attributes,
                r;
            for (r in i) {
                var n = i[r],
                    o = new self[n.type](n.array);
                t.addAttribute(r, new THREE.BufferAttribute(o, n.itemSize))
            }
            return i = e.data.offsets, void 0 !== i && (t.offsets = JSON.parse(JSON.stringify(i))), e = e.data.boundingSphere, void 0 !== e && (i = new THREE.Vector3, void 0 !== e.center && i.fromArray(e.center), t.boundingSphere = new THREE.Sphere(i, e.radius)), t
        }
    }, THREE.MaterialLoader = function(e) {
        this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
    }, THREE.MaterialLoader.prototype = {
        constructor: THREE.MaterialLoader,
        load: function(e, t, i, r) {
            var n = this,
                o = new THREE.XHRLoader(n.manager);
            o.setCrossOrigin(this.crossOrigin), o.load(e, function(e) {
                t(n.parse(JSON.parse(e)))
            }, i, r)
        },
        setCrossOrigin: function(e) {
            this.crossOrigin = e
        },
        parse: function(e) {
            var t = new THREE[e.type];
            if (void 0 !== e.color && t.color.setHex(e.color), void 0 !== e.emissive && t.emissive.setHex(e.emissive), void 0 !== e.specular && t.specular.setHex(e.specular), void 0 !== e.shininess && (t.shininess = e.shininess), void 0 !== e.uniforms && (t.uniforms = e.uniforms), void 0 !== e.vertexShader && (t.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (t.fragmentShader = e.fragmentShader), void 0 !== e.vertexColors && (t.vertexColors = e.vertexColors), void 0 !== e.shading && (t.shading = e.shading), void 0 !== e.blending && (t.blending = e.blending), void 0 !== e.side && (t.side = e.side), void 0 !== e.opacity && (t.opacity = e.opacity), void 0 !== e.transparent && (t.transparent = e.transparent), void 0 !== e.wireframe && (t.wireframe = e.wireframe), void 0 !== e.size && (t.size = e.size), void 0 !== e.sizeAttenuation && (t.sizeAttenuation = e.sizeAttenuation), void 0 !== e.materials)
                for (var i = 0, r = e.materials.length; r > i; i++) t.materials.push(this.parse(e.materials[i]));
            return t
        }
    }, THREE.ObjectLoader = function(e) {
        this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager, this.texturePath = ""
    }, THREE.ObjectLoader.prototype = {
        constructor: THREE.ObjectLoader,
        load: function(e, t, i, r) {
            "" === this.texturePath && (this.texturePath = e.substring(0, e.lastIndexOf("/") + 1));
            var n = this,
                o = new THREE.XHRLoader(n.manager);
            o.setCrossOrigin(this.crossOrigin), o.load(e, function(e) {
                n.parse(JSON.parse(e), t)
            }, i, r)
        },
        setTexturePath: function(e) {
            this.texturePath = e
        },
        setCrossOrigin: function(e) {
            this.crossOrigin = e
        },
        parse: function(e, t) {
            var i = this.parseGeometries(e.geometries),
                r = this.parseImages(e.images, function() {
                    void 0 !== t && t(n)
                }),
                r = this.parseTextures(e.textures, r),
                r = this.parseMaterials(e.materials, r),
                n = this.parseObject(e.object, i, r);
            return void 0 !== e.images && 0 !== e.images.length || void 0 === t || t(n), n
        },
        parseGeometries: function(e) {
            var t = {};
            if (void 0 !== e)
                for (var i = new THREE.JSONLoader, r = new THREE.BufferGeometryLoader, n = 0, o = e.length; o > n; n++) {
                    var a, s = e[n];
                    switch (s.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            a = new THREE[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "CubeGeometry":
                            a = new THREE.BoxGeometry(s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                            break;
                        case "CircleGeometry":
                            a = new THREE.CircleGeometry(s.radius, s.segments);
                            break;
                        case "CylinderGeometry":
                            a = new THREE.CylinderGeometry(s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded);
                            break;
                        case "SphereGeometry":
                            a = new THREE.SphereGeometry(s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                            break;
                        case "IcosahedronGeometry":
                            a = new THREE.IcosahedronGeometry(s.radius, s.detail);
                            break;
                        case "TorusGeometry":
                            a = new THREE.TorusGeometry(s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                            break;
                        case "TorusKnotGeometry":
                            a = new THREE.TorusKnotGeometry(s.radius, s.tube, s.radialSegments, s.tubularSegments, s.p, s.q, s.heightScale);
                            break;
                        case "BufferGeometry":
                            a = r.parse(s);
                            break;
                        case "Geometry":
                            a = i.parse(s.data).geometry
                    }
                    a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), t[s.uuid] = a
                }
            return t
        },
        parseMaterials: function(e, t) {
            var i = {};
            if (void 0 !== e)
                for (var r = function(e) {
                        return void 0 === t[e] && THREE.warn("THREE.ObjectLoader: Undefined texture", e), t[e]
                    }, n = new THREE.MaterialLoader, o = 0, a = e.length; a > o; o++) {
                    var s = e[o],
                        l = n.parse(s);
                    l.uuid = s.uuid, void 0 !== s.name && (l.name = s.name), void 0 !== s.map && (l.map = r(s.map)), void 0 !== s.bumpMap && (l.bumpMap = r(s.bumpMap), s.bumpScale && (l.bumpScale = new THREE.Vector2(s.bumpScale, s.bumpScale))), void 0 !== s.alphaMap && (l.alphaMap = r(s.alphaMap)), void 0 !== s.envMap && (l.envMap = r(s.envMap)), void 0 !== s.normalMap && (l.normalMap = r(s.normalMap), s.normalScale && (l.normalScale = new THREE.Vector2(s.normalScale, s.normalScale))), void 0 !== s.lightMap && (l.lightMap = r(s.lightMap)), void 0 !== s.specularMap && (l.specularMap = r(s.specularMap)), i[s.uuid] = l
                }
            return i
        },
        parseImages: function(e, t) {
            var i = this,
                r = {};
            if (void 0 !== e && 0 < e.length) {
                var n = new THREE.LoadingManager(t),
                    o = new THREE.ImageLoader(n);
                o.setCrossOrigin(this.crossOrigin);
                for (var n = function(e) {
                        return i.manager.itemStart(e), o.load(e, function() {
                            i.manager.itemEnd(e)
                        })
                    }, a = 0, s = e.length; s > a; a++) {
                    var l = e[a],
                        h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : i.texturePath + l.url;
                    r[l.uuid] = n(h)
                }
            }
            return r
        },
        parseTextures: function(e, t) {
            var i = {};
            if (void 0 !== e)
                for (var r = 0, n = e.length; n > r; r++) {
                    var o = e[r];
                    void 0 === o.image && THREE.warn('THREE.ObjectLoader: No "image" speficied for', o.uuid), void 0 === t[o.image] && THREE.warn("THREE.ObjectLoader: Undefined image", o.image);
                    var a = new THREE.Texture(t[o.image]);
                    a.needsUpdate = !0, a.uuid = o.uuid, void 0 !== o.name && (a.name = o.name), void 0 !== o.repeat && (a.repeat = new THREE.Vector2(o.repeat[0], o.repeat[1])), void 0 !== o.minFilter && (a.minFilter = THREE[o.minFilter]), void 0 !== o.magFilter && (a.magFilter = THREE[o.magFilter]), void 0 !== o.anisotropy && (a.anisotropy = o.anisotropy), o.wrap instanceof Array && (a.wrapS = THREE[o.wrap[0]], a.wrapT = THREE[o.wrap[1]]), i[o.uuid] = a
                }
            return i
        },
        parseObject: function() {
            var e = new THREE.Matrix4;
            return function(t, i, r) {
                var n;
                n = function(e) {
                    return void 0 === i[e] && THREE.warn("THREE.ObjectLoader: Undefined geometry", e), i[e]
                };
                var o = function(e) {
                    return void 0 === r[e] && THREE.warn("THREE.ObjectLoader: Undefined material", e), r[e]
                };
                switch (t.type) {
                    case "Scene":
                        n = new THREE.Scene;
                        break;
                    case "PerspectiveCamera":
                        n = new THREE.PerspectiveCamera(t.fov, t.aspect, t.near, t.far);
                        break;
                    case "OrthographicCamera":
                        n = new THREE.OrthographicCamera(t.left, t.right, t.top, t.bottom, t.near, t.far);
                        break;
                    case "AmbientLight":
                        n = new THREE.AmbientLight(t.color);
                        break;
                    case "DirectionalLight":
                        n = new THREE.DirectionalLight(t.color, t.intensity);
                        break;
                    case "PointLight":
                        n = new THREE.PointLight(t.color, t.intensity, t.distance, t.decay);
                        break;
                    case "SpotLight":
                        n = new THREE.SpotLight(t.color, t.intensity, t.distance, t.angle, t.exponent, t.decay);
                        break;
                    case "HemisphereLight":
                        n = new THREE.HemisphereLight(t.color, t.groundColor, t.intensity);
                        break;
                    case "Mesh":
                        n = new THREE.Mesh(n(t.geometry), o(t.material));
                        break;
                    case "Line":
                        n = new THREE.Line(n(t.geometry), o(t.material), t.mode);
                        break;
                    case "PointCloud":
                        n = new THREE.PointCloud(n(t.geometry), o(t.material));
                        break;
                    case "Sprite":
                        n = new THREE.Sprite(o(t.material));
                        break;
                    case "Group":
                        n = new THREE.Group;
                        break;
                    default:
                        n = new THREE.Object3D
                }
                if (n.uuid = t.uuid, void 0 !== t.name && (n.name = t.name), void 0 !== t.matrix ? (e.fromArray(t.matrix), e.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== t.position && n.position.fromArray(t.position), void 0 !== t.rotation && n.rotation.fromArray(t.rotation), void 0 !== t.scale && n.scale.fromArray(t.scale)), void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.userData && (n.userData = t.userData), void 0 !== t.children)
                    for (var a in t.children) n.add(this.parseObject(t.children[a], i, r));
                return n
            }
        }()
    }, THREE.TextureLoader = function(e) {
        this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
    }, THREE.TextureLoader.prototype = {
        constructor: THREE.TextureLoader,
        load: function(e, t, i, r) {
            var n = new THREE.ImageLoader(this.manager);
            n.setCrossOrigin(this.crossOrigin), n.load(e, function(e) {
                e = new THREE.Texture(e), e.needsUpdate = !0, void 0 !== t && t(e)
            }, i, r)
        },
        setCrossOrigin: function(e) {
            this.crossOrigin = e
        }
    }, THREE.DataTextureLoader = THREE.BinaryTextureLoader = function() {
        this._parser = null
    }, THREE.BinaryTextureLoader.prototype = {
        constructor: THREE.BinaryTextureLoader,
        load: function(e, t, i, r) {
            var n = this,
                o = new THREE.DataTexture,
                a = new THREE.XHRLoader;
            return a.setResponseType("arraybuffer"), a.load(e, function(e) {
                (e = n._parser(e)) && (void 0 !== e.image ? o.image = e.image : void 0 !== e.data && (o.image.width = e.width, o.image.height = e.height, o.image.data = e.data), o.wrapS = void 0 !== e.wrapS ? e.wrapS : THREE.ClampToEdgeWrapping, o.wrapT = void 0 !== e.wrapT ? e.wrapT : THREE.ClampToEdgeWrapping, o.magFilter = void 0 !== e.magFilter ? e.magFilter : THREE.LinearFilter, o.minFilter = void 0 !== e.minFilter ? e.minFilter : THREE.LinearMipMapLinearFilter, o.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1, void 0 !== e.format && (o.format = e.format), void 0 !== e.type && (o.type = e.type), void 0 !== e.mipmaps && (o.mipmaps = e.mipmaps), 1 === e.mipmapCount && (o.minFilter = THREE.LinearFilter), o.needsUpdate = !0, t && t(o, e))
            }, i, r), o
        }
    }, THREE.CompressedTextureLoader = function() {
        this._parser = null
    }, THREE.CompressedTextureLoader.prototype = {
        constructor: THREE.CompressedTextureLoader,
        load: function(e, t, i) {
            var r = this,
                n = [],
                o = new THREE.CompressedTexture;
            o.image = n;
            var a = new THREE.XHRLoader;
            if (a.setResponseType("arraybuffer"), e instanceof Array) {
                var s = 0;
                i = function(i) {
                    a.load(e[i], function(e) {
                        e = r._parser(e, !0), n[i] = {
                            width: e.width,
                            height: e.height,
                            format: e.format,
                            mipmaps: e.mipmaps
                        }, s += 1, 6 === s && (1 == e.mipmapCount && (o.minFilter = THREE.LinearFilter), o.format = e.format, o.needsUpdate = !0, t && t(o))
                    })
                };
                for (var l = 0, h = e.length; h > l; ++l) i(l)
            } else a.load(e, function(e) {
                if (e = r._parser(e, !0), e.isCubemap)
                    for (var i = e.mipmaps.length / e.mipmapCount, a = 0; i > a; a++) {
                        n[a] = {
                            mipmaps: []
                        };
                        for (var s = 0; s < e.mipmapCount; s++) n[a].mipmaps.push(e.mipmaps[a * e.mipmapCount + s]), n[a].format = e.format, n[a].width = e.width, n[a].height = e.height
                    } else o.image.width = e.width, o.image.height = e.height, o.mipmaps = e.mipmaps;
                1 === e.mipmapCount && (o.minFilter = THREE.LinearFilter), o.format = e.format, o.needsUpdate = !0, t && t(o)
            });
            return o
        }
    }, THREE.Material = function() {
        Object.defineProperty(this, "id", {
            value: THREE.MaterialIdCount++
        }), this.uuid = THREE.Math.generateUUID(), this.name = "", this.type = "Material", this.side = THREE.FrontSide, this.opacity = 1, this.transparent = !1, this.blending = THREE.NormalBlending, this.blendSrc = THREE.SrcAlphaFactor, this.blendDst = THREE.OneMinusSrcAlphaFactor, this.blendEquation = THREE.AddEquation, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.colorWrite = this.depthWrite = this.depthTest = !0, this.polygonOffset = !1, this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this._needsUpdate = this.visible = !0
    }, THREE.Material.prototype = {
        constructor: THREE.Material,
        get needsUpdate() {
            return this._needsUpdate
        },
        set needsUpdate(e) {
            !0 === e && this.update(), this._needsUpdate = e
        },
        setValues: function(e) {
            if (void 0 !== e)
                for (var t in e) {
                    var i = e[t];
                    if (void 0 === i) THREE.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    else if (t in this) {
                        var r = this[t];
                        r instanceof THREE.Color ? r.set(i) : r instanceof THREE.Vector3 && i instanceof THREE.Vector3 ? r.copy(i) : this[t] = "overdraw" == t ? Number(i) : i
                    }
                }
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.2,
                    type: "material",
                    generator: "MaterialExporter"
                },
                uuid: this.uuid,
                type: this.type
            };
            return "" !== this.name && (e.name = this.name), this instanceof THREE.MeshBasicMaterial ? (e.color = this.color.getHex(), this.vertexColors !== THREE.NoColors && (e.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (e.blending = this.blending), this.side !== THREE.FrontSide && (e.side = this.side)) : this instanceof THREE.MeshLambertMaterial ? (e.color = this.color.getHex(), e.emissive = this.emissive.getHex(), this.vertexColors !== THREE.NoColors && (e.vertexColors = this.vertexColors), this.shading !== THREE.SmoothShading && (e.shading = this.shading), this.blending !== THREE.NormalBlending && (e.blending = this.blending), this.side !== THREE.FrontSide && (e.side = this.side)) : this instanceof THREE.MeshPhongMaterial ? (e.color = this.color.getHex(), e.emissive = this.emissive.getHex(), e.specular = this.specular.getHex(), e.shininess = this.shininess, this.vertexColors !== THREE.NoColors && (e.vertexColors = this.vertexColors), this.shading !== THREE.SmoothShading && (e.shading = this.shading), this.blending !== THREE.NormalBlending && (e.blending = this.blending), this.side !== THREE.FrontSide && (e.side = this.side)) : this instanceof THREE.MeshNormalMaterial ? (this.blending !== THREE.NormalBlending && (e.blending = this.blending), this.side !== THREE.FrontSide && (e.side = this.side)) : this instanceof THREE.MeshDepthMaterial ? (this.blending !== THREE.NormalBlending && (e.blending = this.blending), this.side !== THREE.FrontSide && (e.side = this.side)) : this instanceof THREE.PointCloudMaterial ? (e.size = this.size, e.sizeAttenuation = this.sizeAttenuation, e.color = this.color.getHex(), this.vertexColors !== THREE.NoColors && (e.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (e.blending = this.blending)) : this instanceof THREE.ShaderMaterial ? (e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader) : this instanceof THREE.SpriteMaterial && (e.color = this.color.getHex()), 1 > this.opacity && (e.opacity = this.opacity), !1 !== this.transparent && (e.transparent = this.transparent), !1 !== this.wireframe && (e.wireframe = this.wireframe), e
        },
        clone: function(e) {
            return void 0 === e && (e = new THREE.Material), e.name = this.name, e.side = this.side, e.opacity = this.opacity, e.transparent = this.transparent, e.blending = this.blending, e.blendSrc = this.blendSrc, e.blendDst = this.blendDst, e.blendEquation = this.blendEquation, e.blendSrcAlpha = this.blendSrcAlpha, e.blendDstAlpha = this.blendDstAlpha, e.blendEquationAlpha = this.blendEquationAlpha, e.depthTest = this.depthTest, e.depthWrite = this.depthWrite, e.polygonOffset = this.polygonOffset, e.polygonOffsetFactor = this.polygonOffsetFactor, e.polygonOffsetUnits = this.polygonOffsetUnits, e.alphaTest = this.alphaTest, e.overdraw = this.overdraw, e.visible = this.visible, e
        },
        update: function() {
            this.dispatchEvent({
                type: "update"
            })
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Material.prototype), THREE.MaterialIdCount = 0, THREE.LineBasicMaterial = function(e) {
        THREE.Material.call(this), this.type = "LineBasicMaterial", this.color = new THREE.Color(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(e)
    }, THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial, THREE.LineBasicMaterial.prototype.clone = function() {
        var e = new THREE.LineBasicMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.linewidth = this.linewidth, e.linecap = this.linecap, e.linejoin = this.linejoin, e.vertexColors = this.vertexColors, e.fog = this.fog, e
    }, THREE.LineDashedMaterial = function(e) {
        THREE.Material.call(this), this.type = "LineDashedMaterial", this.color = new THREE.Color(16777215), this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.vertexColors = !1, this.fog = !0, this.setValues(e)
    }, THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial, THREE.LineDashedMaterial.prototype.clone = function() {
        var e = new THREE.LineDashedMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.linewidth = this.linewidth, e.scale = this.scale, e.dashSize = this.dashSize, e.gapSize = this.gapSize, e.vertexColors = this.vertexColors, e.fog = this.fog, e
    }, THREE.MeshBasicMaterial = function(e) {
        THREE.Material.call(this), this.type = "MeshBasicMaterial", this.color = new THREE.Color(16777215), this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphTargets = this.skinning = !1, this.setValues(e)
    }, THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial, THREE.MeshBasicMaterial.prototype.clone = function() {
        var e = new THREE.MeshBasicMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.lightMap = this.lightMap, e.specularMap = this.specularMap, e.alphaMap = this.alphaMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e
    }, THREE.MeshLambertMaterial = function(e) {
        THREE.Material.call(this), this.type = "MeshLambertMaterial", this.color = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.wrapAround = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }, THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial, THREE.MeshLambertMaterial.prototype.clone = function() {
        var e = new THREE.MeshLambertMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.emissive.copy(this.emissive), e.wrapAround = this.wrapAround, e.wrapRGB.copy(this.wrapRGB), e.map = this.map, e.lightMap = this.lightMap, e.specularMap = this.specularMap, e.alphaMap = this.alphaMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
    }, THREE.MeshPhongMaterial = function(e) {
        THREE.Material.call(this), this.type = "MeshPhongMaterial", this.color = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.specular = new THREE.Color(1118481), this.shininess = 30, this.wrapAround = this.metal = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.bumpMap = this.lightMap = this.map = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new THREE.Vector2(1, 1), this.envMap = this.alphaMap = this.specularMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
    }, THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial, THREE.MeshPhongMaterial.prototype.clone = function() {
        var e = new THREE.MeshPhongMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.emissive.copy(this.emissive), e.specular.copy(this.specular), e.shininess = this.shininess, e.metal = this.metal, e.wrapAround = this.wrapAround, e.wrapRGB.copy(this.wrapRGB), e.map = this.map, e.lightMap = this.lightMap, e.bumpMap = this.bumpMap, e.bumpScale = this.bumpScale, e.normalMap = this.normalMap, e.normalScale.copy(this.normalScale), e.specularMap = this.specularMap, e.alphaMap = this.alphaMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
    }, THREE.MeshDepthMaterial = function(e) {
        THREE.Material.call(this), this.type = "MeshDepthMaterial", this.wireframe = this.morphTargets = !1, this.wireframeLinewidth = 1, this.setValues(e)
    }, THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial, THREE.MeshDepthMaterial.prototype.clone = function() {
        var e = new THREE.MeshDepthMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e
    }, THREE.MeshNormalMaterial = function(e) {
        THREE.Material.call(this, e), this.type = "MeshNormalMaterial", this.wireframe = !1, this.wireframeLinewidth = 1, this.morphTargets = !1, this.setValues(e)
    }, THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial, THREE.MeshNormalMaterial.prototype.clone = function() {
        var e = new THREE.MeshNormalMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e
    }, THREE.MeshFaceMaterial = function(e) {
        this.uuid = THREE.Math.generateUUID(), this.type = "MeshFaceMaterial", this.materials = e instanceof Array ? e : []
    }, THREE.MeshFaceMaterial.prototype = {
        constructor: THREE.MeshFaceMaterial,
        toJSON: function() {
            for (var e = {
                    metadata: {
                        version: 4.2,
                        type: "material",
                        generator: "MaterialExporter"
                    },
                    uuid: this.uuid,
                    type: this.type,
                    materials: []
                }, t = 0, i = this.materials.length; i > t; t++) e.materials.push(this.materials[t].toJSON());
            return e
        },
        clone: function() {
            for (var e = new THREE.MeshFaceMaterial, t = 0; t < this.materials.length; t++) e.materials.push(this.materials[t].clone());
            return e
        }
    }, THREE.PointCloudMaterial = function(e) {
        THREE.Material.call(this), this.type = "PointCloudMaterial", this.color = new THREE.Color(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.vertexColors = THREE.NoColors, this.fog = !0, this.setValues(e)
    }, THREE.PointCloudMaterial.prototype = Object.create(THREE.Material.prototype), THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial, THREE.PointCloudMaterial.prototype.clone = function() {
        var e = new THREE.PointCloudMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.size = this.size, e.sizeAttenuation = this.sizeAttenuation, e.vertexColors = this.vertexColors, e.fog = this.fog, e
    }, THREE.ParticleBasicMaterial = function(e) {
        return THREE.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial."), new THREE.PointCloudMaterial(e)
    }, THREE.ParticleSystemMaterial = function(e) {
        return THREE.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial."), new THREE.PointCloudMaterial(e)
    }, THREE.ShaderMaterial = function(e) {
        THREE.Material.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.attributes = null, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.shading = THREE.SmoothShading, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.setValues(e)
    }, THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype), THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial, THREE.ShaderMaterial.prototype.clone = function() {
        var e = new THREE.ShaderMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.fragmentShader = this.fragmentShader, e.vertexShader = this.vertexShader, e.uniforms = THREE.UniformsUtils.clone(this.uniforms), e.attributes = this.attributes, e.defines = this.defines, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.fog = this.fog, e.lights = this.lights, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
    }, THREE.RawShaderMaterial = function(e) {
        THREE.ShaderMaterial.call(this, e), this.type = "RawShaderMaterial"
    }, THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype), THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial, THREE.RawShaderMaterial.prototype.clone = function() {
        var e = new THREE.RawShaderMaterial;
        return THREE.ShaderMaterial.prototype.clone.call(this, e), e
    }, THREE.SpriteMaterial = function(e) {
        THREE.Material.call(this), this.type = "SpriteMaterial", this.color = new THREE.Color(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.setValues(e)
    }, THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial, THREE.SpriteMaterial.prototype.clone = function() {
        var e = new THREE.SpriteMaterial;
        return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.rotation = this.rotation, e.fog = this.fog, e
    }, THREE.Texture = function(e, t, i, r, n, o, a, s, l) {
        Object.defineProperty(this, "id", {
            value: THREE.TextureIdCount++
        }), this.uuid = THREE.Math.generateUUID(), this.sourceFile = this.name = "", this.image = void 0 !== e ? e : THREE.Texture.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : THREE.Texture.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== r ? r : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== n ? n : THREE.LinearFilter, this.minFilter = void 0 !== o ? o : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== a ? a : THREE.RGBAFormat, this.type = void 0 !== s ? s : THREE.UnsignedByteType, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this._needsUpdate = !1, this.onUpdate = null
    }, THREE.Texture.DEFAULT_IMAGE = void 0, THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping, THREE.Texture.prototype = {
        constructor: THREE.Texture,
        get needsUpdate() {
            return this._needsUpdate
        },
        set needsUpdate(e) {
            !0 === e && this.update(), this._needsUpdate = e
        },
        clone: function(e) {
            return void 0 === e && (e = new THREE.Texture), e.image = this.image, e.mipmaps = this.mipmaps.slice(0), e.mapping = this.mapping, e.wrapS = this.wrapS, e.wrapT = this.wrapT, e.magFilter = this.magFilter, e.minFilter = this.minFilter, e.anisotropy = this.anisotropy, e.format = this.format, e.type = this.type, e.offset.copy(this.offset), e.repeat.copy(this.repeat), e.generateMipmaps = this.generateMipmaps, e.premultiplyAlpha = this.premultiplyAlpha, e.flipY = this.flipY, e.unpackAlignment = this.unpackAlignment, e
        },
        update: function() {
            this.dispatchEvent({
                type: "update"
            })
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype), THREE.TextureIdCount = 0, THREE.CubeTexture = function(e, t, i, r, n, o, a, s, l) {
        t = void 0 !== t ? t : THREE.CubeReflectionMapping, THREE.Texture.call(this, e, t, i, r, n, o, a, s, l), this.images = e
    }, THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CubeTexture.prototype.constructor = THREE.CubeTexture, THREE.CubeTexture.clone = function(e) {
        return void 0 === e && (e = new THREE.CubeTexture), THREE.Texture.prototype.clone.call(this, e), e.images = this.images, e
    }, THREE.CompressedTexture = function(e, t, i, r, n, o, a, s, l, h, u) {
        THREE.Texture.call(this, null, o, a, s, l, h, r, n, u), this.image = {
            width: t,
            height: i
        }, this.mipmaps = e, this.generateMipmaps = this.flipY = !1
    }, THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture, THREE.CompressedTexture.prototype.clone = function() {
        var e = new THREE.CompressedTexture;
        return THREE.Texture.prototype.clone.call(this, e), e
    }, THREE.DataTexture = function(e, t, i, r, n, o, a, s, l, h, u) {
        THREE.Texture.call(this, null, o, a, s, l, h, r, n, u), this.image = {
            data: e,
            width: t,
            height: i
        }
    }, THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype), THREE.DataTexture.prototype.constructor = THREE.DataTexture, THREE.DataTexture.prototype.clone = function() {
        var e = new THREE.DataTexture;
        return THREE.Texture.prototype.clone.call(this, e), e
    }, THREE.VideoTexture = function(e, t, i, r, n, o, a, s, l) {
        THREE.Texture.call(this, e, t, i, r, n, o, a, s, l), this.generateMipmaps = !1;
        var h = this,
            u = function() {
                requestAnimationFrame(u), e.readyState === e.HAVE_ENOUGH_DATA && (h.needsUpdate = !0)
            };
        u()
    }, THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype), THREE.VideoTexture.prototype.constructor = THREE.VideoTexture, THREE.Group = function() {
        THREE.Object3D.call(this), this.type = "Group"
    }, THREE.Group.prototype = Object.create(THREE.Object3D.prototype), THREE.Group.prototype.constructor = THREE.Group, THREE.PointCloud = function(e, t) {
        THREE.Object3D.call(this), this.type = "PointCloud", this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.PointCloudMaterial({
            color: 16777215 * Math.random()
        })
    }, THREE.PointCloud.prototype = Object.create(THREE.Object3D.prototype), THREE.PointCloud.prototype.constructor = THREE.PointCloud, THREE.PointCloud.prototype.raycast = function() {
        var e = new THREE.Matrix4,
            t = new THREE.Ray;
        return function(i, r) {
            var n = this,
                o = n.geometry,
                a = i.params.PointCloud.threshold;
            if (e.getInverse(this.matrixWorld), t.copy(i.ray).applyMatrix4(e), null === o.boundingBox || !1 !== t.isIntersectionBox(o.boundingBox)) {
                var s = a / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    l = new THREE.Vector3,
                    a = function(e, o) {
                        var a = t.distanceToPoint(e);
                        if (s > a) {
                            var l = t.closestPointToPoint(e);
                            l.applyMatrix4(n.matrixWorld);
                            var h = i.ray.origin.distanceTo(l);
                            r.push({
                                distance: h,
                                distanceToRay: a,
                                point: l.clone(),
                                index: o,
                                face: null,
                                object: n
                            })
                        }
                    };
                if (o instanceof THREE.BufferGeometry) {
                    var h = o.attributes,
                        u = h.position.array;
                    if (void 0 !== h.index) {
                        var h = h.index.array,
                            c = o.offsets;
                        0 === c.length && (c = [{
                            start: 0,
                            count: h.length,
                            index: 0
                        }]);
                        for (var p = 0, d = c.length; d > p; ++p)
                            for (var f = c[p].start, m = c[p].index, o = f, f = f + c[p].count; f > o; o++) {
                                var E = m + h[o];
                                l.fromArray(u, 3 * E), a(l, E)
                            }
                    } else
                        for (h = u.length / 3, o = 0; h > o; o++) l.set(u[3 * o], u[3 * o + 1], u[3 * o + 2]), a(l, o)
                } else
                    for (l = this.geometry.vertices, o = 0; o < l.length; o++) a(l[o], o)
            }
        }
    }(), THREE.PointCloud.prototype.clone = function(e) {
        return void 0 === e && (e = new THREE.PointCloud(this.geometry, this.material)), THREE.Object3D.prototype.clone.call(this, e), e
    }, THREE.ParticleSystem = function(e, t) {
        return THREE.warn("THREE.ParticleSystem has been renamed to THREE.PointCloud."), new THREE.PointCloud(e, t)
    }, THREE.Line = function(e, t, i) {
        THREE.Object3D.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.LineBasicMaterial({
            color: 16777215 * Math.random()
        }), this.mode = void 0 !== i ? i : THREE.LineStrip
    }, THREE.LineStrip = 0, THREE.LinePieces = 1, THREE.Line.prototype = Object.create(THREE.Object3D.prototype), THREE.Line.prototype.constructor = THREE.Line, THREE.Line.prototype.raycast = function() {
        var e = new THREE.Matrix4,
            t = new THREE.Ray,
            i = new THREE.Sphere;
        return function(r, n) {
            var o = r.linePrecision,
                o = o * o,
                a = this.geometry;
            if (null === a.boundingSphere && a.computeBoundingSphere(), i.copy(a.boundingSphere), i.applyMatrix4(this.matrixWorld), !1 !== r.ray.isIntersectionSphere(i)) {
                e.getInverse(this.matrixWorld), t.copy(r.ray).applyMatrix4(e);
                var s = new THREE.Vector3,
                    l = new THREE.Vector3,
                    h = new THREE.Vector3,
                    u = new THREE.Vector3,
                    c = this.mode === THREE.LineStrip ? 1 : 2;
                if (a instanceof THREE.BufferGeometry) {
                    var p = a.attributes;
                    if (void 0 !== p.index) {
                        var d = p.index.array,
                            p = p.position.array,
                            f = a.offsets;
                        0 === f.length && (f = [{
                            start: 0,
                            count: d.length,
                            index: 0
                        }]);
                        for (var m = 0; m < f.length; m++)
                            for (var E = f[m].start, v = f[m].count, g = f[m].index, a = E; E + v - 1 > a; a += c) {
                                var y = g + d[a + 1];
                                s.fromArray(p, 3 * (g + d[a])), l.fromArray(p, 3 * y), y = t.distanceSqToSegment(s, l, u, h), y > o || (y = t.origin.distanceTo(u), y < r.near || y > r.far || n.push({
                                    distance: y,
                                    point: h.clone().applyMatrix4(this.matrixWorld),
                                    index: a,
                                    offsetIndex: m,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            }
                    } else
                        for (p = p.position.array, a = 0; a < p.length / 3 - 1; a += c) s.fromArray(p, 3 * a), l.fromArray(p, 3 * a + 3), y = t.distanceSqToSegment(s, l, u, h), y > o || (y = t.origin.distanceTo(u), y < r.near || y > r.far || n.push({
                            distance: y,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: a,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                } else if (a instanceof THREE.Geometry)
                    for (s = a.vertices, l = s.length, a = 0; l - 1 > a; a += c) y = t.distanceSqToSegment(s[a], s[a + 1], u, h), y > o || (y = t.origin.distanceTo(u), y < r.near || y > r.far || n.push({
                        distance: y,
                        point: h.clone().applyMatrix4(this.matrixWorld),
                        index: a,
                        face: null,
                        faceIndex: null,
                        object: this
                    }))
            }
        }
    }(), THREE.Line.prototype.clone = function(e) {
        return void 0 === e && (e = new THREE.Line(this.geometry, this.material, this.mode)), THREE.Object3D.prototype.clone.call(this, e), e
    }, THREE.Mesh = function(e, t) {
        THREE.Object3D.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.MeshBasicMaterial({
            color: 16777215 * Math.random()
        }), this.updateMorphTargets()
    }, THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype), THREE.Mesh.prototype.constructor = THREE.Mesh, THREE.Mesh.prototype.updateMorphTargets = function() {
        if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
            this.morphTargetBase = -1, this.morphTargetForcedOrder = [], this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (var e = 0, t = this.geometry.morphTargets.length; t > e; e++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[e].name] = e
        }
    }, THREE.Mesh.prototype.getMorphTargetIndexByName = function(e) {
        return void 0 !== this.morphTargetDictionary[e] ? this.morphTargetDictionary[e] : (THREE.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + e + " does not exist. Returning 0."), 0)
    }, THREE.Mesh.prototype.raycast = function() {
        var e = new THREE.Matrix4,
            t = new THREE.Ray,
            i = new THREE.Sphere,
            r = new THREE.Vector3,
            n = new THREE.Vector3,
            o = new THREE.Vector3;
        return function(a, s) {
            var l = this.geometry;
            if (null === l.boundingSphere && l.computeBoundingSphere(), i.copy(l.boundingSphere), i.applyMatrix4(this.matrixWorld), !1 !== a.ray.isIntersectionSphere(i) && (e.getInverse(this.matrixWorld), t.copy(a.ray).applyMatrix4(e), null === l.boundingBox || !1 !== t.isIntersectionBox(l.boundingBox)))
                if (l instanceof THREE.BufferGeometry) {
                    var h = this.material;
                    if (void 0 !== h) {
                        var u = l.attributes,
                            c, p, d = a.precision;
                        if (void 0 !== u.index) {
                            var f = u.index.array,
                                m = u.position.array,
                                E = l.offsets;
                            0 === E.length && (E = [{
                                start: 0,
                                count: f.length,
                                index: 0
                            }]);
                            for (var v = 0, g = E.length; g > v; ++v)
                                for (var u = E[v].start, y = E[v].index, l = u, T = u + E[v].count; T > l; l += 3) {
                                    u = y + f[l], c = y + f[l + 1], p = y + f[l + 2], r.fromArray(m, 3 * u), n.fromArray(m, 3 * c), o.fromArray(m, 3 * p);
                                    var x = h.side === THREE.BackSide ? t.intersectTriangle(o, n, r, !0) : t.intersectTriangle(r, n, o, h.side !== THREE.DoubleSide);
                                    if (null !== x) {
                                        x.applyMatrix4(this.matrixWorld);
                                        var _ = a.ray.origin.distanceTo(x);
                                        d > _ || _ < a.near || _ > a.far || s.push({
                                            distance: _,
                                            point: x,
                                            face: new THREE.Face3(u, c, p, THREE.Triangle.normal(r, n, o)),
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                                }
                        } else
                            for (m = u.position.array, f = l = 0, T = m.length; T > l; l += 3, f += 9) u = l, c = l + 1, p = l + 2, r.fromArray(m, f), n.fromArray(m, f + 3), o.fromArray(m, f + 6), x = h.side === THREE.BackSide ? t.intersectTriangle(o, n, r, !0) : t.intersectTriangle(r, n, o, h.side !== THREE.DoubleSide), null !== x && (x.applyMatrix4(this.matrixWorld), _ = a.ray.origin.distanceTo(x), d > _ || _ < a.near || _ > a.far || s.push({
                                distance: _,
                                point: x,
                                face: new THREE.Face3(u, c, p, THREE.Triangle.normal(r, n, o)),
                                faceIndex: null,
                                object: this
                            }))
                    }
                } else if (l instanceof THREE.Geometry)
                for (f = this.material instanceof THREE.MeshFaceMaterial, m = !0 === f ? this.material.materials : null, d = a.precision, E = l.vertices, v = 0, g = l.faces.length; g > v; v++)
                    if (y = l.faces[v], h = !0 === f ? m[y.materialIndex] : this.material, void 0 !== h) {
                        if (u = E[y.a], c = E[y.b], p = E[y.c], !0 === h.morphTargets) {
                            x = l.morphTargets, _ = this.morphTargetInfluences, r.set(0, 0, 0), n.set(0, 0, 0), o.set(0, 0, 0);
                            for (var T = 0, R = x.length; R > T; T++) {
                                var b = _[T];
                                if (0 !== b) {
                                    var H = x[T].vertices;
                                    r.x += (H[y.a].x - u.x) * b, r.y += (H[y.a].y - u.y) * b, r.z += (H[y.a].z - u.z) * b, n.x += (H[y.b].x - c.x) * b, n.y += (H[y.b].y - c.y) * b, n.z += (H[y.b].z - c.z) * b, o.x += (H[y.c].x - p.x) * b, o.y += (H[y.c].y - p.y) * b, o.z += (H[y.c].z - p.z) * b
                                }
                            }
                            r.add(u), n.add(c), o.add(p), u = r, c = n, p = o
                        }
                        x = h.side === THREE.BackSide ? t.intersectTriangle(p, c, u, !0) : t.intersectTriangle(u, c, p, h.side !== THREE.DoubleSide), null !== x && (x.applyMatrix4(this.matrixWorld), _ = a.ray.origin.distanceTo(x), d > _ || _ < a.near || _ > a.far || s.push({
                            distance: _,
                            point: x,
                            face: y,
                            faceIndex: v,
                            object: this
                        }))
                    }
        }
    }(), THREE.Mesh.prototype.clone = function(e, t) {
        return void 0 === e && (e = new THREE.Mesh(this.geometry, this.material)), THREE.Object3D.prototype.clone.call(this, e, t), e
    }, THREE.Bone = function(e) {
        THREE.Object3D.call(this), this.type = "Bone", this.skin = e
    }, THREE.Bone.prototype = Object.create(THREE.Object3D.prototype), THREE.Bone.prototype.constructor = THREE.Bone, THREE.Skeleton = function(e, t, i) {
        if (this.useVertexTexture = void 0 !== i ? i : !0, this.identityMatrix = new THREE.Matrix4, e = e || [], this.bones = e.slice(0), this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = e = 256 < this.bones.length ? 64 : 64 < this.bones.length ? 32 : 16 < this.bones.length ? 16 : 8, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t) this.calculateInverses();
        else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
        else
            for (THREE.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [], t = 0, e = this.bones.length; e > t; t++) this.boneInverses.push(new THREE.Matrix4)
    }, THREE.Skeleton.prototype.calculateInverses = function() {
        this.boneInverses = [];
        for (var e = 0, t = this.bones.length; t > e; e++) {
            var i = new THREE.Matrix4;
            this.bones[e] && i.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(i)
        }
    }, THREE.Skeleton.prototype.pose = function() {
        for (var e, t = 0, i = this.bones.length; i > t; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
        for (t = 0, i = this.bones.length; i > t; t++)(e = this.bones[t]) && (e.parent ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
    }, THREE.Skeleton.prototype.update = function() {
        var e = new THREE.Matrix4;
        return function() {
            for (var t = 0, i = this.bones.length; i > t; t++) e.multiplyMatrices(this.bones[t] ? this.bones[t].matrixWorld : this.identityMatrix, this.boneInverses[t]), e.flattenToArrayOffset(this.boneMatrices, 16 * t);
            this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
        }
    }(), THREE.SkinnedMesh = function(e, t, i) {
        if (THREE.Mesh.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new THREE.Matrix4, this.bindMatrixInverse = new THREE.Matrix4, e = [], this.geometry && void 0 !== this.geometry.bones) {
            for (var r, n, o, a, s = 0, l = this.geometry.bones.length; l > s; ++s) r = this.geometry.bones[s], n = r.pos, o = r.rotq, a = r.scl, t = new THREE.Bone(this), e.push(t), t.name = r.name, t.position.set(n[0], n[1], n[2]), t.quaternion.set(o[0], o[1], o[2], o[3]), void 0 !== a ? t.scale.set(a[0], a[1], a[2]) : t.scale.set(1, 1, 1);
            for (s = 0, l = this.geometry.bones.length; l > s; ++s) r = this.geometry.bones[s], -1 !== r.parent ? e[r.parent].add(e[s]) : this.add(e[s])
        }
        this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new THREE.Skeleton(e, void 0, i))
    }, THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh, THREE.SkinnedMesh.prototype.bind = function(e, t) {
        this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
    }, THREE.SkinnedMesh.prototype.pose = function() {
        this.skeleton.pose()
    }, THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
        if (this.geometry instanceof THREE.Geometry)
            for (var e = 0; e < this.geometry.skinIndices.length; e++) {
                var t = this.geometry.skinWeights[e],
                    i = 1 / t.lengthManhattan();
                1 / 0 !== i ? t.multiplyScalar(i) : t.set(1)
            }
    }, THREE.SkinnedMesh.prototype.updateMatrixWorld = function(e) {
        THREE.Mesh.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : THREE.warn("THREE.SkinnedMesh unreckognized bindMode: " + this.bindMode)
    }, THREE.SkinnedMesh.prototype.clone = function(e) {
        return void 0 === e && (e = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture)), THREE.Mesh.prototype.clone.call(this, e), e
    }, THREE.MorphAnimMesh = function(e, t) {
        THREE.Mesh.call(this, e, t), this.type = "MorphAnimMesh", this.duration = 1e3, this.mirroredLoop = !1, this.currentKeyframe = this.lastKeyframe = this.time = 0, this.direction = 1, this.directionBackwards = !1, this.setFrameRange(0, this.geometry.morphTargets.length - 1)
    }, THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh, THREE.MorphAnimMesh.prototype.setFrameRange = function(e, t) {
        this.startKeyframe = e, this.endKeyframe = t, this.length = this.endKeyframe - this.startKeyframe + 1
    }, THREE.MorphAnimMesh.prototype.setDirectionForward = function() {
        this.direction = 1, this.directionBackwards = !1
    }, THREE.MorphAnimMesh.prototype.setDirectionBackward = function() {
        this.direction = -1, this.directionBackwards = !0
    }, THREE.MorphAnimMesh.prototype.parseAnimations = function() {
        var e = this.geometry;
        e.animations || (e.animations = {});
        for (var t, i = e.animations, r = /([a-z]+)_?(\d+)/, n = 0, o = e.morphTargets.length; o > n; n++) {
            var a = e.morphTargets[n].name.match(r);
            if (a && 1 < a.length) {
                a = a[1], i[a] || (i[a] = {
                    start: 1 / 0,
                    end: -1 / 0
                });
                var s = i[a];
                n < s.start && (s.start = n), n > s.end && (s.end = n), t || (t = a)
            }
        }
        e.firstAnimation = t
    }, THREE.MorphAnimMesh.prototype.setAnimationLabel = function(e, t, i) {
        this.geometry.animations || (this.geometry.animations = {}), this.geometry.animations[e] = {
            start: t,
            end: i
        }
    }, THREE.MorphAnimMesh.prototype.playAnimation = function(e, t) {
        var i = this.geometry.animations[e];
        i ? (this.setFrameRange(i.start, i.end), this.duration = (i.end - i.start) / t * 1e3, this.time = 0) : THREE.warn("THREE.MorphAnimMesh: animation[" + e + "] undefined in .playAnimation()")
    }, THREE.MorphAnimMesh.prototype.updateAnimation = function(e) {
        var t = this.duration / this.length;
        this.time += this.direction * e, this.mirroredLoop ? (this.time > this.duration || 0 > this.time) && (this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 0 > this.time && (this.time = 0, this.directionBackwards = !1)) : (this.time %= this.duration, 0 > this.time && (this.time += this.duration)), e = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / t), 0, this.length - 1), e !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[e] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = e), t = this.time % t / t, this.directionBackwards && (t = 1 - t), this.morphTargetInfluences[this.currentKeyframe] = t, this.morphTargetInfluences[this.lastKeyframe] = 1 - t
    }, THREE.MorphAnimMesh.prototype.interpolateTargets = function(e, t, i) {
        for (var r = this.morphTargetInfluences, n = 0, o = r.length; o > n; n++) r[n] = 0;
        e > -1 && (r[e] = 1 - i), t > -1 && (r[t] = i)
    }, THREE.MorphAnimMesh.prototype.clone = function(e) {
        return void 0 === e && (e = new THREE.MorphAnimMesh(this.geometry, this.material)), e.duration = this.duration, e.mirroredLoop = this.mirroredLoop, e.time = this.time, e.lastKeyframe = this.lastKeyframe, e.currentKeyframe = this.currentKeyframe, e.direction = this.direction, e.directionBackwards = this.directionBackwards, THREE.Mesh.prototype.clone.call(this, e), e
    }, THREE.LOD = function() {
        THREE.Object3D.call(this), this.objects = []
    }, THREE.LOD.prototype = Object.create(THREE.Object3D.prototype), THREE.LOD.prototype.constructor = THREE.LOD, THREE.LOD.prototype.addLevel = function(e, t) {
        void 0 === t && (t = 0), t = Math.abs(t);
        for (var i = 0; i < this.objects.length && !(t < this.objects[i].distance); i++);
        this.objects.splice(i, 0, {
            distance: t,
            object: e
        }), this.add(e)
    }, THREE.LOD.prototype.getObjectForDistance = function(e) {
        for (var t = 1, i = this.objects.length; i > t && !(e < this.objects[t].distance); t++);
        return this.objects[t - 1].object
    }, THREE.LOD.prototype.raycast = function() {
        var e = new THREE.Vector3;
        return function(t, i) {
            e.setFromMatrixPosition(this.matrixWorld);
            var r = t.ray.origin.distanceTo(e);
            this.getObjectForDistance(r).raycast(t, i)
        }
    }(), THREE.LOD.prototype.update = function() {
        var e = new THREE.Vector3,
            t = new THREE.Vector3;
        return function(i) {
            if (1 < this.objects.length) {
                e.setFromMatrixPosition(i.matrixWorld), t.setFromMatrixPosition(this.matrixWorld), i = e.distanceTo(t), this.objects[0].object.visible = !0;
                for (var r = 1, n = this.objects.length; n > r && i >= this.objects[r].distance; r++) this.objects[r - 1].object.visible = !1, this.objects[r].object.visible = !0;
                for (; n > r; r++) this.objects[r].object.visible = !1
            }
        }
    }(), THREE.LOD.prototype.clone = function(e) {
        void 0 === e && (e = new THREE.LOD), THREE.Object3D.prototype.clone.call(this, e);
        for (var t = 0, i = this.objects.length; i > t; t++) {
            var r = this.objects[t].object.clone();
            r.visible = 0 === t, e.addLevel(r, this.objects[t].distance)
        }
        return e
    }, THREE.Sprite = function() {
        var e = new Uint16Array([0, 1, 2, 0, 2, 3]),
            t = new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0]),
            i = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            r = new THREE.BufferGeometry;
        return r.addAttribute("index", new THREE.BufferAttribute(e, 1)), r.addAttribute("position", new THREE.BufferAttribute(t, 3)), r.addAttribute("uv", new THREE.BufferAttribute(i, 2)),
            function(e) {
                THREE.Object3D.call(this), this.type = "Sprite", this.geometry = r, this.material = void 0 !== e ? e : new THREE.SpriteMaterial
            }
    }(), THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype), THREE.Sprite.prototype.constructor = THREE.Sprite, THREE.Sprite.prototype.raycast = function() {
        var e = new THREE.Vector3;
        return function(t, i) {
            e.setFromMatrixPosition(this.matrixWorld);
            var r = t.ray.distanceToPoint(e);
            r > this.scale.x || i.push({
                distance: r,
                point: this.position,
                face: null,
                object: this
            })
        }
    }(), THREE.Sprite.prototype.clone = function(e) {
        return void 0 === e && (e = new THREE.Sprite(this.material)), THREE.Object3D.prototype.clone.call(this, e), e
    }, THREE.Particle = THREE.Sprite, THREE.LensFlare = function(e, t, i, r, n) {
        THREE.Object3D.call(this), this.lensFlares = [], this.positionScreen = new THREE.Vector3, this.customUpdateCallback = void 0, void 0 !== e && this.add(e, t, i, r, n)
    }, THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare.prototype.constructor = THREE.LensFlare, THREE.LensFlare.prototype.add = function(e, t, i, r, n, o) {
        void 0 === t && (t = -1), void 0 === i && (i = 0), void 0 === o && (o = 1), void 0 === n && (n = new THREE.Color(16777215)), void 0 === r && (r = THREE.NormalBlending), i = Math.min(i, Math.max(0, i)), this.lensFlares.push({
            texture: e,
            size: t,
            distance: i,
            x: 0,
            y: 0,
            z: 0,
            scale: 1,
            rotation: 1,
            opacity: o,
            color: n,
            blending: r
        })
    }, THREE.LensFlare.prototype.updateLensFlares = function() {
        var e, t = this.lensFlares.length,
            i, r = 2 * -this.positionScreen.x,
            n = 2 * -this.positionScreen.y;
        for (e = 0; t > e; e++) i = this.lensFlares[e], i.x = this.positionScreen.x + r * i.distance, i.y = this.positionScreen.y + n * i.distance, i.wantedRotation = i.x * Math.PI * .25, i.rotation += .25 * (i.wantedRotation - i.rotation)
    }, THREE.Scene = function() {
        THREE.Object3D.call(this), this.type = "Scene", this.overrideMaterial = this.fog = null, this.autoUpdate = !0
    }, THREE.Scene.prototype = Object.create(THREE.Object3D.prototype), THREE.Scene.prototype.constructor = THREE.Scene, THREE.Scene.prototype.clone = function(e) {
        return void 0 === e && (e = new THREE.Scene), THREE.Object3D.prototype.clone.call(this, e), null !== this.fog && (e.fog = this.fog.clone()), null !== this.overrideMaterial && (e.overrideMaterial = this.overrideMaterial.clone()), e.autoUpdate = this.autoUpdate, e.matrixAutoUpdate = this.matrixAutoUpdate, e
    }, THREE.Fog = function(e, t, i) {
        this.name = "", this.color = new THREE.Color(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== i ? i : 1e3
    }, THREE.Fog.prototype.clone = function() {
        return new THREE.Fog(this.color.getHex(), this.near, this.far)
    }, THREE.FogExp2 = function(e, t) {
        this.name = "", this.color = new THREE.Color(e), this.density = void 0 !== t ? t : 25e-5
    }, THREE.FogExp2.prototype.clone = function() {
        return new THREE.FogExp2(this.color.getHex(), this.density)
    }, THREE.ShaderChunk = {}, THREE.ShaderChunk.common = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n	float distance = dot( planeNormal, point-pointOnPlane );\n	return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n	if ( decayExponent > 0.0 ) {\n	  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n	}\n	return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n	return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n	return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n	return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n	return a;\n#endif\n}\n", THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n", THREE.ShaderChunk.lights_lambert_vertex = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack += ambientLightColor;\n\n#endif\n", THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n", THREE.ShaderChunk.default_vertex = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n	vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n", THREE.ShaderChunk.map_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif", THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n", THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif", THREE.ShaderChunk.lightmap_pars_vertex = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif", THREE.ShaderChunk.lights_phong_fragment = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		totalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		totalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			totalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\n\n			// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			totalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n		// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		totalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		totalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalDiffuseLight += hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		totalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\n#ifdef METAL\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\n\n#else\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\n\n#endif\n", THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif", THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif", THREE.ShaderChunk.envmap_pars_fragment = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n", THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif", THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n	// Per-Pixel Tangent Space Normal Mapping\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n", THREE.ShaderChunk.lights_phong_pars_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n", THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif", THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif", THREE.ShaderChunk.lights_phong_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif", THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif", THREE.ShaderChunk.lightmap_vertex = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif", THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n", THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n", THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n	vColor.xyz = inputToLinear( color.xyz );\n\n#endif", THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n", THREE.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n", THREE.ShaderChunk.linear_to_gamma_fragment = "\n	outgoingLight = linearToOutput( outgoingLight );\n", THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif", THREE.ShaderChunk.lights_lambert_pars_vertex = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n", THREE.ShaderChunk.map_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n", THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// Transforming Normal Vectors with the Inverse Transformation\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n", THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif", THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif", THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif", THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif", THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n		fogFactor = whiteCompliment( fogFactor );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif", THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n", THREE.ShaderChunk.defaultnormal_vertex = "#ifdef USE_SKINNING\n\n	vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n	vec3 objectNormal = morphedNormal;\n\n#else\n\n	vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n", THREE.ShaderChunk.lights_phong_pars_fragment = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n", THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif", THREE.ShaderChunk.map_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif", THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n	outgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif", THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif", THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif", THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif", THREE.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n", THREE.ShaderChunk.shadowmap_fragment = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n	shadowColor = inputToLinear( shadowColor );\n\n	outgoingLight = outgoingLight * shadowColor;\n\n#endif\n", THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#elif defined( USE_MORPHTARGETS )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif\n", THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif", THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n", THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif", THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n", THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n", THREE.UniformsUtils = {
        merge: function(e) {
            for (var t = {}, i = 0; i < e.length; i++) {
                var r = this.clone(e[i]),
                    n;
                for (n in r) t[n] = r[n]
            }
            return t
        },
        clone: function(e) {
            var t = {},
                i;
            for (i in e) {
                t[i] = {};
                for (var r in e[i]) {
                    var n = e[i][r];
                    t[i][r] = n instanceof THREE.Color || n instanceof THREE.Vector2 || n instanceof THREE.Vector3 || n instanceof THREE.Vector4 || n instanceof THREE.Matrix4 || n instanceof THREE.Texture ? n.clone() : n instanceof Array ? n.slice() : n
                }
            }
            return t
        }
    }, THREE.UniformsLib = {
        common: {
            diffuse: {
                type: "c",
                value: new THREE.Color(15658734)
            },
            opacity: {
                type: "f",
                value: 1
            },
            map: {
                type: "t",
                value: null
            },
            offsetRepeat: {
                type: "v4",
                value: new THREE.Vector4(0, 0, 1, 1)
            },
            lightMap: {
                type: "t",
                value: null
            },
            specularMap: {
                type: "t",
                value: null
            },
            alphaMap: {
                type: "t",
                value: null
            },
            envMap: {
                type: "t",
                value: null
            },
            flipEnvMap: {
                type: "f",
                value: -1
            },
            reflectivity: {
                type: "f",
                value: 1
            },
            refractionRatio: {
                type: "f",
                value: .98
            },
            morphTargetInfluences: {
                type: "f",
                value: 0
            }
        },
        bump: {
            bumpMap: {
                type: "t",
                value: null
            },
            bumpScale: {
                type: "f",
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                type: "t",
                value: null
            },
            normalScale: {
                type: "v2",
                value: new THREE.Vector2(1, 1)
            }
        },
        fog: {
            fogDensity: {
                type: "f",
                value: 25e-5
            },
            fogNear: {
                type: "f",
                value: 1
            },
            fogFar: {
                type: "f",
                value: 2e3
            },
            fogColor: {
                type: "c",
                value: new THREE.Color(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                type: "fv",
                value: []
            },
            directionalLightDirection: {
                type: "fv",
                value: []
            },
            directionalLightColor: {
                type: "fv",
                value: []
            },
            hemisphereLightDirection: {
                type: "fv",
                value: []
            },
            hemisphereLightSkyColor: {
                type: "fv",
                value: []
            },
            hemisphereLightGroundColor: {
                type: "fv",
                value: []
            },
            pointLightColor: {
                type: "fv",
                value: []
            },
            pointLightPosition: {
                type: "fv",
                value: []
            },
            pointLightDistance: {
                type: "fv1",
                value: []
            },
            pointLightDecay: {
                type: "fv1",
                value: []
            },
            spotLightColor: {
                type: "fv",
                value: []
            },
            spotLightPosition: {
                type: "fv",
                value: []
            },
            spotLightDirection: {
                type: "fv",
                value: []
            },
            spotLightDistance: {
                type: "fv1",
                value: []
            },
            spotLightAngleCos: {
                type: "fv1",
                value: []
            },
            spotLightExponent: {
                type: "fv1",
                value: []
            },
            spotLightDecay: {
                type: "fv1",
                value: []
            }
        },
        particle: {
            psColor: {
                type: "c",
                value: new THREE.Color(15658734)
            },
            opacity: {
                type: "f",
                value: 1
            },
            size: {
                type: "f",
                value: 1
            },
            scale: {
                type: "f",
                value: 1
            },
            map: {
                type: "t",
                value: null
            },
            offsetRepeat: {
                type: "v4",
                value: new THREE.Vector4(0, 0, 1, 1)
            },
            fogDensity: {
                type: "f",
                value: 25e-5
            },
            fogNear: {
                type: "f",
                value: 1
            },
            fogFar: {
                type: "f",
                value: 2e3
            },
            fogColor: {
                type: "c",
                value: new THREE.Color(16777215)
            }
        },
        shadowmap: {
            shadowMap: {
                type: "tv",
                value: []
            },
            shadowMapSize: {
                type: "v2v",
                value: []
            },
            shadowBias: {
                type: "fv1",
                value: []
            },
            shadowDarkness: {
                type: "fv1",
                value: []
            },
            shadowMatrix: {
                type: "m4v",
                value: []
            }
        }
    }, THREE.ShaderLib = {
        basic: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),
            vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "	#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "	#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
        },
        lambert: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                }
            }]),
            vertexShader: ["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "	#ifdef DOUBLE_SIDED\n		if ( gl_FrontFacing )\n			outgoingLight += diffuseColor.rgb * vLightFront + emissive;\n		else\n			outgoingLight += diffuseColor.rgb * vLightBack + emissive;\n	#else\n		outgoingLight += diffuseColor.rgb * vLightFront + emissive;\n	#endif", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
        },
        phong: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
                emissive: {
                    type: "c",
                    value: new THREE.Color(0)
                },
                specular: {
                    type: "c",
                    value: new THREE.Color(1118481)
                },
                shininess: {
                    type: "f",
                    value: 30
                },
                wrapRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                }
            }]),
            vertexShader: ["#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "	vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
        },
        particle_basic: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]),
            vertexShader: ["uniform float size;\nuniform float scale;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n	#else\n		gl_PointSize = size;\n	#endif\n	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 psColor;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( psColor, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphatest_fragment, "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
        },
        dashed: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
                scale: {
                    type: "f",
                    value: 1
                },
                dashSize: {
                    type: "f",
                    value: 1
                },
                totalSize: {
                    type: "f",
                    value: 2
                }
            }]),
            vertexShader: ["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.color_fragment, "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.fog_fragment, "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
        },
        depth: {
            uniforms: {
                mNear: {
                    type: "f",
                    value: 1
                },
                mFar: {
                    type: "f",
                    value: 2e3
                },
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform float mNear;\nuniform float mFar;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	float color = 1.0 - smoothstep( mNear, mFar, depth );\n	gl_FragColor = vec4( vec3( color ), opacity );\n}"].join("\n")
        },
        normal: {
            uniforms: {
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n	vNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform float opacity;\nvarying vec3 vNormal;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
        },
        cube: {
            uniforms: {
                tCube: {
                    type: "t",
                    value: null
                },
                tFlip: {
                    type: "f",
                    value: -1
                }
            },
            vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    type: "t",
                    value: null
                },
                tFlip: {
                    type: "f",
                    value: -1
                }
            },
            vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\nvec3 direction = normalize( vWorldPosition );\nvec2 sampleUV;\nsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\nsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\ngl_FragColor = texture2D( tEquirect, sampleUV );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
        },
        depthRGBA: {
            uniforms: {},
            vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, "vec4 pack_depth( const in float depth ) {\n	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n	res -= res.xxyz * bit_mask;\n	return res;\n}\nvoid main() {", THREE.ShaderChunk.logdepthbuf_fragment, "	#ifdef USE_LOGDEPTHBUF_EXT\n		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n	#else\n		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n	#endif\n}"].join("\n")
        }
    }, THREE.WebGLRenderer = function(e) {
        function t(e) {
            var t = e.geometry;
            e = e.material;
            var i = t.vertices.length;
            if (e.attributes) {
                void 0 === t.__webglCustomAttributesList && (t.__webglCustomAttributesList = []);
                for (var r in e.attributes) {
                    var n = e.attributes[r];
                    if (!n.__webglInitialized || n.createUniqueBuffers) {
                        n.__webglInitialized = !0;
                        var o = 1;
                        "v2" === n.type ? o = 2 : "v3" === n.type ? o = 3 : "v4" === n.type ? o = 4 : "c" === n.type && (o = 3), n.size = o, n.array = new Float32Array(i * o), n.buffer = mt.createBuffer(), n.buffer.belongsToAttribute = r, n.needsUpdate = !0
                    }
                    t.__webglCustomAttributesList.push(n)
                }
            }
        }

        function i(e, t) {
            return e.material instanceof THREE.MeshFaceMaterial ? e.material.materials[t.materialIndex] : e.material
        }

        function r(e, t, i, r) {
            i = i.attributes;
            var n = t.attributes;
            t = t.attributesKeys;
            for (var o = 0, a = t.length; a > o; o++) {
                var s = t[o],
                    l = n[s];
                if (l >= 0) {
                    var h = i[s];
                    void 0 !== h ? (s = h.itemSize, mt.bindBuffer(mt.ARRAY_BUFFER, h.buffer), gt.enableAttribute(l), mt.vertexAttribPointer(l, s, mt.FLOAT, !1, 0, r * s * 4)) : void 0 !== e.defaultAttributeValues && (2 === e.defaultAttributeValues[s].length ? mt.vertexAttrib2fv(l, e.defaultAttributeValues[s]) : 3 === e.defaultAttributeValues[s].length && mt.vertexAttrib3fv(l, e.defaultAttributeValues[s]))
                }
            }
            gt.disableUnusedAttributes()
        }

        function n(e, t) {
            return e.object.renderOrder !== t.object.renderOrder ? e.object.renderOrder - t.object.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
        }

        function o(e, t) {
            return e.object.renderOrder !== t.object.renderOrder ? e.object.renderOrder - t.object.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
        }

        function a(e, t) {
            return t[0] - e[0]
        }

        function s(e) {
            if (!1 !== e.visible) {
                if (!(e instanceof THREE.Scene || e instanceof THREE.Group)) {
                    void 0 === e.__webglInit && (e.__webglInit = !0, e._modelViewMatrix = new THREE.Matrix4, e._normalMatrix = new THREE.Matrix3, e.addEventListener("removed", Bt));
                    var i = e.geometry;
                    if (void 0 !== i && void 0 === i.__webglInit)
                        if (i.__webglInit = !0, i.addEventListener("dispose", zt), i instanceof THREE.BufferGeometry) Y.info.memory.geometries++;
                        else if (e instanceof THREE.Mesh) c(e, i);
                    else if (e instanceof THREE.Line) {
                        if (void 0 === i.__webglVertexBuffer) {
                            i.__webglVertexBuffer = mt.createBuffer(), i.__webglColorBuffer = mt.createBuffer(), i.__webglLineDistanceBuffer = mt.createBuffer(), Y.info.memory.geometries++;
                            var r = i.vertices.length;
                            i.__vertexArray = new Float32Array(3 * r), i.__colorArray = new Float32Array(3 * r), i.__lineDistanceArray = new Float32Array(1 * r), i.__webglLineCount = r, t(e), i.verticesNeedUpdate = !0, i.colorsNeedUpdate = !0, i.lineDistancesNeedUpdate = !0
                        }
                    } else e instanceof THREE.PointCloud && void 0 === i.__webglVertexBuffer && (i.__webglVertexBuffer = mt.createBuffer(), i.__webglColorBuffer = mt.createBuffer(), Y.info.memory.geometries++, r = i.vertices.length, i.__vertexArray = new Float32Array(3 * r), i.__colorArray = new Float32Array(3 * r), i.__webglParticleCount = r, t(e), i.verticesNeedUpdate = !0, i.colorsNeedUpdate = !0);
                    if (void 0 === e.__webglActive)
                        if (e.__webglActive = !0, e instanceof THREE.Mesh) {
                            if (i instanceof THREE.BufferGeometry) p(I, i, e);
                            else if (i instanceof THREE.Geometry)
                                for (var i = Xt[i.id], r = 0, n = i.length; n > r; r++) p(I, i[r], e)
                        } else e instanceof THREE.Line || e instanceof THREE.PointCloud ? p(I, i, e) : (e instanceof THREE.ImmediateRenderObject || e.immediateRenderCallback) && j.push({
                            id: null,
                            object: e,
                            opaque: null,
                            transparent: null,
                            z: 0
                        });
                    if (e instanceof THREE.Light) V.push(e);
                    else if (e instanceof THREE.Sprite) X.push(e);
                    else if (e instanceof THREE.LensFlare) q.push(e);
                    else if ((i = I[e.id]) && (!1 === e.frustumCulled || !0 === ht.intersectsObject(e)))
                        for (r = 0, n = i.length; n > r; r++) {
                            var o = i[r],
                                a = o,
                                l = a.object,
                                h = a.buffer,
                                u = l.geometry,
                                l = l.material;
                            l instanceof THREE.MeshFaceMaterial ? (l = l.materials[u instanceof THREE.BufferGeometry ? 0 : h.materialIndex], a.material = l, l.transparent ? W.push(a) : G.push(a)) : l && (a.material = l, l.transparent ? W.push(a) : G.push(a)), o.render = !0, !0 === Y.sortObjects && (ct.setFromMatrixPosition(e.matrixWorld), ct.applyProjection(ut), o.z = ct.z)
                        }
                }
                for (r = 0, n = e.children.length; n > r; r++) s(e.children[r])
            }
        }

        function l(e, t, i, r, n) {
            for (var o, a = 0, s = e.length; s > a; a++) {
                o = e[a];
                var l = o.object,
                    h = o.buffer;
                if (T(l, t), n) o = n;
                else {
                    if (o = o.material, !o) continue;
                    E(o)
                }
                Y.setMaterialFaces(o), h instanceof THREE.BufferGeometry ? Y.renderBufferDirect(t, i, r, o, h, l) : Y.renderBuffer(t, i, r, o, h, l)
            }
        }

        function h(e, t, i, r, n, o) {
            for (var a, s = 0, l = e.length; l > s; s++) {
                a = e[s];
                var h = a.object;
                if (h.visible) {
                    if (o) a = o;
                    else {
                        if (a = a[t], !a) continue;
                        E(a)
                    }
                    Y.renderImmediateObject(i, r, n, a, h)
                }
            }
        }

        function u(e) {
            var t = e.object.material;
            t.transparent ? (e.transparent = t, e.opaque = null) : (e.opaque = t, e.transparent = null)
        }

        function c(e, t) {
            var r = e.material,
                n = !1;
            if (void 0 === Xt[t.id] || !0 === t.groupsNeedUpdate) {
                delete I[e.id];
                for (var o = Xt, a = t.id, r = r instanceof THREE.MeshFaceMaterial, s = yt.get("OES_element_index_uint") ? 4294967296 : 65535, l, n = {}, h = t.morphTargets.length, u = t.morphNormals.length, c, d = {}, f = [], m = 0, E = t.faces.length; E > m; m++) {
                    l = t.faces[m];
                    var v = r ? l.materialIndex : 0;
                    v in n || (n[v] = {
                        hash: v,
                        counter: 0
                    }), l = n[v].hash + "_" + n[v].counter, l in d || (c = {
                        id: qt++,
                        faces3: [],
                        materialIndex: v,
                        vertices: 0,
                        numMorphTargets: h,
                        numMorphNormals: u
                    }, d[l] = c, f.push(c)), d[l].vertices + 3 > s && (n[v].counter += 1, l = n[v].hash + "_" + n[v].counter, l in d || (c = {
                        id: qt++,
                        faces3: [],
                        materialIndex: v,
                        vertices: 0,
                        numMorphTargets: h,
                        numMorphNormals: u
                    }, d[l] = c, f.push(c))), d[l].faces3.push(m), d[l].vertices += 3
                }
                o[a] = f, t.groupsNeedUpdate = !1
            }
            for (o = Xt[t.id], a = 0, r = o.length; r > a; a++) {
                if (s = o[a], void 0 === s.__webglVertexBuffer) {
                    if (n = s, n.__webglVertexBuffer = mt.createBuffer(), n.__webglNormalBuffer = mt.createBuffer(), n.__webglTangentBuffer = mt.createBuffer(), n.__webglColorBuffer = mt.createBuffer(), n.__webglUVBuffer = mt.createBuffer(), n.__webglUV2Buffer = mt.createBuffer(), n.__webglSkinIndicesBuffer = mt.createBuffer(), n.__webglSkinWeightsBuffer = mt.createBuffer(), n.__webglFaceBuffer = mt.createBuffer(), n.__webglLineBuffer = mt.createBuffer(), u = n.numMorphTargets)
                        for (n.__webglMorphTargetsBuffers = [], h = 0; u > h; h++) n.__webglMorphTargetsBuffers.push(mt.createBuffer());
                    if (u = n.numMorphNormals)
                        for (n.__webglMorphNormalsBuffers = [], h = 0; u > h; h++) n.__webglMorphNormalsBuffers.push(mt.createBuffer());
                    if (Y.info.memory.geometries++, n = s, m = e, E = m.geometry, u = n.faces3, h = 3 * u.length, d = 1 * u.length, f = 3 * u.length, u = i(m, n), n.__vertexArray = new Float32Array(3 * h), n.__normalArray = new Float32Array(3 * h), n.__colorArray = new Float32Array(3 * h), n.__uvArray = new Float32Array(2 * h), 1 < E.faceVertexUvs.length && (n.__uv2Array = new Float32Array(2 * h)), E.hasTangents && (n.__tangentArray = new Float32Array(4 * h)), m.geometry.skinWeights.length && m.geometry.skinIndices.length && (n.__skinIndexArray = new Float32Array(4 * h), n.__skinWeightArray = new Float32Array(4 * h)), m = null !== yt.get("OES_element_index_uint") && d > 21845 ? Uint32Array : Uint16Array, n.__typeArray = m, n.__faceArray = new m(3 * d), n.__lineArray = new m(2 * f), E = n.numMorphTargets)
                        for (n.__morphTargetsArrays = [], m = 0; E > m; m++) n.__morphTargetsArrays.push(new Float32Array(3 * h));
                    if (E = n.numMorphNormals)
                        for (n.__morphNormalsArrays = [], m = 0; E > m; m++) n.__morphNormalsArrays.push(new Float32Array(3 * h));
                    if (n.__webglFaceCount = 3 * d, n.__webglLineCount = 2 * f, u.attributes)
                        for (d in void 0 === n.__webglCustomAttributesList && (n.__webglCustomAttributesList = []), d = void 0, u.attributes) {
                            var f = u.attributes[d],
                                m = {},
                                g;
                            for (g in f) m[g] = f[g];
                            (!m.__webglInitialized || m.createUniqueBuffers) && (m.__webglInitialized = !0, E = 1, "v2" === m.type ? E = 2 : "v3" === m.type ? E = 3 : "v4" === m.type ? E = 4 : "c" === m.type && (E = 3), m.size = E, m.array = new Float32Array(h * E), m.buffer = mt.createBuffer(), m.buffer.belongsToAttribute = d, f.needsUpdate = !0, m.__original = f), n.__webglCustomAttributesList.push(m)
                        }
                    n.__inittedArrays = !0, t.verticesNeedUpdate = !0, t.morphTargetsNeedUpdate = !0, t.elementsNeedUpdate = !0, t.uvsNeedUpdate = !0, t.normalsNeedUpdate = !0, t.tangentsNeedUpdate = !0, n = t.colorsNeedUpdate = !0
                } else n = !1;
                (n || void 0 === e.__webglActive) && p(I, s, e)
            }
            e.__webglActive = !0
        }

        function p(e, t, i) {
            var r = i.id;
            e[r] = e[r] || [], e[r].push({
                id: r,
                buffer: t,
                object: i,
                material: null,
                z: 0
            })
        }

        function d(e) {
            var t = e.geometry;
            if (t instanceof THREE.BufferGeometry)
                for (var r = t.attributes, n = t.attributesKeys, o = 0, a = n.length; a > o; o++) {
                    var s = n[o],
                        l = r[s],
                        h = "index" === s ? mt.ELEMENT_ARRAY_BUFFER : mt.ARRAY_BUFFER;
                    void 0 === l.buffer ? (l.buffer = mt.createBuffer(), mt.bindBuffer(h, l.buffer), mt.bufferData(h, l.array, l instanceof THREE.DynamicBufferAttribute ? mt.DYNAMIC_DRAW : mt.STATIC_DRAW), l.needsUpdate = !1) : !0 === l.needsUpdate && (mt.bindBuffer(h, l.buffer), void 0 === l.updateRange || -1 === l.updateRange.count ? mt.bufferSubData(h, 0, l.array) : 0 === l.updateRange.count ? console.error("THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.") : (mt.bufferSubData(h, l.updateRange.offset * l.array.BYTES_PER_ELEMENT, l.array.subarray(l.updateRange.offset, l.updateRange.offset + l.updateRange.count)), l.updateRange.count = 0), l.needsUpdate = !1)
                } else if (e instanceof THREE.Mesh) {
                    !0 === t.groupsNeedUpdate && c(e, t);
                    for (var u = Xt[t.id], o = 0, p = u.length; p > o; o++) {
                        var d = u[o],
                            E = i(e, d),
                            v = E.attributes && f(E);
                        if (t.verticesNeedUpdate || t.morphTargetsNeedUpdate || t.elementsNeedUpdate || t.uvsNeedUpdate || t.normalsNeedUpdate || t.colorsNeedUpdate || t.tangentsNeedUpdate || v) {
                            var g = d,
                                y = e,
                                T = mt.DYNAMIC_DRAW,
                                x = !t.dynamic,
                                _ = E;
                            if (g.__inittedArrays) {
                                var R = !1 == _ instanceof THREE.MeshPhongMaterial && _.shading === THREE.FlatShading,
                                    b = void 0,
                                    H = void 0,
                                    w = void 0,
                                    M = void 0,
                                    S = void 0,
                                    C = void 0,
                                    A = void 0,
                                    P = void 0,
                                    L = void 0,
                                    D = void 0,
                                    O = void 0,
                                    F = void 0,
                                    k = void 0,
                                    U = void 0,
                                    N = void 0,
                                    B = void 0,
                                    z = void 0,
                                    V = void 0,
                                    I = void 0,
                                    j = void 0,
                                    G = void 0,
                                    W = void 0,
                                    X = void 0,
                                    q = void 0,
                                    Y = void 0,
                                    Q = void 0,
                                    K = void 0,
                                    Z = void 0,
                                    J = void 0,
                                    et = void 0,
                                    tt = void 0,
                                    it = void 0,
                                    rt = void 0,
                                    nt = void 0,
                                    ot = void 0,
                                    at = void 0,
                                    st = void 0,
                                    lt = void 0,
                                    ht = void 0,
                                    ut = void 0,
                                    ct = 0,
                                    pt = 0,
                                    dt = 0,
                                    ft = 0,
                                    Et = 0,
                                    vt = 0,
                                    gt = 0,
                                    yt = 0,
                                    Tt = 0,
                                    xt = 0,
                                    _t = 0,
                                    Rt = 0,
                                    bt = void 0,
                                    Ht = g.__vertexArray,
                                    wt = g.__uvArray,
                                    Mt = g.__uv2Array,
                                    St = g.__normalArray,
                                    Ct = g.__tangentArray,
                                    At = g.__colorArray,
                                    Pt = g.__skinIndexArray,
                                    Lt = g.__skinWeightArray,
                                    Dt = g.__morphTargetsArrays,
                                    Ot = g.__morphNormalsArrays,
                                    Ft = g.__webglCustomAttributesList,
                                    kt = void 0,
                                    Ut = g.__faceArray,
                                    Nt = g.__lineArray,
                                    Bt = y.geometry,
                                    zt = Bt.elementsNeedUpdate,
                                    Vt = Bt.uvsNeedUpdate,
                                    It = Bt.normalsNeedUpdate,
                                    jt = Bt.tangentsNeedUpdate,
                                    Gt = Bt.colorsNeedUpdate,
                                    Wt = Bt.morphTargetsNeedUpdate,
                                    qt = Bt.vertices,
                                    $ = g.faces3,
                                    Yt = Bt.faces,
                                    Qt = Bt.faceVertexUvs[0],
                                    Kt = Bt.faceVertexUvs[1],
                                    $t = Bt.skinIndices,
                                    Zt = Bt.skinWeights,
                                    Jt = Bt.morphTargets,
                                    ei = Bt.morphNormals;
                                if (Bt.verticesNeedUpdate) {
                                    for (b = 0, H = $.length; H > b; b++) M = Yt[$[b]], F = qt[M.a], k = qt[M.b], U = qt[M.c], Ht[pt] = F.x, Ht[pt + 1] = F.y, Ht[pt + 2] = F.z, Ht[pt + 3] = k.x, Ht[pt + 4] = k.y, Ht[pt + 5] = k.z, Ht[pt + 6] = U.x, Ht[pt + 7] = U.y, Ht[pt + 8] = U.z, pt += 9;
                                    mt.bindBuffer(mt.ARRAY_BUFFER, g.__webglVertexBuffer), mt.bufferData(mt.ARRAY_BUFFER, Ht, T)
                                }
                                if (Wt)
                                    for (ot = 0, at = Jt.length; at > ot; ot++) {
                                        for (b = _t = 0, H = $.length; H > b; b++) ht = $[b], M = Yt[ht], F = Jt[ot].vertices[M.a], k = Jt[ot].vertices[M.b], U = Jt[ot].vertices[M.c], st = Dt[ot], st[_t] = F.x, st[_t + 1] = F.y, st[_t + 2] = F.z, st[_t + 3] = k.x, st[_t + 4] = k.y, st[_t + 5] = k.z, st[_t + 6] = U.x, st[_t + 7] = U.y, st[_t + 8] = U.z, _.morphNormals && (R ? j = I = V = ei[ot].faceNormals[ht] : (ut = ei[ot].vertexNormals[ht], V = ut.a, I = ut.b, j = ut.c), lt = Ot[ot], lt[_t] = V.x, lt[_t + 1] = V.y, lt[_t + 2] = V.z, lt[_t + 3] = I.x, lt[_t + 4] = I.y, lt[_t + 5] = I.z, lt[_t + 6] = j.x, lt[_t + 7] = j.y, lt[_t + 8] = j.z), _t += 9;
                                        mt.bindBuffer(mt.ARRAY_BUFFER, g.__webglMorphTargetsBuffers[ot]), mt.bufferData(mt.ARRAY_BUFFER, Dt[ot], T), _.morphNormals && (mt.bindBuffer(mt.ARRAY_BUFFER, g.__webglMorphNormalsBuffers[ot]), mt.bufferData(mt.ARRAY_BUFFER, Ot[ot], T))
                                    }
                                if (Zt.length) {
                                    for (b = 0, H = $.length; H > b; b++) M = Yt[$[b]], q = Zt[M.a], Y = Zt[M.b], Q = Zt[M.c], Lt[xt] = q.x, Lt[xt + 1] = q.y, Lt[xt + 2] = q.z, Lt[xt + 3] = q.w, Lt[xt + 4] = Y.x, Lt[xt + 5] = Y.y, Lt[xt + 6] = Y.z, Lt[xt + 7] = Y.w, Lt[xt + 8] = Q.x, Lt[xt + 9] = Q.y, Lt[xt + 10] = Q.z, Lt[xt + 11] = Q.w, K = $t[M.a], Z = $t[M.b], J = $t[M.c], Pt[xt] = K.x, Pt[xt + 1] = K.y, Pt[xt + 2] = K.z, Pt[xt + 3] = K.w, Pt[xt + 4] = Z.x, Pt[xt + 5] = Z.y, Pt[xt + 6] = Z.z, Pt[xt + 7] = Z.w, Pt[xt + 8] = J.x, Pt[xt + 9] = J.y, Pt[xt + 10] = J.z, Pt[xt + 11] = J.w, xt += 12;
                                    xt > 0 && (mt.bindBuffer(mt.ARRAY_BUFFER, g.__webglSkinIndicesBuffer), mt.bufferData(mt.ARRAY_BUFFER, Pt, T), mt.bindBuffer(mt.ARRAY_BUFFER, g.__webglSkinWeightsBuffer), mt.bufferData(mt.ARRAY_BUFFER, Lt, T))
                                }
                                if (Gt) {
                                    for (b = 0, H = $.length; H > b; b++) M = Yt[$[b]], A = M.vertexColors, P = M.color, 3 === A.length && _.vertexColors === THREE.VertexColors ? (G = A[0], W = A[1], X = A[2]) : X = W = G = P, At[Tt] = G.r, At[Tt + 1] = G.g, At[Tt + 2] = G.b, At[Tt + 3] = W.r, At[Tt + 4] = W.g, At[Tt + 5] = W.b, At[Tt + 6] = X.r, At[Tt + 7] = X.g, At[Tt + 8] = X.b, Tt += 9;
                                    Tt > 0 && (mt.bindBuffer(mt.ARRAY_BUFFER, g.__webglColorBuffer), mt.bufferData(mt.ARRAY_BUFFER, At, T))
                                }
                                if (jt && Bt.hasTangents) {
                                    for (b = 0, H = $.length; H > b; b++) M = Yt[$[b]], L = M.vertexTangents, N = L[0], B = L[1], z = L[2], Ct[gt] = N.x, Ct[gt + 1] = N.y, Ct[gt + 2] = N.z, Ct[gt + 3] = N.w, Ct[gt + 4] = B.x, Ct[gt + 5] = B.y, Ct[gt + 6] = B.z, Ct[gt + 7] = B.w, Ct[gt + 8] = z.x, Ct[gt + 9] = z.y, Ct[gt + 10] = z.z, Ct[gt + 11] = z.w, gt += 12;
                                    mt.bindBuffer(mt.ARRAY_BUFFER, g.__webglTangentBuffer), mt.bufferData(mt.ARRAY_BUFFER, Ct, T)
                                }
                                if (It) {
                                    for (b = 0, H = $.length; H > b; b++)
                                        if (M = Yt[$[b]], S = M.vertexNormals, C = M.normal, 3 === S.length && !1 === R)
                                            for (et = 0; 3 > et; et++) it = S[et], St[vt] = it.x, St[vt + 1] = it.y, St[vt + 2] = it.z, vt += 3;
                                        else
                                            for (et = 0; 3 > et; et++) St[vt] = C.x, St[vt + 1] = C.y, St[vt + 2] = C.z, vt += 3;
                                    mt.bindBuffer(mt.ARRAY_BUFFER, g.__webglNormalBuffer), mt.bufferData(mt.ARRAY_BUFFER, St, T)
                                }
                                if (Vt && Qt) {
                                    for (b = 0, H = $.length; H > b; b++)
                                        if (w = $[b], D = Qt[w], void 0 !== D)
                                            for (et = 0; 3 > et; et++) rt = D[et], wt[dt] = rt.x, wt[dt + 1] = rt.y, dt += 2;
                                    dt > 0 && (mt.bindBuffer(mt.ARRAY_BUFFER, g.__webglUVBuffer), mt.bufferData(mt.ARRAY_BUFFER, wt, T))
                                }
                                if (Vt && Kt) {
                                    for (b = 0, H = $.length; H > b; b++)
                                        if (w = $[b], O = Kt[w], void 0 !== O)
                                            for (et = 0; 3 > et; et++) nt = O[et], Mt[ft] = nt.x, Mt[ft + 1] = nt.y, ft += 2;
                                    ft > 0 && (mt.bindBuffer(mt.ARRAY_BUFFER, g.__webglUV2Buffer), mt.bufferData(mt.ARRAY_BUFFER, Mt, T))
                                }
                                if (zt) {
                                    for (b = 0, H = $.length; H > b; b++) Ut[Et] = ct, Ut[Et + 1] = ct + 1, Ut[Et + 2] = ct + 2, Et += 3, Nt[yt] = ct, Nt[yt + 1] = ct + 1, Nt[yt + 2] = ct, Nt[yt + 3] = ct + 2, Nt[yt + 4] = ct + 1, Nt[yt + 5] = ct + 2, yt += 6, ct += 3;
                                    mt.bindBuffer(mt.ELEMENT_ARRAY_BUFFER, g.__webglFaceBuffer), mt.bufferData(mt.ELEMENT_ARRAY_BUFFER, Ut, T), mt.bindBuffer(mt.ELEMENT_ARRAY_BUFFER, g.__webglLineBuffer), mt.bufferData(mt.ELEMENT_ARRAY_BUFFER, Nt, T)
                                }
                                if (Ft)
                                    for (et = 0, tt = Ft.length; tt > et; et++)
                                        if (kt = Ft[et], kt.__original.needsUpdate) {
                                            if (Rt = 0, 1 === kt.size) {
                                                if (void 0 === kt.boundTo || "vertices" === kt.boundTo)
                                                    for (b = 0, H = $.length; H > b; b++) M = Yt[$[b]], kt.array[Rt] = kt.value[M.a], kt.array[Rt + 1] = kt.value[M.b], kt.array[Rt + 2] = kt.value[M.c], Rt += 3;
                                                else if ("faces" === kt.boundTo)
                                                    for (b = 0, H = $.length; H > b; b++) bt = kt.value[$[b]], kt.array[Rt] = bt, kt.array[Rt + 1] = bt, kt.array[Rt + 2] = bt, Rt += 3
                                            } else if (2 === kt.size) {
                                                if (void 0 === kt.boundTo || "vertices" === kt.boundTo)
                                                    for (b = 0, H = $.length; H > b; b++) M = Yt[$[b]], F = kt.value[M.a], k = kt.value[M.b], U = kt.value[M.c], kt.array[Rt] = F.x, kt.array[Rt + 1] = F.y, kt.array[Rt + 2] = k.x, kt.array[Rt + 3] = k.y, kt.array[Rt + 4] = U.x, kt.array[Rt + 5] = U.y, Rt += 6;
                                                else if ("faces" === kt.boundTo)
                                                    for (b = 0, H = $.length; H > b; b++) U = k = F = bt = kt.value[$[b]], kt.array[Rt] = F.x, kt.array[Rt + 1] = F.y, kt.array[Rt + 2] = k.x, kt.array[Rt + 3] = k.y, kt.array[Rt + 4] = U.x, kt.array[Rt + 5] = U.y, Rt += 6
                                            } else if (3 === kt.size) {
                                                var ti;
                                                if (ti = "c" === kt.type ? ["r", "g", "b"] : ["x", "y", "z"], void 0 === kt.boundTo || "vertices" === kt.boundTo)
                                                    for (b = 0, H = $.length; H > b; b++) M = Yt[$[b]], F = kt.value[M.a], k = kt.value[M.b], U = kt.value[M.c], kt.array[Rt] = F[ti[0]], kt.array[Rt + 1] = F[ti[1]], kt.array[Rt + 2] = F[ti[2]], kt.array[Rt + 3] = k[ti[0]], kt.array[Rt + 4] = k[ti[1]], kt.array[Rt + 5] = k[ti[2]], kt.array[Rt + 6] = U[ti[0]], kt.array[Rt + 7] = U[ti[1]], kt.array[Rt + 8] = U[ti[2]], Rt += 9;
                                                else if ("faces" === kt.boundTo)
                                                    for (b = 0, H = $.length; H > b; b++) U = k = F = bt = kt.value[$[b]], kt.array[Rt] = F[ti[0]], kt.array[Rt + 1] = F[ti[1]], kt.array[Rt + 2] = F[ti[2]], kt.array[Rt + 3] = k[ti[0]], kt.array[Rt + 4] = k[ti[1]], kt.array[Rt + 5] = k[ti[2]], kt.array[Rt + 6] = U[ti[0]], kt.array[Rt + 7] = U[ti[1]], kt.array[Rt + 8] = U[ti[2]], Rt += 9;
                                                else if ("faceVertices" === kt.boundTo)
                                                    for (b = 0, H = $.length; H > b; b++) bt = kt.value[$[b]], F = bt[0], k = bt[1], U = bt[2], kt.array[Rt] = F[ti[0]], kt.array[Rt + 1] = F[ti[1]], kt.array[Rt + 2] = F[ti[2]], kt.array[Rt + 3] = k[ti[0]], kt.array[Rt + 4] = k[ti[1]], kt.array[Rt + 5] = k[ti[2]], kt.array[Rt + 6] = U[ti[0]], kt.array[Rt + 7] = U[ti[1]], kt.array[Rt + 8] = U[ti[2]], Rt += 9
                                            } else if (4 === kt.size)
                                                if (void 0 === kt.boundTo || "vertices" === kt.boundTo)
                                                    for (b = 0, H = $.length; H > b; b++) M = Yt[$[b]], F = kt.value[M.a], k = kt.value[M.b], U = kt.value[M.c], kt.array[Rt] = F.x, kt.array[Rt + 1] = F.y, kt.array[Rt + 2] = F.z, kt.array[Rt + 3] = F.w, kt.array[Rt + 4] = k.x, kt.array[Rt + 5] = k.y, kt.array[Rt + 6] = k.z, kt.array[Rt + 7] = k.w, kt.array[Rt + 8] = U.x, kt.array[Rt + 9] = U.y, kt.array[Rt + 10] = U.z, kt.array[Rt + 11] = U.w, Rt += 12;
                                                else if ("faces" === kt.boundTo)
                                                for (b = 0, H = $.length; H > b; b++) U = k = F = bt = kt.value[$[b]], kt.array[Rt] = F.x, kt.array[Rt + 1] = F.y, kt.array[Rt + 2] = F.z, kt.array[Rt + 3] = F.w, kt.array[Rt + 4] = k.x, kt.array[Rt + 5] = k.y, kt.array[Rt + 6] = k.z, kt.array[Rt + 7] = k.w, kt.array[Rt + 8] = U.x, kt.array[Rt + 9] = U.y, kt.array[Rt + 10] = U.z, kt.array[Rt + 11] = U.w, Rt += 12;
                                            else if ("faceVertices" === kt.boundTo)
                                                for (b = 0, H = $.length; H > b; b++) bt = kt.value[$[b]], F = bt[0], k = bt[1], U = bt[2], kt.array[Rt] = F.x, kt.array[Rt + 1] = F.y, kt.array[Rt + 2] = F.z, kt.array[Rt + 3] = F.w, kt.array[Rt + 4] = k.x, kt.array[Rt + 5] = k.y, kt.array[Rt + 6] = k.z, kt.array[Rt + 7] = k.w, kt.array[Rt + 8] = U.x, kt.array[Rt + 9] = U.y, kt.array[Rt + 10] = U.z, kt.array[Rt + 11] = U.w, Rt += 12;
                                            mt.bindBuffer(mt.ARRAY_BUFFER, kt.buffer), mt.bufferData(mt.ARRAY_BUFFER, kt.array, T)
                                        }
                                x && (delete g.__inittedArrays, delete g.__colorArray, delete g.__normalArray, delete g.__tangentArray, delete g.__uvArray, delete g.__uv2Array, delete g.__faceArray, delete g.__vertexArray, delete g.__lineArray, delete g.__skinIndexArray, delete g.__skinWeightArray)
                            }
                        }
                    }
                    t.verticesNeedUpdate = !1, t.morphTargetsNeedUpdate = !1, t.elementsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.tangentsNeedUpdate = !1, E.attributes && m(E)
                } else if (e instanceof THREE.Line) {
                if (E = i(e, t), v = E.attributes && f(E), t.verticesNeedUpdate || t.colorsNeedUpdate || t.lineDistancesNeedUpdate || v) {
                    var ii = mt.DYNAMIC_DRAW,
                        ri, ni, oi, ai, si, li, hi = t.vertices,
                        ui = t.colors,
                        ci = t.lineDistances,
                        pi = hi.length,
                        di = ui.length,
                        fi = ci.length,
                        mi = t.__vertexArray,
                        Ei = t.__colorArray,
                        vi = t.__lineDistanceArray,
                        gi = t.colorsNeedUpdate,
                        yi = t.lineDistancesNeedUpdate,
                        Ti = t.__webglCustomAttributesList,
                        xi, _i, Ri, bi, Hi, wi;
                    if (t.verticesNeedUpdate) {
                        for (ri = 0; pi > ri; ri++) ai = hi[ri], si = 3 * ri, mi[si] = ai.x, mi[si + 1] = ai.y, mi[si + 2] = ai.z;
                        mt.bindBuffer(mt.ARRAY_BUFFER, t.__webglVertexBuffer), mt.bufferData(mt.ARRAY_BUFFER, mi, ii)
                    }
                    if (gi) {
                        for (ni = 0; di > ni; ni++) li = ui[ni], si = 3 * ni, Ei[si] = li.r, Ei[si + 1] = li.g, Ei[si + 2] = li.b;
                        mt.bindBuffer(mt.ARRAY_BUFFER, t.__webglColorBuffer), mt.bufferData(mt.ARRAY_BUFFER, Ei, ii)
                    }
                    if (yi) {
                        for (oi = 0; fi > oi; oi++) vi[oi] = ci[oi];
                        mt.bindBuffer(mt.ARRAY_BUFFER, t.__webglLineDistanceBuffer), mt.bufferData(mt.ARRAY_BUFFER, vi, ii)
                    }
                    if (Ti)
                        for (xi = 0, _i = Ti.length; _i > xi; xi++)
                            if (wi = Ti[xi], wi.needsUpdate && (void 0 === wi.boundTo || "vertices" === wi.boundTo)) {
                                if (si = 0, bi = wi.value.length, 1 === wi.size)
                                    for (Ri = 0; bi > Ri; Ri++) wi.array[Ri] = wi.value[Ri];
                                else if (2 === wi.size)
                                    for (Ri = 0; bi > Ri; Ri++) Hi = wi.value[Ri], wi.array[si] = Hi.x, wi.array[si + 1] = Hi.y, si += 2;
                                else if (3 === wi.size)
                                    if ("c" === wi.type)
                                        for (Ri = 0; bi > Ri; Ri++) Hi = wi.value[Ri], wi.array[si] = Hi.r, wi.array[si + 1] = Hi.g, wi.array[si + 2] = Hi.b, si += 3;
                                    else
                                        for (Ri = 0; bi > Ri; Ri++) Hi = wi.value[Ri], wi.array[si] = Hi.x, wi.array[si + 1] = Hi.y, wi.array[si + 2] = Hi.z, si += 3;
                                else if (4 === wi.size)
                                    for (Ri = 0; bi > Ri; Ri++) Hi = wi.value[Ri], wi.array[si] = Hi.x, wi.array[si + 1] = Hi.y, wi.array[si + 2] = Hi.z, wi.array[si + 3] = Hi.w, si += 4;
                                mt.bindBuffer(mt.ARRAY_BUFFER, wi.buffer), mt.bufferData(mt.ARRAY_BUFFER, wi.array, ii), wi.needsUpdate = !1
                            }
                }
                t.verticesNeedUpdate = !1, t.colorsNeedUpdate = !1, t.lineDistancesNeedUpdate = !1, E.attributes && m(E)
            } else if (e instanceof THREE.PointCloud) {
                if (E = i(e, t), v = E.attributes && f(E), t.verticesNeedUpdate || t.colorsNeedUpdate || v) {
                    var Mi = mt.DYNAMIC_DRAW,
                        Si, Ci, Ai, Pi, Li, Di = t.vertices,
                        Oi = Di.length,
                        Fi = t.colors,
                        ki = Fi.length,
                        Ui = t.__vertexArray,
                        Ni = t.__colorArray,
                        Bi = t.colorsNeedUpdate,
                        zi = t.__webglCustomAttributesList,
                        Vi, Ii, ji, Gi, Wi, Xi;
                    if (t.verticesNeedUpdate) {
                        for (Si = 0; Oi > Si; Si++) Ai = Di[Si], Pi = 3 * Si, Ui[Pi] = Ai.x, Ui[Pi + 1] = Ai.y, Ui[Pi + 2] = Ai.z;
                        mt.bindBuffer(mt.ARRAY_BUFFER, t.__webglVertexBuffer), mt.bufferData(mt.ARRAY_BUFFER, Ui, Mi)
                    }
                    if (Bi) {
                        for (Ci = 0; ki > Ci; Ci++) Li = Fi[Ci], Pi = 3 * Ci, Ni[Pi] = Li.r, Ni[Pi + 1] = Li.g, Ni[Pi + 2] = Li.b;
                        mt.bindBuffer(mt.ARRAY_BUFFER, t.__webglColorBuffer), mt.bufferData(mt.ARRAY_BUFFER, Ni, Mi)
                    }
                    if (zi)
                        for (Vi = 0, Ii = zi.length; Ii > Vi; Vi++) {
                            if (Xi = zi[Vi], Xi.needsUpdate && (void 0 === Xi.boundTo || "vertices" === Xi.boundTo))
                                if (Gi = Xi.value.length, Pi = 0, 1 === Xi.size)
                                    for (ji = 0; Gi > ji; ji++) Xi.array[ji] = Xi.value[ji];
                                else if (2 === Xi.size)
                                for (ji = 0; Gi > ji; ji++) Wi = Xi.value[ji], Xi.array[Pi] = Wi.x, Xi.array[Pi + 1] = Wi.y, Pi += 2;
                            else if (3 === Xi.size)
                                if ("c" === Xi.type)
                                    for (ji = 0; Gi > ji; ji++) Wi = Xi.value[ji], Xi.array[Pi] = Wi.r, Xi.array[Pi + 1] = Wi.g, Xi.array[Pi + 2] = Wi.b, Pi += 3;
                                else
                                    for (ji = 0; Gi > ji; ji++) Wi = Xi.value[ji], Xi.array[Pi] = Wi.x, Xi.array[Pi + 1] = Wi.y, Xi.array[Pi + 2] = Wi.z, Pi += 3;
                            else if (4 === Xi.size)
                                for (ji = 0; Gi > ji; ji++) Wi = Xi.value[ji], Xi.array[Pi] = Wi.x, Xi.array[Pi + 1] = Wi.y, Xi.array[Pi + 2] = Wi.z, Xi.array[Pi + 3] = Wi.w, Pi += 4;
                            mt.bindBuffer(mt.ARRAY_BUFFER, Xi.buffer), mt.bufferData(mt.ARRAY_BUFFER, Xi.array, Mi), Xi.needsUpdate = !1
                        }
                }
                t.verticesNeedUpdate = !1, t.colorsNeedUpdate = !1, E.attributes && m(E)
            }
        }

        function f(e) {
            for (var t in e.attributes)
                if (e.attributes[t].needsUpdate) return !0;
            return !1
        }

        function m(e) {
            for (var t in e.attributes) e.attributes[t].needsUpdate = !1
        }

        function E(e) {
            !0 === e.transparent ? gt.setBlending(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha) : gt.setBlending(THREE.NoBlending), gt.setDepthTest(e.depthTest), gt.setDepthWrite(e.depthWrite), gt.setColorWrite(e.colorWrite), gt.setPolygonOffset(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
        }

        function v(e, t, i, r, n) {
            var o, a, s, l;
            if (it = 0, r.needsUpdate) {
                r.program && Wt(r), r.addEventListener("dispose", jt);
                var h = Yt[r.type];
                if (h) {
                    var u = THREE.ShaderLib[h];
                    r.__webglShader = {
                        uniforms: THREE.UniformsUtils.clone(u.uniforms),
                        vertexShader: u.vertexShader,
                        fragmentShader: u.fragmentShader
                    }
                } else r.__webglShader = {
                    uniforms: r.uniforms,
                    vertexShader: r.vertexShader,
                    fragmentShader: r.fragmentShader
                };
                for (var c = 0, p = 0, d = 0, f = 0, m = 0, E = t.length; E > m; m++) {
                    var v = t[m];
                    v.onlyShadow || !1 === v.visible || (v instanceof THREE.DirectionalLight && c++, v instanceof THREE.PointLight && p++, v instanceof THREE.SpotLight && d++, v instanceof THREE.HemisphereLight && f++)
                }
                o = c, a = p, s = d, l = f;
                for (var T, b = 0, H = 0, w = t.length; w > H; H++) {
                    var C = t[H];
                    C.castShadow && (C instanceof THREE.SpotLight && b++, C instanceof THREE.DirectionalLight && !C.shadowCascade && b++)
                }
                T = b;
                var A;
                if (St && n && n.skeleton && n.skeleton.useVertexTexture) A = 1024;
                else {
                    var L = mt.getParameter(mt.MAX_VERTEX_UNIFORM_VECTORS),
                        D = Math.floor((L - 20) / 4);
                    void 0 !== n && n instanceof THREE.SkinnedMesh && (D = Math.min(n.skeleton.bones.length, D), D < n.skeleton.bones.length && THREE.warn("WebGLRenderer: too many bones - " + n.skeleton.bones.length + ", this GPU supports just " + D + " (try OpenGL instead of ANGLE)")), A = D
                }
                var O = {
                        precision: P,
                        supportsVertexTextures: Mt,
                        map: !!r.map,
                        envMap: !!r.envMap,
                        envMapMode: r.envMap && r.envMap.mapping,
                        lightMap: !!r.lightMap,
                        bumpMap: !!r.bumpMap,
                        normalMap: !!r.normalMap,
                        specularMap: !!r.specularMap,
                        alphaMap: !!r.alphaMap,
                        combine: r.combine,
                        vertexColors: r.vertexColors,
                        fog: i,
                        useFog: r.fog,
                        fogExp: i instanceof THREE.FogExp2,
                        flatShading: r.shading === THREE.FlatShading,
                        sizeAttenuation: r.sizeAttenuation,
                        logarithmicDepthBuffer: N,
                        skinning: r.skinning,
                        maxBones: A,
                        useVertexTexture: St && n && n.skeleton && n.skeleton.useVertexTexture,
                        morphTargets: r.morphTargets,
                        morphNormals: r.morphNormals,
                        maxMorphTargets: Y.maxMorphTargets,
                        maxMorphNormals: Y.maxMorphNormals,
                        maxDirLights: o,
                        maxPointLights: a,
                        maxSpotLights: s,
                        maxHemiLights: l,
                        maxShadows: T,
                        shadowMapEnabled: Y.shadowMapEnabled && n.receiveShadow && T > 0,
                        shadowMapType: Y.shadowMapType,
                        shadowMapDebug: Y.shadowMapDebug,
                        shadowMapCascade: Y.shadowMapCascade,
                        alphaTest: r.alphaTest,
                        metal: r.metal,
                        wrapAround: r.wrapAround,
                        doubleSided: r.side === THREE.DoubleSide,
                        flipSided: r.side === THREE.BackSide
                    },
                    F = [];
                if (h ? F.push(h) : (F.push(r.fragmentShader), F.push(r.vertexShader)), void 0 !== r.defines)
                    for (var k in r.defines) F.push(k), F.push(r.defines[k]);
                for (k in O) F.push(k), F.push(O[k]);
                for (var U = F.join(), B, z = 0, V = Q.length; V > z; z++) {
                    var I = Q[z];
                    if (I.code === U) {
                        B = I, B.usedTimes++;
                        break
                    }
                }
                void 0 === B && (B = new THREE.WebGLProgram(Y, U, r, O), Q.push(B), Y.info.memory.programs = Q.length), r.program = B;
                var j = B.attributes;
                if (r.morphTargets) {
                    r.numSupportedMorphTargets = 0;
                    for (var G, W = "morphTarget", X = 0; X < Y.maxMorphTargets; X++) G = W + X, 0 <= j[G] && r.numSupportedMorphTargets++
                }
                if (r.morphNormals)
                    for (r.numSupportedMorphNormals = 0, W = "morphNormal", X = 0; X < Y.maxMorphNormals; X++) G = W + X, 0 <= j[G] && r.numSupportedMorphNormals++;
                r.uniformsList = [];
                for (var q in r.__webglShader.uniforms) {
                    var Z = r.program.uniforms[q];
                    Z && r.uniformsList.push([r.__webglShader.uniforms[q], Z])
                }
                r.needsUpdate = !1
            }
            r.morphTargets && !n.__webglMorphTargetInfluences && (n.__webglMorphTargetInfluences = new Float32Array(Y.maxMorphTargets));
            var et = !1,
                rt = !1,
                nt = !1,
                ot = r.program,
                at = ot.uniforms,
                st = r.__webglShader.uniforms;
            if (ot.id !== K && (mt.useProgram(ot.program), K = ot.id, nt = rt = et = !0), r.id !== J && (-1 === J && (nt = !0), J = r.id, rt = !0), (et || e !== tt) && (mt.uniformMatrix4fv(at.projectionMatrix, !1, e.projectionMatrix.elements), N && mt.uniform1f(at.logDepthBufFC, 2 / (Math.log(e.far + 1) / Math.LN2)), e !== tt && (tt = e), (r instanceof THREE.ShaderMaterial || r instanceof THREE.MeshPhongMaterial || r.envMap) && null !== at.cameraPosition && (ct.setFromMatrixPosition(e.matrixWorld), mt.uniform3f(at.cameraPosition, ct.x, ct.y, ct.z)), (r instanceof THREE.MeshPhongMaterial || r instanceof THREE.MeshLambertMaterial || r instanceof THREE.MeshBasicMaterial || r instanceof THREE.ShaderMaterial || r.skinning) && null !== at.viewMatrix && mt.uniformMatrix4fv(at.viewMatrix, !1, e.matrixWorldInverse.elements)), r.skinning)
                if (n.bindMatrix && null !== at.bindMatrix && mt.uniformMatrix4fv(at.bindMatrix, !1, n.bindMatrix.elements), n.bindMatrixInverse && null !== at.bindMatrixInverse && mt.uniformMatrix4fv(at.bindMatrixInverse, !1, n.bindMatrixInverse.elements), St && n.skeleton && n.skeleton.useVertexTexture) {
                    if (null !== at.boneTexture) {
                        var lt = y();
                        mt.uniform1i(at.boneTexture, lt), Y.setTexture(n.skeleton.boneTexture, lt)
                    }
                    null !== at.boneTextureWidth && mt.uniform1i(at.boneTextureWidth, n.skeleton.boneTextureWidth), null !== at.boneTextureHeight && mt.uniform1i(at.boneTextureHeight, n.skeleton.boneTextureHeight)
                } else n.skeleton && n.skeleton.boneMatrices && null !== at.boneGlobalMatrices && mt.uniformMatrix4fv(at.boneGlobalMatrices, !1, n.skeleton.boneMatrices);
            if (rt) {
                if (i && r.fog && (st.fogColor.value = i.color, i instanceof THREE.Fog ? (st.fogNear.value = i.near, st.fogFar.value = i.far) : i instanceof THREE.FogExp2 && (st.fogDensity.value = i.density)), r instanceof THREE.MeshPhongMaterial || r instanceof THREE.MeshLambertMaterial || r.lights) {
                    if (dt) {
                        var nt = !0,
                            ht, ut, Et, vt = 0,
                            gt = 0,
                            yt = 0,
                            Tt, xt, _t, Rt, bt, Ht = ft,
                            Ct = Ht.directional.colors,
                            At = Ht.directional.positions,
                            Pt = Ht.point.colors,
                            Lt = Ht.point.positions,
                            Ot = Ht.point.distances,
                            Ft = Ht.point.decays,
                            kt = Ht.spot.colors,
                            Ut = Ht.spot.positions,
                            Nt = Ht.spot.distances,
                            Bt = Ht.spot.directions,
                            zt = Ht.spot.anglesCos,
                            It = Ht.spot.exponents,
                            Gt = Ht.spot.decays,
                            Xt = Ht.hemi.skyColors,
                            qt = Ht.hemi.groundColors,
                            Qt = Ht.hemi.positions,
                            Kt = 0,
                            $t = 0,
                            Zt = 0,
                            Jt = 0,
                            ei = 0,
                            ti = 0,
                            ii = 0,
                            ri = 0,
                            ni = 0,
                            oi = 0,
                            ai = 0,
                            si = 0;
                        for (ht = 0, ut = t.length; ut > ht; ht++) Et = t[ht], Et.onlyShadow || (Tt = Et.color, Rt = Et.intensity, bt = Et.distance, Et instanceof THREE.AmbientLight ? Et.visible && (vt += Tt.r, gt += Tt.g, yt += Tt.b) : Et instanceof THREE.DirectionalLight ? (ei += 1, Et.visible && (pt.setFromMatrixPosition(Et.matrixWorld), ct.setFromMatrixPosition(Et.target.matrixWorld), pt.sub(ct), pt.normalize(), ni = 3 * Kt, At[ni] = pt.x, At[ni + 1] = pt.y, At[ni + 2] = pt.z, x(Ct, ni, Tt, Rt), Kt += 1)) : Et instanceof THREE.PointLight ? (ti += 1, Et.visible && (oi = 3 * $t, x(Pt, oi, Tt, Rt), ct.setFromMatrixPosition(Et.matrixWorld), Lt[oi] = ct.x, Lt[oi + 1] = ct.y, Lt[oi + 2] = ct.z, Ot[$t] = bt, Ft[$t] = 0 === Et.distance ? 0 : Et.decay, $t += 1)) : Et instanceof THREE.SpotLight ? (ii += 1, Et.visible && (ai = 3 * Zt, x(kt, ai, Tt, Rt), pt.setFromMatrixPosition(Et.matrixWorld), Ut[ai] = pt.x, Ut[ai + 1] = pt.y, Ut[ai + 2] = pt.z, Nt[Zt] = bt, ct.setFromMatrixPosition(Et.target.matrixWorld), pt.sub(ct), pt.normalize(), Bt[ai] = pt.x, Bt[ai + 1] = pt.y, Bt[ai + 2] = pt.z, zt[Zt] = Math.cos(Et.angle), It[Zt] = Et.exponent, Gt[Zt] = 0 === Et.distance ? 0 : Et.decay, Zt += 1)) : Et instanceof THREE.HemisphereLight && (ri += 1, Et.visible && (pt.setFromMatrixPosition(Et.matrixWorld), pt.normalize(), si = 3 * Jt, Qt[si] = pt.x, Qt[si + 1] = pt.y, Qt[si + 2] = pt.z, xt = Et.color, _t = Et.groundColor, x(Xt, si, xt, Rt), x(qt, si, _t, Rt), Jt += 1)));
                        for (ht = 3 * Kt, ut = Math.max(Ct.length, 3 * ei); ut > ht; ht++) Ct[ht] = 0;
                        for (ht = 3 * $t, ut = Math.max(Pt.length, 3 * ti); ut > ht; ht++) Pt[ht] = 0;
                        for (ht = 3 * Zt, ut = Math.max(kt.length, 3 * ii); ut > ht; ht++) kt[ht] = 0;
                        for (ht = 3 * Jt, ut = Math.max(Xt.length, 3 * ri); ut > ht; ht++) Xt[ht] = 0;
                        for (ht = 3 * Jt, ut = Math.max(qt.length, 3 * ri); ut > ht; ht++) qt[ht] = 0;
                        Ht.directional.length = Kt, Ht.point.length = $t, Ht.spot.length = Zt, Ht.hemi.length = Jt, Ht.ambient[0] = vt, Ht.ambient[1] = gt, Ht.ambient[2] = yt, dt = !1
                    }
                    if (nt) {
                        var li = ft;
                        st.ambientLightColor.value = li.ambient, st.directionalLightColor.value = li.directional.colors, st.directionalLightDirection.value = li.directional.positions, st.pointLightColor.value = li.point.colors, st.pointLightPosition.value = li.point.positions, st.pointLightDistance.value = li.point.distances, st.pointLightDecay.value = li.point.decays, st.spotLightColor.value = li.spot.colors, st.spotLightPosition.value = li.spot.positions, st.spotLightDistance.value = li.spot.distances, st.spotLightDirection.value = li.spot.directions, st.spotLightAngleCos.value = li.spot.anglesCos, st.spotLightExponent.value = li.spot.exponents, st.spotLightDecay.value = li.spot.decays, st.hemisphereLightSkyColor.value = li.hemi.skyColors, st.hemisphereLightGroundColor.value = li.hemi.groundColors, st.hemisphereLightDirection.value = li.hemi.positions, g(st, !0)
                    } else g(st, !1)
                }
                if (r instanceof THREE.MeshBasicMaterial || r instanceof THREE.MeshLambertMaterial || r instanceof THREE.MeshPhongMaterial) {
                    st.opacity.value = r.opacity, st.diffuse.value = r.color, st.map.value = r.map, st.lightMap.value = r.lightMap, st.specularMap.value = r.specularMap, st.alphaMap.value = r.alphaMap, r.bumpMap && (st.bumpMap.value = r.bumpMap, st.bumpScale.value = r.bumpScale), r.normalMap && (st.normalMap.value = r.normalMap, st.normalScale.value.copy(r.normalScale));
                    var hi;
                    if (r.map ? hi = r.map : r.specularMap ? hi = r.specularMap : r.normalMap ? hi = r.normalMap : r.bumpMap ? hi = r.bumpMap : r.alphaMap && (hi = r.alphaMap), void 0 !== hi) {
                        var ui = hi.offset,
                            ci = hi.repeat;
                        st.offsetRepeat.value.set(ui.x, ui.y, ci.x, ci.y)
                    }
                    st.envMap.value = r.envMap, st.flipEnvMap.value = r.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1, st.reflectivity.value = r.reflectivity, st.refractionRatio.value = r.refractionRatio
                }
                if (r instanceof THREE.LineBasicMaterial) st.diffuse.value = r.color, st.opacity.value = r.opacity;
                else if (r instanceof THREE.LineDashedMaterial) st.diffuse.value = r.color, st.opacity.value = r.opacity, st.dashSize.value = r.dashSize, st.totalSize.value = r.dashSize + r.gapSize, st.scale.value = r.scale;
                else if (r instanceof THREE.PointCloudMaterial) {
                    if (st.psColor.value = r.color, st.opacity.value = r.opacity, st.size.value = r.size, st.scale.value = S.height / 2, st.map.value = r.map, null !== r.map) {
                        var pi = r.map.offset,
                            di = r.map.repeat;
                        st.offsetRepeat.value.set(pi.x, pi.y, di.x, di.y)
                    }
                } else r instanceof THREE.MeshPhongMaterial ? (st.shininess.value = r.shininess, st.emissive.value = r.emissive, st.specular.value = r.specular, r.wrapAround && st.wrapRGB.value.copy(r.wrapRGB)) : r instanceof THREE.MeshLambertMaterial ? (st.emissive.value = r.emissive, r.wrapAround && st.wrapRGB.value.copy(r.wrapRGB)) : r instanceof THREE.MeshDepthMaterial ? (st.mNear.value = e.near, st.mFar.value = e.far, st.opacity.value = r.opacity) : r instanceof THREE.MeshNormalMaterial && (st.opacity.value = r.opacity);
                if (n.receiveShadow && !r._shadowPass && st.shadowMatrix)
                    for (var fi = 0, mi = 0, $ = t.length; $ > mi; mi++) {
                        var Ei = t[mi];
                        Ei.castShadow && (Ei instanceof THREE.SpotLight || Ei instanceof THREE.DirectionalLight && !Ei.shadowCascade) && (st.shadowMap.value[fi] = Ei.shadowMap, st.shadowMapSize.value[fi] = Ei.shadowMapSize, st.shadowMatrix.value[fi] = Ei.shadowMatrix, st.shadowDarkness.value[fi] = Ei.shadowDarkness, st.shadowBias.value[fi] = Ei.shadowBias, fi++)
                    }
                for (var vi = r.uniformsList, gi, yi, Ti, xi = 0, _i = vi.length; _i > xi; xi++) {
                    var Ri = vi[xi][0];
                    if (!1 !== Ri.needsUpdate) {
                        var bi = Ri.type,
                            Hi = Ri.value,
                            wi = vi[xi][1];
                        switch (bi) {
                            case "1i":
                                mt.uniform1i(wi, Hi);
                                break;
                            case "1f":
                                mt.uniform1f(wi, Hi);
                                break;
                            case "2f":
                                mt.uniform2f(wi, Hi[0], Hi[1]);
                                break;
                            case "3f":
                                mt.uniform3f(wi, Hi[0], Hi[1], Hi[2]);
                                break;
                            case "4f":
                                mt.uniform4f(wi, Hi[0], Hi[1], Hi[2], Hi[3]);
                                break;
                            case "1iv":
                                mt.uniform1iv(wi, Hi);
                                break;
                            case "3iv":
                                mt.uniform3iv(wi, Hi);
                                break;
                            case "1fv":
                                mt.uniform1fv(wi, Hi);
                                break;
                            case "2fv":
                                mt.uniform2fv(wi, Hi);
                                break;
                            case "3fv":
                                mt.uniform3fv(wi, Hi);
                                break;
                            case "4fv":
                                mt.uniform4fv(wi, Hi);
                                break;
                            case "Matrix3fv":
                                mt.uniformMatrix3fv(wi, !1, Hi);
                                break;
                            case "Matrix4fv":
                                mt.uniformMatrix4fv(wi, !1, Hi);
                                break;
                            case "i":
                                mt.uniform1i(wi, Hi);
                                break;
                            case "f":
                                mt.uniform1f(wi, Hi);
                                break;
                            case "v2":
                                mt.uniform2f(wi, Hi.x, Hi.y);
                                break;
                            case "v3":
                                mt.uniform3f(wi, Hi.x, Hi.y, Hi.z);
                                break;
                            case "v4":
                                mt.uniform4f(wi, Hi.x, Hi.y, Hi.z, Hi.w);
                                break;
                            case "c":
                                mt.uniform3f(wi, Hi.r, Hi.g, Hi.b);
                                break;
                            case "iv1":
                                mt.uniform1iv(wi, Hi);
                                break;
                            case "iv":
                                mt.uniform3iv(wi, Hi);
                                break;
                            case "fv1":
                                mt.uniform1fv(wi, Hi);
                                break;
                            case "fv":
                                mt.uniform3fv(wi, Hi);
                                break;
                            case "v2v":
                                void 0 === Ri._array && (Ri._array = new Float32Array(2 * Hi.length));
                                for (var Mi = 0, Si = Hi.length; Si > Mi; Mi++) Ti = 2 * Mi, Ri._array[Ti] = Hi[Mi].x, Ri._array[Ti + 1] = Hi[Mi].y;
                                mt.uniform2fv(wi, Ri._array);
                                break;
                            case "v3v":
                                for (void 0 === Ri._array && (Ri._array = new Float32Array(3 * Hi.length)), Mi = 0, Si = Hi.length; Si > Mi; Mi++) Ti = 3 * Mi, Ri._array[Ti] = Hi[Mi].x, Ri._array[Ti + 1] = Hi[Mi].y, Ri._array[Ti + 2] = Hi[Mi].z;
                                mt.uniform3fv(wi, Ri._array);
                                break;
                            case "v4v":
                                for (void 0 === Ri._array && (Ri._array = new Float32Array(4 * Hi.length)), Mi = 0, Si = Hi.length; Si > Mi; Mi++) Ti = 4 * Mi, Ri._array[Ti] = Hi[Mi].x, Ri._array[Ti + 1] = Hi[Mi].y, Ri._array[Ti + 2] = Hi[Mi].z, Ri._array[Ti + 3] = Hi[Mi].w;
                                mt.uniform4fv(wi, Ri._array);
                                break;
                            case "m3":
                                mt.uniformMatrix3fv(wi, !1, Hi.elements);
                                break;
                            case "m3v":
                                for (void 0 === Ri._array && (Ri._array = new Float32Array(9 * Hi.length)), Mi = 0, Si = Hi.length; Si > Mi; Mi++) Hi[Mi].flattenToArrayOffset(Ri._array, 9 * Mi);
                                mt.uniformMatrix3fv(wi, !1, Ri._array);
                                break;
                            case "m4":
                                mt.uniformMatrix4fv(wi, !1, Hi.elements);
                                break;
                            case "m4v":
                                for (void 0 === Ri._array && (Ri._array = new Float32Array(16 * Hi.length)), Mi = 0, Si = Hi.length; Si > Mi; Mi++) Hi[Mi].flattenToArrayOffset(Ri._array, 16 * Mi);
                                mt.uniformMatrix4fv(wi, !1, Ri._array);
                                break;
                            case "t":
                                if (gi = Hi, yi = y(), mt.uniform1i(wi, yi), !gi) continue;
                                if (gi instanceof THREE.CubeTexture || gi.image instanceof Array && 6 === gi.image.length) {
                                    var Ci = gi,
                                        Ai = yi;
                                    if (6 === Ci.image.length)
                                        if (Ci.needsUpdate) {
                                            Ci.image.__webglTextureCube || (Ci.addEventListener("dispose", Vt), Ci.image.__webglTextureCube = mt.createTexture(), Y.info.memory.textures++), mt.activeTexture(mt.TEXTURE0 + Ai), mt.bindTexture(mt.TEXTURE_CUBE_MAP, Ci.image.__webglTextureCube), mt.pixelStorei(mt.UNPACK_FLIP_Y_WEBGL, Ci.flipY);
                                            for (var Pi = Ci instanceof THREE.CompressedTexture, Li = Ci.image[0] instanceof THREE.DataTexture, Di = [], Oi = 0; 6 > Oi; Oi++) Di[Oi] = !Y.autoScaleCubemaps || Pi || Li ? Li ? Ci.image[Oi].image : Ci.image[Oi] : R(Ci.image[Oi], wt);
                                            var Fi = Di[0],
                                                ki = THREE.Math.isPowerOfTwo(Fi.width) && THREE.Math.isPowerOfTwo(Fi.height),
                                                Ui = M(Ci.format),
                                                Ni = M(Ci.type);
                                            for (_(mt.TEXTURE_CUBE_MAP, Ci, ki), Oi = 0; 6 > Oi; Oi++)
                                                if (Pi)
                                                    for (var Bi, zi = Di[Oi].mipmaps, Vi = 0, Ii = zi.length; Ii > Vi; Vi++) Bi = zi[Vi], Ci.format !== THREE.RGBAFormat && Ci.format !== THREE.RGBFormat ? -1 < Dt().indexOf(Ui) ? mt.compressedTexImage2D(mt.TEXTURE_CUBE_MAP_POSITIVE_X + Oi, Vi, Ui, Bi.width, Bi.height, 0, Bi.data) : THREE.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()") : mt.texImage2D(mt.TEXTURE_CUBE_MAP_POSITIVE_X + Oi, Vi, Ui, Bi.width, Bi.height, 0, Ui, Ni, Bi.data);
                                                else Li ? mt.texImage2D(mt.TEXTURE_CUBE_MAP_POSITIVE_X + Oi, 0, Ui, Di[Oi].width, Di[Oi].height, 0, Ui, Ni, Di[Oi].data) : mt.texImage2D(mt.TEXTURE_CUBE_MAP_POSITIVE_X + Oi, 0, Ui, Ui, Ni, Di[Oi]);
                                            Ci.generateMipmaps && ki && mt.generateMipmap(mt.TEXTURE_CUBE_MAP), Ci.needsUpdate = !1, Ci.onUpdate && Ci.onUpdate()
                                        } else mt.activeTexture(mt.TEXTURE0 + Ai), mt.bindTexture(mt.TEXTURE_CUBE_MAP, Ci.image.__webglTextureCube)
                                } else if (gi instanceof THREE.WebGLRenderTargetCube) {
                                    var ji = gi;
                                    mt.activeTexture(mt.TEXTURE0 + yi), mt.bindTexture(mt.TEXTURE_CUBE_MAP, ji.__webglTexture)
                                } else Y.setTexture(gi, yi);
                                break;
                            case "tv":
                                for (void 0 === Ri._array && (Ri._array = []), Mi = 0, Si = Ri.value.length; Si > Mi; Mi++) Ri._array[Mi] = y();
                                for (mt.uniform1iv(wi, Ri._array), Mi = 0, Si = Ri.value.length; Si > Mi; Mi++) gi = Ri.value[Mi], yi = Ri._array[Mi], gi && Y.setTexture(gi, yi);
                                break;
                            default:
                                THREE.warn("THREE.WebGLRenderer: Unknown uniform type: " + bi)
                        }
                    }
                }
            }
            return mt.uniformMatrix4fv(at.modelViewMatrix, !1, n._modelViewMatrix.elements), at.normalMatrix && mt.uniformMatrix3fv(at.normalMatrix, !1, n._normalMatrix.elements), null !== at.modelMatrix && mt.uniformMatrix4fv(at.modelMatrix, !1, n.matrixWorld.elements), ot
        }

        function g(e, t) {
            e.ambientLightColor.needsUpdate = t, e.directionalLightColor.needsUpdate = t, e.directionalLightDirection.needsUpdate = t, e.pointLightColor.needsUpdate = t, e.pointLightPosition.needsUpdate = t, e.pointLightDistance.needsUpdate = t, e.pointLightDecay.needsUpdate = t, e.spotLightColor.needsUpdate = t, e.spotLightPosition.needsUpdate = t, e.spotLightDistance.needsUpdate = t, e.spotLightDirection.needsUpdate = t, e.spotLightAngleCos.needsUpdate = t, e.spotLightExponent.needsUpdate = t, e.spotLightDecay.needsUpdate = t, e.hemisphereLightSkyColor.needsUpdate = t, e.hemisphereLightGroundColor.needsUpdate = t, e.hemisphereLightDirection.needsUpdate = t
        }

        function y() {
            var e = it;
            return e >= Rt && THREE.warn("WebGLRenderer: trying to use " + e + " texture units while this GPU supports only " + Rt), it += 1, e
        }

        function T(e, t) {
            e._modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, e.matrixWorld), e._normalMatrix.getNormalMatrix(e._modelViewMatrix)
        }

        function x(e, t, i, r) {
            e[t] = i.r * r, e[t + 1] = i.g * r, e[t + 2] = i.b * r
        }

        function _(e, t, i) {
            i ? (mt.texParameteri(e, mt.TEXTURE_WRAP_S, M(t.wrapS)), mt.texParameteri(e, mt.TEXTURE_WRAP_T, M(t.wrapT)), mt.texParameteri(e, mt.TEXTURE_MAG_FILTER, M(t.magFilter)), mt.texParameteri(e, mt.TEXTURE_MIN_FILTER, M(t.minFilter))) : (mt.texParameteri(e, mt.TEXTURE_WRAP_S, mt.CLAMP_TO_EDGE), mt.texParameteri(e, mt.TEXTURE_WRAP_T, mt.CLAMP_TO_EDGE), t.wrapS === THREE.ClampToEdgeWrapping && t.wrapT === THREE.ClampToEdgeWrapping || THREE.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( " + t.sourceFile + " )"), mt.texParameteri(e, mt.TEXTURE_MAG_FILTER, w(t.magFilter)), mt.texParameteri(e, mt.TEXTURE_MIN_FILTER, w(t.minFilter)), t.minFilter !== THREE.NearestFilter && t.minFilter !== THREE.LinearFilter && THREE.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( " + t.sourceFile + " )")), (i = yt.get("EXT_texture_filter_anisotropic")) && t.type !== THREE.FloatType && t.type !== THREE.HalfFloatType && (1 < t.anisotropy || t.__currentAnisotropy) && (mt.texParameterf(e, i.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, Y.getMaxAnisotropy())), t.__currentAnisotropy = t.anisotropy)
        }

        function R(e, t) {
            if (e.width > t || e.height > t) {
                var i = t / Math.max(e.width, e.height),
                    r = document.createElement("canvas");
                return r.width = Math.floor(e.width * i), r.height = Math.floor(e.height * i), r.getContext("2d").drawImage(e, 0, 0, e.width, e.height, 0, 0, r.width, r.height), THREE.warn("THREE.WebGLRenderer: image is too big (" + e.width + "x" + e.height + "). Resized to " + r.width + "x" + r.height, e), r
            }
            return e
        }

        function b(e, t) {
            mt.bindRenderbuffer(mt.RENDERBUFFER, e), t.depthBuffer && !t.stencilBuffer ? (mt.renderbufferStorage(mt.RENDERBUFFER, mt.DEPTH_COMPONENT16, t.width, t.height), mt.framebufferRenderbuffer(mt.FRAMEBUFFER, mt.DEPTH_ATTACHMENT, mt.RENDERBUFFER, e)) : t.depthBuffer && t.stencilBuffer ? (mt.renderbufferStorage(mt.RENDERBUFFER, mt.DEPTH_STENCIL, t.width, t.height), mt.framebufferRenderbuffer(mt.FRAMEBUFFER, mt.DEPTH_STENCIL_ATTACHMENT, mt.RENDERBUFFER, e)) : mt.renderbufferStorage(mt.RENDERBUFFER, mt.RGBA4, t.width, t.height)
        }

        function H(e) {
            e instanceof THREE.WebGLRenderTargetCube ? (mt.bindTexture(mt.TEXTURE_CUBE_MAP, e.__webglTexture), mt.generateMipmap(mt.TEXTURE_CUBE_MAP), mt.bindTexture(mt.TEXTURE_CUBE_MAP, null)) : (mt.bindTexture(mt.TEXTURE_2D, e.__webglTexture), mt.generateMipmap(mt.TEXTURE_2D), mt.bindTexture(mt.TEXTURE_2D, null))
        }

        function w(e) {
            return e === THREE.NearestFilter || e === THREE.NearestMipMapNearestFilter || e === THREE.NearestMipMapLinearFilter ? mt.NEAREST : mt.LINEAR
        }

        function M(e) {
            var t;
            if (e === THREE.RepeatWrapping) return mt.REPEAT;
            if (e === THREE.ClampToEdgeWrapping) return mt.CLAMP_TO_EDGE;
            if (e === THREE.MirroredRepeatWrapping) return mt.MIRRORED_REPEAT;
            if (e === THREE.NearestFilter) return mt.NEAREST;
            if (e === THREE.NearestMipMapNearestFilter) return mt.NEAREST_MIPMAP_NEAREST;
            if (e === THREE.NearestMipMapLinearFilter) return mt.NEAREST_MIPMAP_LINEAR;
            if (e === THREE.LinearFilter) return mt.LINEAR;
            if (e === THREE.LinearMipMapNearestFilter) return mt.LINEAR_MIPMAP_NEAREST;
            if (e === THREE.LinearMipMapLinearFilter) return mt.LINEAR_MIPMAP_LINEAR;
            if (e === THREE.UnsignedByteType) return mt.UNSIGNED_BYTE;
            if (e === THREE.UnsignedShort4444Type) return mt.UNSIGNED_SHORT_4_4_4_4;
            if (e === THREE.UnsignedShort5551Type) return mt.UNSIGNED_SHORT_5_5_5_1;
            if (e === THREE.UnsignedShort565Type) return mt.UNSIGNED_SHORT_5_6_5;
            if (e === THREE.ByteType) return mt.BYTE;
            if (e === THREE.ShortType) return mt.SHORT;
            if (e === THREE.UnsignedShortType) return mt.UNSIGNED_SHORT;
            if (e === THREE.IntType) return mt.INT;
            if (e === THREE.UnsignedIntType) return mt.UNSIGNED_INT;
            if (e === THREE.FloatType) return mt.FLOAT;
            if (t = yt.get("OES_texture_half_float"), null !== t && e === THREE.HalfFloatType) return t.HALF_FLOAT_OES;
            if (e === THREE.AlphaFormat) return mt.ALPHA;
            if (e === THREE.RGBFormat) return mt.RGB;
            if (e === THREE.RGBAFormat) return mt.RGBA;
            if (e === THREE.LuminanceFormat) return mt.LUMINANCE;
            if (e === THREE.LuminanceAlphaFormat) return mt.LUMINANCE_ALPHA;
            if (e === THREE.AddEquation) return mt.FUNC_ADD;
            if (e === THREE.SubtractEquation) return mt.FUNC_SUBTRACT;
            if (e === THREE.ReverseSubtractEquation) return mt.FUNC_REVERSE_SUBTRACT;
            if (e === THREE.ZeroFactor) return mt.ZERO;
            if (e === THREE.OneFactor) return mt.ONE;
            if (e === THREE.SrcColorFactor) return mt.SRC_COLOR;
            if (e === THREE.OneMinusSrcColorFactor) return mt.ONE_MINUS_SRC_COLOR;
            if (e === THREE.SrcAlphaFactor) return mt.SRC_ALPHA;
            if (e === THREE.OneMinusSrcAlphaFactor) return mt.ONE_MINUS_SRC_ALPHA;
            if (e === THREE.DstAlphaFactor) return mt.DST_ALPHA;
            if (e === THREE.OneMinusDstAlphaFactor) return mt.ONE_MINUS_DST_ALPHA;
            if (e === THREE.DstColorFactor) return mt.DST_COLOR;
            if (e === THREE.OneMinusDstColorFactor) return mt.ONE_MINUS_DST_COLOR;
            if (e === THREE.SrcAlphaSaturateFactor) return mt.SRC_ALPHA_SATURATE;
            if (t = yt.get("WEBGL_compressed_texture_s3tc"), null !== t) {
                if (e === THREE.RGB_S3TC_DXT1_Format) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (e === THREE.RGBA_S3TC_DXT1_Format) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (e === THREE.RGBA_S3TC_DXT3_Format) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (e === THREE.RGBA_S3TC_DXT5_Format) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
            }
            if (t = yt.get("WEBGL_compressed_texture_pvrtc"), null !== t) {
                if (e === THREE.RGB_PVRTC_4BPPV1_Format) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (e === THREE.RGB_PVRTC_2BPPV1_Format) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (e === THREE.RGBA_PVRTC_4BPPV1_Format) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (e === THREE.RGBA_PVRTC_2BPPV1_Format) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (t = yt.get("EXT_blend_minmax"), null !== t) {
                if (e === THREE.MinEquation) return t.MIN_EXT;
                if (e === THREE.MaxEquation) return t.MAX_EXT
            }
            return 0
        }
        console.log("THREE.WebGLRenderer", THREE.REVISION), e = e || {};
        var S = void 0 !== e.canvas ? e.canvas : document.createElement("canvas"),
            C = void 0 !== e.context ? e.context : null,
            A = 1,
            P = void 0 !== e.precision ? e.precision : "highp",
            L = void 0 !== e.alpha ? e.alpha : !1,
            D = void 0 !== e.depth ? e.depth : !0,
            O = void 0 !== e.stencil ? e.stencil : !0,
            F = void 0 !== e.antialias ? e.antialias : !1,
            k = void 0 !== e.premultipliedAlpha ? e.premultipliedAlpha : !0,
            U = void 0 !== e.preserveDrawingBuffer ? e.preserveDrawingBuffer : !1,
            N = void 0 !== e.logarithmicDepthBuffer ? e.logarithmicDepthBuffer : !1,
            B = new THREE.Color(0),
            z = 0,
            V = [],
            I = {},
            j = [],
            G = [],
            W = [],
            X = [],
            q = [];
        this.domElement = S, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.gammaFactor = 2, this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1, this.shadowMapType = THREE.PCFShadowMap, this.shadowMapCullFace = THREE.CullFaceFront, this.shadowMapCascade = this.shadowMapDebug = !1, this.maxMorphTargets = 8, this.maxMorphNormals = 4, this.autoScaleCubemaps = !0, this.info = {
            memory: {
                programs: 0,
                geometries: 0,
                textures: 0
            },
            render: {
                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0
            }
        };
        var Y = this,
            Q = [],
            K = null,
            Z = null,
            J = -1,
            et = "",
            tt = null,
            it = 0,
            rt = 0,
            nt = 0,
            ot = S.width,
            at = S.height,
            st = 0,
            lt = 0,
            ht = new THREE.Frustum,
            ut = new THREE.Matrix4,
            ct = new THREE.Vector3,
            pt = new THREE.Vector3,
            dt = !0,
            ft = {
                ambient: [0, 0, 0],
                directional: {
                    length: 0,
                    colors: [],
                    positions: []
                },
                point: {
                    length: 0,
                    colors: [],
                    positions: [],
                    distances: [],
                    decays: []
                },
                spot: {
                    length: 0,
                    colors: [],
                    positions: [],
                    distances: [],
                    directions: [],
                    anglesCos: [],
                    exponents: [],
                    decays: []
                },
                hemi: {
                    length: 0,
                    skyColors: [],
                    groundColors: [],
                    positions: []
                }
            },
            mt;
        try {
            var Et = {
                alpha: L,
                depth: D,
                stencil: O,
                antialias: F,
                premultipliedAlpha: k,
                preserveDrawingBuffer: U
            };
            if (mt = C || S.getContext("webgl", Et) || S.getContext("experimental-webgl", Et), null === mt) {
                if (null !== S.getContext("webgl")) throw "Error creating WebGL context with your selected attributes.";
                throw "Error creating WebGL context."
            }
            S.addEventListener("webglcontextlost", function(e) {
                e.preventDefault(), _t(), xt(), I = {}
            }, !1)
        } catch (vt) {
            THREE.error("THREE.WebGLRenderer: " + vt)
        }
        var gt = new THREE.WebGLState(mt, M);
        void 0 === mt.getShaderPrecisionFormat && (mt.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        });
        var yt = new THREE.WebGLExtensions(mt);
        yt.get("OES_texture_float"), yt.get("OES_texture_float_linear"), yt.get("OES_texture_half_float"), yt.get("OES_texture_half_float_linear"), yt.get("OES_standard_derivatives"), N && yt.get("EXT_frag_depth");
        var Tt = function(e, t, i, r) {
                !0 === k && (e *= r, t *= r, i *= r), mt.clearColor(e, t, i, r)
            },
            xt = function() {
                mt.clearColor(0, 0, 0, 1), mt.clearDepth(1), mt.clearStencil(0), mt.enable(mt.DEPTH_TEST), mt.depthFunc(mt.LEQUAL), mt.frontFace(mt.CCW), mt.cullFace(mt.BACK), mt.enable(mt.CULL_FACE), mt.enable(mt.BLEND), mt.blendEquation(mt.FUNC_ADD), mt.blendFunc(mt.SRC_ALPHA, mt.ONE_MINUS_SRC_ALPHA), mt.viewport(rt, nt, ot, at), Tt(B.r, B.g, B.b, z)
            },
            _t = function() {
                tt = K = null, et = "", J = -1, dt = !0, gt.reset()
            };
        xt(), this.context = mt, this.state = gt;
        var Rt = mt.getParameter(mt.MAX_TEXTURE_IMAGE_UNITS),
            bt = mt.getParameter(mt.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            Ht = mt.getParameter(mt.MAX_TEXTURE_SIZE),
            wt = mt.getParameter(mt.MAX_CUBE_MAP_TEXTURE_SIZE),
            Mt = bt > 0,
            St = Mt && yt.get("OES_texture_float"),
            Ct = mt.getShaderPrecisionFormat(mt.VERTEX_SHADER, mt.HIGH_FLOAT),
            At = mt.getShaderPrecisionFormat(mt.VERTEX_SHADER, mt.MEDIUM_FLOAT),
            Pt = mt.getShaderPrecisionFormat(mt.FRAGMENT_SHADER, mt.HIGH_FLOAT),
            Lt = mt.getShaderPrecisionFormat(mt.FRAGMENT_SHADER, mt.MEDIUM_FLOAT),
            Dt = function() {
                var e;
                return function() {
                    if (void 0 !== e) return e;
                    if (e = [], yt.get("WEBGL_compressed_texture_pvrtc") || yt.get("WEBGL_compressed_texture_s3tc"))
                        for (var t = mt.getParameter(mt.COMPRESSED_TEXTURE_FORMATS), i = 0; i < t.length; i++) e.push(t[i]);
                    return e
                }
            }(),
            Ot = 0 < Ct.precision && 0 < Pt.precision,
            Ft = 0 < At.precision && 0 < Lt.precision;
        "highp" !== P || Ot || (Ft ? (P = "mediump", THREE.warn("THREE.WebGLRenderer: highp not supported, using mediump.")) : (P = "lowp", THREE.warn("THREE.WebGLRenderer: highp and mediump not supported, using lowp."))), "mediump" !== P || Ft || (P = "lowp", THREE.warn("THREE.WebGLRenderer: mediump not supported, using lowp."));
        var kt = new THREE.ShadowMapPlugin(this, V, I, j),
            Ut = new THREE.SpritePlugin(this, X),
            Nt = new THREE.LensFlarePlugin(this, q);
        this.getContext = function() {
            return mt
        }, this.forceContextLoss = function() {
            yt.get("WEBGL_lose_context").loseContext()
        }, this.supportsVertexTextures = function() {
            return Mt
        }, this.supportsFloatTextures = function() {
            return yt.get("OES_texture_float")
        }, this.supportsHalfFloatTextures = function() {
            return yt.get("OES_texture_half_float")
        }, this.supportsStandardDerivatives = function() {
            return yt.get("OES_standard_derivatives")
        }, this.supportsCompressedTextureS3TC = function() {
            return yt.get("WEBGL_compressed_texture_s3tc")
        }, this.supportsCompressedTexturePVRTC = function() {
            return yt.get("WEBGL_compressed_texture_pvrtc")
        }, this.supportsBlendMinMax = function() {
            return yt.get("EXT_blend_minmax")
        }, this.getMaxAnisotropy = function() {
            var e;
            return function() {
                if (void 0 !== e) return e;
                var t = yt.get("EXT_texture_filter_anisotropic");
                return e = null !== t ? mt.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            }
        }(), this.getPrecision = function() {
            return P
        }, this.getPixelRatio = function() {
            return A
        }, this.setPixelRatio = function(e) {
            A = e
        }, this.setSize = function(e, t, i) {
            S.width = e * A, S.height = t * A, !1 !== i && (S.style.width = e + "px", S.style.height = t + "px"), this.setViewport(0, 0, e, t)
        }, this.setViewport = function(e, t, i, r) {
            rt = e * A, nt = t * A, ot = i * A, at = r * A, mt.viewport(rt, nt, ot, at)
        }, this.setScissor = function(e, t, i, r) {
            mt.scissor(e * A, t * A, i * A, r * A)
        }, this.enableScissorTest = function(e) {
            e ? mt.enable(mt.SCISSOR_TEST) : mt.disable(mt.SCISSOR_TEST)
        }, this.getClearColor = function() {
            return B
        }, this.setClearColor = function(e, t) {
            B.set(e), z = void 0 !== t ? t : 1, Tt(B.r, B.g, B.b, z)
        }, this.getClearAlpha = function() {
            return z
        }, this.setClearAlpha = function(e) {
            z = e, Tt(B.r, B.g, B.b, z)
        }, this.clear = function(e, t, i) {
            var r = 0;
            (void 0 === e || e) && (r |= mt.COLOR_BUFFER_BIT), (void 0 === t || t) && (r |= mt.DEPTH_BUFFER_BIT), (void 0 === i || i) && (r |= mt.STENCIL_BUFFER_BIT), mt.clear(r)
        }, this.clearColor = function() {
            mt.clear(mt.COLOR_BUFFER_BIT)
        }, this.clearDepth = function() {
            mt.clear(mt.DEPTH_BUFFER_BIT)
        }, this.clearStencil = function() {
            mt.clear(mt.STENCIL_BUFFER_BIT)
        }, this.clearTarget = function(e, t, i, r) {
            this.setRenderTarget(e), this.clear(t, i, r)
        }, this.resetGLState = _t;
        var Bt = function(e) {
                e.target.traverse(function(e) {
                    if (e.removeEventListener("remove", Bt), e instanceof THREE.Mesh || e instanceof THREE.PointCloud || e instanceof THREE.Line) delete I[e.id];
                    else if (e instanceof THREE.ImmediateRenderObject || e.immediateRenderCallback)
                        for (var t = j, i = t.length - 1; i >= 0; i--) t[i].object === e && t.splice(i, 1);
                    delete e.__webglInit, delete e._modelViewMatrix, delete e._normalMatrix, delete e.__webglActive
                })
            },
            zt = function(e) {
                if (e = e.target, e.removeEventListener("dispose", zt), delete e.__webglInit, e instanceof THREE.BufferGeometry) {
                    for (var t in e.attributes) {
                        var i = e.attributes[t];
                        void 0 !== i.buffer && (mt.deleteBuffer(i.buffer), delete i.buffer)
                    }
                    Y.info.memory.geometries--
                } else if (t = Xt[e.id], void 0 !== t) {
                    for (var i = 0, r = t.length; r > i; i++) {
                        var n = t[i];
                        if (void 0 !== n.numMorphTargets) {
                            for (var o = 0, a = n.numMorphTargets; a > o; o++) mt.deleteBuffer(n.__webglMorphTargetsBuffers[o]);
                            delete n.__webglMorphTargetsBuffers
                        }
                        if (void 0 !== n.numMorphNormals) {
                            for (o = 0, a = n.numMorphNormals; a > o; o++) mt.deleteBuffer(n.__webglMorphNormalsBuffers[o]);
                            delete n.__webglMorphNormalsBuffers
                        }
                        Gt(n)
                    }
                    delete Xt[e.id]
                } else Gt(e);
                et = ""
            },
            Vt = function(e) {
                e = e.target, e.removeEventListener("dispose", Vt), e.image && e.image.__webglTextureCube ? (mt.deleteTexture(e.image.__webglTextureCube), delete e.image.__webglTextureCube) : void 0 !== e.__webglInit && (mt.deleteTexture(e.__webglTexture), delete e.__webglTexture, delete e.__webglInit), Y.info.memory.textures--
            },
            It = function(e) {
                if (e = e.target, e.removeEventListener("dispose", It), e && void 0 !== e.__webglTexture) {
                    if (mt.deleteTexture(e.__webglTexture), delete e.__webglTexture, e instanceof THREE.WebGLRenderTargetCube)
                        for (var t = 0; 6 > t; t++) mt.deleteFramebuffer(e.__webglFramebuffer[t]), mt.deleteRenderbuffer(e.__webglRenderbuffer[t]);
                    else mt.deleteFramebuffer(e.__webglFramebuffer), mt.deleteRenderbuffer(e.__webglRenderbuffer);
                    delete e.__webglFramebuffer, delete e.__webglRenderbuffer
                }
                Y.info.memory.textures--
            },
            jt = function(e) {
                e = e.target, e.removeEventListener("dispose", jt), Wt(e)
            },
            Gt = function(e) {
                for (var t = "__webglVertexBuffer __webglNormalBuffer __webglTangentBuffer __webglColorBuffer __webglUVBuffer __webglUV2Buffer __webglSkinIndicesBuffer __webglSkinWeightsBuffer __webglFaceBuffer __webglLineBuffer __webglLineDistanceBuffer".split(" "), i = 0, r = t.length; r > i; i++) {
                    var n = t[i];
                    void 0 !== e[n] && (mt.deleteBuffer(e[n]), delete e[n])
                }
                if (void 0 !== e.__webglCustomAttributesList) {
                    for (n in e.__webglCustomAttributesList) mt.deleteBuffer(e.__webglCustomAttributesList[n].buffer);
                    delete e.__webglCustomAttributesList
                }
                Y.info.memory.geometries--
            },
            Wt = function(e) {
                var t = e.program.program;
                if (void 0 !== t) {
                    e.program = void 0;
                    var i, r, n = !1;
                    for (e = 0, i = Q.length; i > e; e++)
                        if (r = Q[e], r.program === t) {
                            r.usedTimes--, 0 === r.usedTimes && (n = !0);
                            break
                        }
                    if (!0 === n) {
                        for (n = [], e = 0, i = Q.length; i > e; e++) r = Q[e], r.program !== t && n.push(r);
                        Q = n, mt.deleteProgram(t), Y.info.memory.programs--
                    }
                }
            };
        this.renderBufferImmediate = function(e, t, i) {
            if (gt.initAttributes(), e.hasPositions && !e.__webglVertexBuffer && (e.__webglVertexBuffer = mt.createBuffer()), e.hasNormals && !e.__webglNormalBuffer && (e.__webglNormalBuffer = mt.createBuffer()), e.hasUvs && !e.__webglUvBuffer && (e.__webglUvBuffer = mt.createBuffer()), e.hasColors && !e.__webglColorBuffer && (e.__webglColorBuffer = mt.createBuffer()), e.hasPositions && (mt.bindBuffer(mt.ARRAY_BUFFER, e.__webglVertexBuffer), mt.bufferData(mt.ARRAY_BUFFER, e.positionArray, mt.DYNAMIC_DRAW), gt.enableAttribute(t.attributes.position), mt.vertexAttribPointer(t.attributes.position, 3, mt.FLOAT, !1, 0, 0)), e.hasNormals) {
                if (mt.bindBuffer(mt.ARRAY_BUFFER, e.__webglNormalBuffer), !1 == i instanceof THREE.MeshPhongMaterial && i.shading === THREE.FlatShading) {
                    var r, n, o, a, s, l, h, u, c, p, d, f = 3 * e.count;
                    for (d = 0; f > d; d += 9) p = e.normalArray, r = p[d], n = p[d + 1], o = p[d + 2], a = p[d + 3], l = p[d + 4], u = p[d + 5], s = p[d + 6], h = p[d + 7], c = p[d + 8], r = (r + a + s) / 3, n = (n + l + h) / 3, o = (o + u + c) / 3, p[d] = r, p[d + 1] = n, p[d + 2] = o, p[d + 3] = r, p[d + 4] = n, p[d + 5] = o, p[d + 6] = r, p[d + 7] = n, p[d + 8] = o
                }
                mt.bufferData(mt.ARRAY_BUFFER, e.normalArray, mt.DYNAMIC_DRAW), gt.enableAttribute(t.attributes.normal), mt.vertexAttribPointer(t.attributes.normal, 3, mt.FLOAT, !1, 0, 0)
            }
            e.hasUvs && i.map && (mt.bindBuffer(mt.ARRAY_BUFFER, e.__webglUvBuffer), mt.bufferData(mt.ARRAY_BUFFER, e.uvArray, mt.DYNAMIC_DRAW), gt.enableAttribute(t.attributes.uv), mt.vertexAttribPointer(t.attributes.uv, 2, mt.FLOAT, !1, 0, 0)), e.hasColors && i.vertexColors !== THREE.NoColors && (mt.bindBuffer(mt.ARRAY_BUFFER, e.__webglColorBuffer), mt.bufferData(mt.ARRAY_BUFFER, e.colorArray, mt.DYNAMIC_DRAW), gt.enableAttribute(t.attributes.color), mt.vertexAttribPointer(t.attributes.color, 3, mt.FLOAT, !1, 0, 0)), gt.disableUnusedAttributes(), mt.drawArrays(mt.TRIANGLES, 0, e.count), e.count = 0
        }, this.renderBufferDirect = function(e, t, i, n, o, a) {
            if (!1 !== n.visible)
                if (d(a), e = v(e, t, i, n, a), t = !1, i = "direct_" + o.id + "_" + e.id + "_" + (n.wireframe ? 1 : 0), i !== et && (et = i, t = !0), t && gt.initAttributes(), a instanceof THREE.Mesh) {
                    a = !0 === n.wireframe ? mt.LINES : mt.TRIANGLES;
                    var s = o.attributes.index;
                    if (s) {
                        var l, h;
                        if (s.array instanceof Uint32Array && yt.get("OES_element_index_uint") ? (l = mt.UNSIGNED_INT, h = 4) : (l = mt.UNSIGNED_SHORT, h = 2), i = o.offsets, 0 === i.length) t && (r(n, e, o, 0), mt.bindBuffer(mt.ELEMENT_ARRAY_BUFFER, s.buffer)), mt.drawElements(a, s.array.length, l, 0), Y.info.render.calls++, Y.info.render.vertices += s.array.length, Y.info.render.faces += s.array.length / 3;
                        else {
                            t = !0;
                            for (var u = 0, c = i.length; c > u; u++) {
                                var p = i[u].index;
                                t && (r(n, e, o, p), mt.bindBuffer(mt.ELEMENT_ARRAY_BUFFER, s.buffer)), mt.drawElements(a, i[u].count, l, i[u].start * h), Y.info.render.calls++, Y.info.render.vertices += i[u].count, Y.info.render.faces += i[u].count / 3
                            }
                        }
                    } else t && r(n, e, o, 0), n = o.attributes.position, mt.drawArrays(a, 0, n.array.length / n.itemSize), Y.info.render.calls++, Y.info.render.vertices += n.array.length / n.itemSize, Y.info.render.faces += n.array.length / (3 * n.itemSize)
                } else if (a instanceof THREE.PointCloud)
                if (a = mt.POINTS, s = o.attributes.index)
                    if (s.array instanceof Uint32Array && yt.get("OES_element_index_uint") ? (l = mt.UNSIGNED_INT, h = 4) : (l = mt.UNSIGNED_SHORT, h = 2), i = o.offsets, 0 === i.length) t && (r(n, e, o, 0), mt.bindBuffer(mt.ELEMENT_ARRAY_BUFFER, s.buffer)), mt.drawElements(a, s.array.length, l, 0), Y.info.render.calls++, Y.info.render.points += s.array.length;
                    else
                        for (1 < i.length && (t = !0), u = 0, c = i.length; c > u; u++) p = i[u].index, t && (r(n, e, o, p), mt.bindBuffer(mt.ELEMENT_ARRAY_BUFFER, s.buffer)), mt.drawElements(a, i[u].count, l, i[u].start * h), Y.info.render.calls++, Y.info.render.points += i[u].count;
            else if (t && r(n, e, o, 0), n = o.attributes.position, i = o.offsets, 0 === i.length) mt.drawArrays(a, 0, n.array.length / 3), Y.info.render.calls++, Y.info.render.points += n.array.length / 3;
            else
                for (u = 0, c = i.length; c > u; u++) mt.drawArrays(a, i[u].index, i[u].count), Y.info.render.calls++, Y.info.render.points += i[u].count;
            else if (a instanceof THREE.Line)
                if (a = a.mode === THREE.LineStrip ? mt.LINE_STRIP : mt.LINES, gt.setLineWidth(n.linewidth * A), s = o.attributes.index)
                    if (s.array instanceof Uint32Array ? (l = mt.UNSIGNED_INT, h = 4) : (l = mt.UNSIGNED_SHORT, h = 2), i = o.offsets, 0 === i.length) t && (r(n, e, o, 0), mt.bindBuffer(mt.ELEMENT_ARRAY_BUFFER, s.buffer)), mt.drawElements(a, s.array.length, l, 0), Y.info.render.calls++, Y.info.render.vertices += s.array.length;
                    else
                        for (1 < i.length && (t = !0), u = 0, c = i.length; c > u; u++) p = i[u].index, t && (r(n, e, o, p), mt.bindBuffer(mt.ELEMENT_ARRAY_BUFFER, s.buffer)), mt.drawElements(a, i[u].count, l, i[u].start * h), Y.info.render.calls++, Y.info.render.vertices += i[u].count;
            else if (t && r(n, e, o, 0), n = o.attributes.position, i = o.offsets, 0 === i.length) mt.drawArrays(a, 0, n.array.length / 3), Y.info.render.calls++, Y.info.render.vertices += n.array.length / 3;
            else
                for (u = 0, c = i.length; c > u; u++) mt.drawArrays(a, i[u].index, i[u].count), Y.info.render.calls++, Y.info.render.vertices += i[u].count
        }, this.renderBuffer = function(e, t, i, r, n, o) {
            if (!1 !== r.visible) {
                if (d(o), i = v(e, t, i, r, o), t = i.attributes, e = !1, i = n.id + "_" + i.id + "_" + (r.wireframe ? 1 : 0), i !== et && (et = i, e = !0), e && gt.initAttributes(), !r.morphTargets && 0 <= t.position) e && (mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglVertexBuffer), gt.enableAttribute(t.position), mt.vertexAttribPointer(t.position, 3, mt.FLOAT, !1, 0, 0));
                else if (o.morphTargetBase) {
                    if (i = r.program.attributes, -1 !== o.morphTargetBase && 0 <= i.position ? (mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglMorphTargetsBuffers[o.morphTargetBase]), gt.enableAttribute(i.position), mt.vertexAttribPointer(i.position, 3, mt.FLOAT, !1, 0, 0)) : 0 <= i.position && (mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglVertexBuffer), gt.enableAttribute(i.position), mt.vertexAttribPointer(i.position, 3, mt.FLOAT, !1, 0, 0)), o.morphTargetForcedOrder.length)
                        for (var s = 0, l = o.morphTargetForcedOrder, h = o.morphTargetInfluences, u; s < r.numSupportedMorphTargets && s < l.length;) u = i["morphTarget" + s], u >= 0 && (mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglMorphTargetsBuffers[l[s]]), gt.enableAttribute(u), mt.vertexAttribPointer(u, 3, mt.FLOAT, !1, 0, 0)), u = i["morphNormal" + s], u >= 0 && r.morphNormals && (mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglMorphNormalsBuffers[l[s]]), gt.enableAttribute(u), mt.vertexAttribPointer(u, 3, mt.FLOAT, !1, 0, 0)), o.__webglMorphTargetInfluences[s] = h[l[s]], s++;
                    else {
                        for (l = [], h = o.morphTargetInfluences, s = o.geometry.morphTargets, h.length > s.length && (console.warn("THREE.WebGLRenderer: Influences array is bigger than morphTargets array."), h.length = s.length), s = 0, u = h.length; u > s; s++) l.push([h[s], s]);
                        l.length > r.numSupportedMorphTargets ? (l.sort(a), l.length = r.numSupportedMorphTargets) : l.length > r.numSupportedMorphNormals ? l.sort(a) : 0 === l.length && l.push([0, 0]);
                        for (var s = 0, c = r.numSupportedMorphTargets; c > s; s++)
                            if (l[s]) {
                                var p = l[s][1];
                                u = i["morphTarget" + s], u >= 0 && (mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglMorphTargetsBuffers[p]), gt.enableAttribute(u), mt.vertexAttribPointer(u, 3, mt.FLOAT, !1, 0, 0)), u = i["morphNormal" + s], u >= 0 && r.morphNormals && (mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglMorphNormalsBuffers[p]), gt.enableAttribute(u), mt.vertexAttribPointer(u, 3, mt.FLOAT, !1, 0, 0)), o.__webglMorphTargetInfluences[s] = h[p]
                            } else o.__webglMorphTargetInfluences[s] = 0
                    }
                    null !== r.program.uniforms.morphTargetInfluences && mt.uniform1fv(r.program.uniforms.morphTargetInfluences, o.__webglMorphTargetInfluences)
                }
                if (e) {
                    if (n.__webglCustomAttributesList)
                        for (i = 0, h = n.__webglCustomAttributesList.length; h > i; i++) l = n.__webglCustomAttributesList[i], 0 <= t[l.buffer.belongsToAttribute] && (mt.bindBuffer(mt.ARRAY_BUFFER, l.buffer), gt.enableAttribute(t[l.buffer.belongsToAttribute]), mt.vertexAttribPointer(t[l.buffer.belongsToAttribute], l.size, mt.FLOAT, !1, 0, 0));
                    0 <= t.color && (0 < o.geometry.colors.length || 0 < o.geometry.faces.length ? (mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglColorBuffer), gt.enableAttribute(t.color), mt.vertexAttribPointer(t.color, 3, mt.FLOAT, !1, 0, 0)) : void 0 !== r.defaultAttributeValues && mt.vertexAttrib3fv(t.color, r.defaultAttributeValues.color)), 0 <= t.normal && (mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglNormalBuffer), gt.enableAttribute(t.normal), mt.vertexAttribPointer(t.normal, 3, mt.FLOAT, !1, 0, 0)), 0 <= t.tangent && (mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglTangentBuffer), gt.enableAttribute(t.tangent), mt.vertexAttribPointer(t.tangent, 4, mt.FLOAT, !1, 0, 0)), 0 <= t.uv && (o.geometry.faceVertexUvs[0] ? (mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglUVBuffer), gt.enableAttribute(t.uv), mt.vertexAttribPointer(t.uv, 2, mt.FLOAT, !1, 0, 0)) : void 0 !== r.defaultAttributeValues && mt.vertexAttrib2fv(t.uv, r.defaultAttributeValues.uv)), 0 <= t.uv2 && (o.geometry.faceVertexUvs[1] ? (mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglUV2Buffer), gt.enableAttribute(t.uv2), mt.vertexAttribPointer(t.uv2, 2, mt.FLOAT, !1, 0, 0)) : void 0 !== r.defaultAttributeValues && mt.vertexAttrib2fv(t.uv2, r.defaultAttributeValues.uv2)), r.skinning && 0 <= t.skinIndex && 0 <= t.skinWeight && (mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglSkinIndicesBuffer), gt.enableAttribute(t.skinIndex), mt.vertexAttribPointer(t.skinIndex, 4, mt.FLOAT, !1, 0, 0), mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglSkinWeightsBuffer), gt.enableAttribute(t.skinWeight), mt.vertexAttribPointer(t.skinWeight, 4, mt.FLOAT, !1, 0, 0)), 0 <= t.lineDistance && (mt.bindBuffer(mt.ARRAY_BUFFER, n.__webglLineDistanceBuffer), gt.enableAttribute(t.lineDistance), mt.vertexAttribPointer(t.lineDistance, 1, mt.FLOAT, !1, 0, 0))
                }
                gt.disableUnusedAttributes(), o instanceof THREE.Mesh ? (o = n.__typeArray === Uint32Array ? mt.UNSIGNED_INT : mt.UNSIGNED_SHORT, r.wireframe ? (gt.setLineWidth(r.wireframeLinewidth * A), e && mt.bindBuffer(mt.ELEMENT_ARRAY_BUFFER, n.__webglLineBuffer), mt.drawElements(mt.LINES, n.__webglLineCount, o, 0)) : (e && mt.bindBuffer(mt.ELEMENT_ARRAY_BUFFER, n.__webglFaceBuffer), mt.drawElements(mt.TRIANGLES, n.__webglFaceCount, o, 0)), Y.info.render.calls++, Y.info.render.vertices += n.__webglFaceCount, Y.info.render.faces += n.__webglFaceCount / 3) : o instanceof THREE.Line ? (o = o.mode === THREE.LineStrip ? mt.LINE_STRIP : mt.LINES, gt.setLineWidth(r.linewidth * A), mt.drawArrays(o, 0, n.__webglLineCount), Y.info.render.calls++) : o instanceof THREE.PointCloud && (mt.drawArrays(mt.POINTS, 0, n.__webglParticleCount), Y.info.render.calls++, Y.info.render.points += n.__webglParticleCount)
            }
        }, this.render = function(e, t, i, r) {
            if (!1 == t instanceof THREE.Camera) THREE.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            else {
                var a = e.fog;
                et = "", J = -1, tt = null, dt = !0, !0 === e.autoUpdate && e.updateMatrixWorld(), void 0 === t.parent && t.updateMatrixWorld(), e.traverse(function(e) {
                    e instanceof THREE.SkinnedMesh && e.skeleton.update()
                }), t.matrixWorldInverse.getInverse(t.matrixWorld), ut.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), ht.setFromMatrix(ut), V.length = 0, G.length = 0, W.length = 0, X.length = 0, q.length = 0, s(e), !0 === Y.sortObjects && (G.sort(n), W.sort(o)), kt.render(e, t), Y.info.render.calls = 0, Y.info.render.vertices = 0, Y.info.render.faces = 0, Y.info.render.points = 0, this.setRenderTarget(i), (this.autoClear || r) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), r = 0;
                for (var c = j.length; c > r; r++) {
                    var p = j[r],
                        d = p.object;
                    d.visible && (T(d, t), u(p))
                }
                e.overrideMaterial ? (r = e.overrideMaterial, E(r), l(G, t, V, a, r), l(W, t, V, a, r), h(j, "", t, V, a, r)) : (gt.setBlending(THREE.NoBlending), l(G, t, V, a, null), h(j, "opaque", t, V, a, null), l(W, t, V, a, null), h(j, "transparent", t, V, a, null)), Ut.render(e, t), Nt.render(e, t, st, lt), i && i.generateMipmaps && i.minFilter !== THREE.NearestFilter && i.minFilter !== THREE.LinearFilter && H(i), gt.setDepthTest(!0), gt.setDepthWrite(!0), gt.setColorWrite(!0)
            }
        }, this.renderImmediateObject = function(e, t, i, r, n) {
            var o = v(e, t, i, r, n);
            et = "", Y.setMaterialFaces(r), n.immediateRenderCallback ? n.immediateRenderCallback(o, mt, ht) : n.render(function(e) {
                Y.renderBufferImmediate(e, o, r)
            })
        };
        var Xt = {},
            qt = 0,
            Yt = {
                MeshDepthMaterial: "depth",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointCloudMaterial: "particle_basic"
            };
        this.setFaceCulling = function(e, t) {
            e === THREE.CullFaceNone ? mt.disable(mt.CULL_FACE) : (mt.frontFace(t === THREE.FrontFaceDirectionCW ? mt.CW : mt.CCW), mt.cullFace(e === THREE.CullFaceBack ? mt.BACK : e === THREE.CullFaceFront ? mt.FRONT : mt.FRONT_AND_BACK), mt.enable(mt.CULL_FACE))
        }, this.setMaterialFaces = function(e) {
            gt.setDoubleSided(e.side === THREE.DoubleSide), gt.setFlipSided(e.side === THREE.BackSide)
        }, this.uploadTexture = function(e) {
            void 0 === e.__webglInit && (e.__webglInit = !0, e.addEventListener("dispose", Vt), e.__webglTexture = mt.createTexture(), Y.info.memory.textures++), mt.bindTexture(mt.TEXTURE_2D, e.__webglTexture), mt.pixelStorei(mt.UNPACK_FLIP_Y_WEBGL, e.flipY), mt.pixelStorei(mt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha), mt.pixelStorei(mt.UNPACK_ALIGNMENT, e.unpackAlignment), e.image = R(e.image, Ht);
            var t = e.image,
                i = THREE.Math.isPowerOfTwo(t.width) && THREE.Math.isPowerOfTwo(t.height),
                r = M(e.format),
                n = M(e.type);
            _(mt.TEXTURE_2D, e, i);
            var o = e.mipmaps;
            if (e instanceof THREE.DataTexture)
                if (0 < o.length && i) {
                    for (var a = 0, s = o.length; s > a; a++) t = o[a], mt.texImage2D(mt.TEXTURE_2D, a, r, t.width, t.height, 0, r, n, t.data);
                    e.generateMipmaps = !1
                } else mt.texImage2D(mt.TEXTURE_2D, 0, r, t.width, t.height, 0, r, n, t.data);
            else if (e instanceof THREE.CompressedTexture)
                for (a = 0, s = o.length; s > a; a++) t = o[a], e.format !== THREE.RGBAFormat && e.format !== THREE.RGBFormat ? -1 < Dt().indexOf(r) ? mt.compressedTexImage2D(mt.TEXTURE_2D, a, r, t.width, t.height, 0, t.data) : THREE.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : mt.texImage2D(mt.TEXTURE_2D, a, r, t.width, t.height, 0, r, n, t.data);
            else if (0 < o.length && i) {
                for (a = 0, s = o.length; s > a; a++) t = o[a], mt.texImage2D(mt.TEXTURE_2D, a, r, r, n, t);
                e.generateMipmaps = !1
            } else mt.texImage2D(mt.TEXTURE_2D, 0, r, r, n, e.image);
            e.generateMipmaps && i && mt.generateMipmap(mt.TEXTURE_2D), e.needsUpdate = !1, e.onUpdate && e.onUpdate()
        }, this.setTexture = function(e, t) {
            mt.activeTexture(mt.TEXTURE0 + t), e.needsUpdate ? Y.uploadTexture(e) : mt.bindTexture(mt.TEXTURE_2D, e.__webglTexture)
        }, this.setRenderTarget = function(e) {
            var t = e instanceof THREE.WebGLRenderTargetCube;
            if (e && void 0 === e.__webglFramebuffer) {
                void 0 === e.depthBuffer && (e.depthBuffer = !0), void 0 === e.stencilBuffer && (e.stencilBuffer = !0), e.addEventListener("dispose", It), e.__webglTexture = mt.createTexture(), Y.info.memory.textures++;
                var i = THREE.Math.isPowerOfTwo(e.width) && THREE.Math.isPowerOfTwo(e.height),
                    r = M(e.format),
                    n = M(e.type);
                if (t) {
                    e.__webglFramebuffer = [], e.__webglRenderbuffer = [], mt.bindTexture(mt.TEXTURE_CUBE_MAP, e.__webglTexture), _(mt.TEXTURE_CUBE_MAP, e, i);
                    for (var o = 0; 6 > o; o++) {
                        e.__webglFramebuffer[o] = mt.createFramebuffer(), e.__webglRenderbuffer[o] = mt.createRenderbuffer(), mt.texImage2D(mt.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, r, e.width, e.height, 0, r, n, null);
                        var a = e,
                            s = mt.TEXTURE_CUBE_MAP_POSITIVE_X + o;
                        mt.bindFramebuffer(mt.FRAMEBUFFER, e.__webglFramebuffer[o]), mt.framebufferTexture2D(mt.FRAMEBUFFER, mt.COLOR_ATTACHMENT0, s, a.__webglTexture, 0), b(e.__webglRenderbuffer[o], e)
                    }
                    i && mt.generateMipmap(mt.TEXTURE_CUBE_MAP)
                } else e.__webglFramebuffer = mt.createFramebuffer(), e.__webglRenderbuffer = e.shareDepthFrom ? e.shareDepthFrom.__webglRenderbuffer : mt.createRenderbuffer(), mt.bindTexture(mt.TEXTURE_2D, e.__webglTexture), _(mt.TEXTURE_2D, e, i), mt.texImage2D(mt.TEXTURE_2D, 0, r, e.width, e.height, 0, r, n, null), r = mt.TEXTURE_2D, mt.bindFramebuffer(mt.FRAMEBUFFER, e.__webglFramebuffer), mt.framebufferTexture2D(mt.FRAMEBUFFER, mt.COLOR_ATTACHMENT0, r, e.__webglTexture, 0), e.shareDepthFrom ? e.depthBuffer && !e.stencilBuffer ? mt.framebufferRenderbuffer(mt.FRAMEBUFFER, mt.DEPTH_ATTACHMENT, mt.RENDERBUFFER, e.__webglRenderbuffer) : e.depthBuffer && e.stencilBuffer && mt.framebufferRenderbuffer(mt.FRAMEBUFFER, mt.DEPTH_STENCIL_ATTACHMENT, mt.RENDERBUFFER, e.__webglRenderbuffer) : b(e.__webglRenderbuffer, e), i && mt.generateMipmap(mt.TEXTURE_2D);
                t ? mt.bindTexture(mt.TEXTURE_CUBE_MAP, null) : mt.bindTexture(mt.TEXTURE_2D, null), mt.bindRenderbuffer(mt.RENDERBUFFER, null), mt.bindFramebuffer(mt.FRAMEBUFFER, null)
            }
            e ? (t = t ? e.__webglFramebuffer[e.activeCubeFace] : e.__webglFramebuffer, i = e.width, e = e.height, n = r = 0) : (t = null, i = ot, e = at, r = rt, n = nt), t !== Z && (mt.bindFramebuffer(mt.FRAMEBUFFER, t), mt.viewport(r, n, i, e), Z = t), st = i, lt = e
        }, this.readRenderTargetPixels = function(e, t, i, r, n, o) {
            if (e instanceof THREE.WebGLRenderTarget) {
                if (e.__webglFramebuffer)
                    if (e.format !== THREE.RGBAFormat) console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.");
                    else {
                        var a = !1;
                        e.__webglFramebuffer !== Z && (mt.bindFramebuffer(mt.FRAMEBUFFER, e.__webglFramebuffer), a = !0), mt.checkFramebufferStatus(mt.FRAMEBUFFER) === mt.FRAMEBUFFER_COMPLETE ? mt.readPixels(t, i, r, n, mt.RGBA, mt.UNSIGNED_BYTE, o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."), a && mt.bindFramebuffer(mt.FRAMEBUFFER, Z)
                    }
            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }, this.initMaterial = function() {
            THREE.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        }, this.addPrePlugin = function() {
            THREE.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        }, this.addPostPlugin = function() {
            THREE.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        }, this.updateShadowMap = function() {
            THREE.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }
    }, THREE.WebGLRenderTarget = function(e, t, i) {
        this.width = e, this.height = t, i = i || {}, this.wrapS = void 0 !== i.wrapS ? i.wrapS : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== i.wrapT ? i.wrapT : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== i.magFilter ? i.magFilter : THREE.LinearFilter, this.minFilter = void 0 !== i.minFilter ? i.minFilter : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.format = void 0 !== i.format ? i.format : THREE.RGBAFormat, this.type = void 0 !== i.type ? i.type : THREE.UnsignedByteType, this.depthBuffer = void 0 !== i.depthBuffer ? i.depthBuffer : !0, this.stencilBuffer = void 0 !== i.stencilBuffer ? i.stencilBuffer : !0, this.generateMipmaps = !0, this.shareDepthFrom = void 0 !== i.shareDepthFrom ? i.shareDepthFrom : null
    }, THREE.WebGLRenderTarget.prototype = {
        constructor: THREE.WebGLRenderTarget,
        setSize: function(e, t) {
            this.width = e, this.height = t
        },
        clone: function() {
            var e = new THREE.WebGLRenderTarget(this.width, this.height);
            return e.wrapS = this.wrapS, e.wrapT = this.wrapT, e.magFilter = this.magFilter, e.minFilter = this.minFilter, e.anisotropy = this.anisotropy, e.offset.copy(this.offset), e.repeat.copy(this.repeat), e.format = this.format, e.type = this.type, e.depthBuffer = this.depthBuffer, e.stencilBuffer = this.stencilBuffer, e.generateMipmaps = this.generateMipmaps, e.shareDepthFrom = this.shareDepthFrom, e
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype), THREE.WebGLRenderTargetCube = function(e, t, i) {
        THREE.WebGLRenderTarget.call(this, e, t, i), this.activeCubeFace = 0
    }, THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype), THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube, THREE.WebGLExtensions = function(e) {
        var t = {};
        this.get = function(i) {
            if (void 0 !== t[i]) return t[i];
            var r;
            switch (i) {
                case "EXT_texture_filter_anisotropic":
                    r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    r = e.getExtension(i)
            }
            return null === r && THREE.warn("THREE.WebGLRenderer: " + i + " extension not supported."), t[i] = r
        }
    }, THREE.WebGLProgram = function() {
        var e = 0;
        return function(t, i, r, n) {
            var o = t.context,
                a = r.defines,
                s = r.__webglShader.uniforms,
                l = r.attributes,
                h = r.__webglShader.vertexShader,
                u = r.__webglShader.fragmentShader,
                c = r.index0AttributeName;
            void 0 === c && !0 === n.morphTargets && (c = "position");
            var p = "SHADOWMAP_TYPE_BASIC";
            n.shadowMapType === THREE.PCFShadowMap ? p = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === THREE.PCFSoftShadowMap && (p = "SHADOWMAP_TYPE_PCF_SOFT");
            var d = "ENVMAP_TYPE_CUBE",
                f = "ENVMAP_MODE_REFLECTION",
                m = "ENVMAP_BLENDING_MULTIPLY";
            if (n.envMap) {
                switch (r.envMap.mapping) {
                    case THREE.CubeReflectionMapping:
                    case THREE.CubeRefractionMapping:
                        d = "ENVMAP_TYPE_CUBE";
                        break;
                    case THREE.EquirectangularReflectionMapping:
                    case THREE.EquirectangularRefractionMapping:
                        d = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case THREE.SphericalReflectionMapping:
                        d = "ENVMAP_TYPE_SPHERE"
                }
                switch (r.envMap.mapping) {
                    case THREE.CubeRefractionMapping:
                    case THREE.EquirectangularRefractionMapping:
                        f = "ENVMAP_MODE_REFRACTION"
                }
                switch (r.combine) {
                    case THREE.MultiplyOperation:
                        m = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case THREE.MixOperation:
                        m = "ENVMAP_BLENDING_MIX";
                        break;
                    case THREE.AddOperation:
                        m = "ENVMAP_BLENDING_ADD"
                }
            }
            var E = 0 < t.gammaFactor ? t.gammaFactor : 1,
                v, g;
            v = [];
            for (var y in a) g = a[y], !1 !== g && (g = "#define " + y + " " + g, v.push(g));
            v = v.join("\n"), a = o.createProgram(), r instanceof THREE.RawShaderMaterial ? t = r = "" : (r = ["precision " + n.precision + " float;", "precision " + n.precision + " int;", v, n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", t.gammaInput ? "#define GAMMA_INPUT" : "", t.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + E, "#define MAX_DIR_LIGHTS " + n.maxDirLights, "#define MAX_POINT_LIGHTS " + n.maxPointLights, "#define MAX_SPOT_LIGHTS " + n.maxSpotLights, "#define MAX_HEMI_LIGHTS " + n.maxHemiLights, "#define MAX_SHADOWS " + n.maxShadows, "#define MAX_BONES " + n.maxBones, n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + f : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexColors ? "#define USE_COLOR" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals ? "#define USE_MORPHNORMALS" : "", n.wrapAround ? "#define WRAP_AROUND" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", n.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\n	attribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n	attribute vec3 morphTarget0;\n	attribute vec3 morphTarget1;\n	attribute vec3 morphTarget2;\n	attribute vec3 morphTarget3;\n	#ifdef USE_MORPHNORMALS\n		attribute vec3 morphNormal0;\n		attribute vec3 morphNormal1;\n		attribute vec3 morphNormal2;\n		attribute vec3 morphNormal3;\n	#else\n		attribute vec3 morphTarget4;\n		attribute vec3 morphTarget5;\n		attribute vec3 morphTarget6;\n		attribute vec3 morphTarget7;\n	#endif\n#endif\n#ifdef USE_SKINNING\n	attribute vec4 skinIndex;\n	attribute vec4 skinWeight;\n#endif\n"].join("\n"), t = ["precision " + n.precision + " float;", "precision " + n.precision + " int;", n.bumpMap || n.normalMap || n.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", v, "#define MAX_DIR_LIGHTS " + n.maxDirLights, "#define MAX_POINT_LIGHTS " + n.maxPointLights, "#define MAX_SPOT_LIGHTS " + n.maxSpotLights, "#define MAX_HEMI_LIGHTS " + n.maxHemiLights, "#define MAX_SHADOWS " + n.maxShadows, n.alphaTest ? "#define ALPHATEST " + n.alphaTest : "", t.gammaInput ? "#define GAMMA_INPUT" : "", t.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + E, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + f : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexColors ? "#define USE_COLOR" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.metal ? "#define METAL" : "", n.wrapAround ? "#define WRAP_AROUND" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", n.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"].join("\n")), h = new THREE.WebGLShader(o, o.VERTEX_SHADER, r + h), u = new THREE.WebGLShader(o, o.FRAGMENT_SHADER, t + u), o.attachShader(a, h), o.attachShader(a, u), void 0 !== c && o.bindAttribLocation(a, 0, c), o.linkProgram(a), c = o.getProgramInfoLog(a), !1 === o.getProgramParameter(a, o.LINK_STATUS) && THREE.error("THREE.WebGLProgram: shader error: " + o.getError(), "gl.VALIDATE_STATUS", o.getProgramParameter(a, o.VALIDATE_STATUS), "gl.getPRogramInfoLog", c), "" !== c && THREE.warn("THREE.WebGLProgram: gl.getProgramInfoLog()" + c), o.deleteShader(h), o.deleteShader(u), c = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences bindMatrix bindMatrixInverse".split(" "), n.useVertexTexture ? (c.push("boneTexture"), c.push("boneTextureWidth"), c.push("boneTextureHeight")) : c.push("boneGlobalMatrices"), n.logarithmicDepthBuffer && c.push("logDepthBufFC");
            for (var T in s) c.push(T);
            for (s = c, T = {}, c = 0, t = s.length; t > c; c++) p = s[c], T[p] = o.getUniformLocation(a, p);
            for (this.uniforms = T, c = "position normal uv uv2 tangent color skinIndex skinWeight lineDistance".split(" "), s = 0; s < n.maxMorphTargets; s++) c.push("morphTarget" + s);
            for (s = 0; s < n.maxMorphNormals; s++) c.push("morphNormal" + s);
            for (var x in l) c.push(x);
            for (n = c, l = {}, x = 0, s = n.length; s > x; x++) T = n[x], l[T] = o.getAttribLocation(a, T);
            return this.attributes = l, this.attributesKeys = Object.keys(this.attributes), this.id = e++, this.code = i, this.usedTimes = 1, this.program = a, this.vertexShader = h, this.fragmentShader = u, this
        }
    }(), THREE.WebGLShader = function() {
        var e = function(e) {
            e = e.split("\n");
            for (var t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
            return e.join("\n")
        };
        return function(t, i, r) {
            return i = t.createShader(i), t.shaderSource(i, r), t.compileShader(i), !1 === t.getShaderParameter(i, t.COMPILE_STATUS) && THREE.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(i) && THREE.warn("THREE.WebGLShader: gl.getShaderInfoLog()", t.getShaderInfoLog(i), e(r)), i
        }
    }(), THREE.WebGLState = function(e, t) {
        var i = new Uint8Array(16),
            r = new Uint8Array(16),
            n = null,
            o = null,
            a = null,
            s = null,
            l = null,
            h = null,
            u = null,
            c = null,
            p = null,
            d = null,
            f = null,
            m = null,
            E = null,
            v = null,
            g = null,
            y = null;
        this.initAttributes = function() {
            for (var e = 0, t = i.length; t > e; e++) i[e] = 0
        }, this.enableAttribute = function(t) {
            i[t] = 1, 0 === r[t] && (e.enableVertexAttribArray(t), r[t] = 1)
        }, this.disableUnusedAttributes = function() {
            for (var t = 0, n = r.length; n > t; t++) r[t] !== i[t] && (e.disableVertexAttribArray(t), r[t] = 0)
        }, this.setBlending = function(i, r, c, p, d, f, m) {
            i !== n && (i === THREE.NoBlending ? e.disable(e.BLEND) : i === THREE.AdditiveBlending ? (e.enable(e.BLEND), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.SRC_ALPHA, e.ONE)) : i === THREE.SubtractiveBlending ? (e.enable(e.BLEND), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.ONE_MINUS_SRC_COLOR)) : i === THREE.MultiplyBlending ? (e.enable(e.BLEND), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.SRC_COLOR)) : i === THREE.CustomBlending ? e.enable(e.BLEND) : (e.enable(e.BLEND), e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA)), n = i), i === THREE.CustomBlending ? (d = d || r, f = f || c, m = m || p, (r !== o || d !== l) && (e.blendEquationSeparate(t(r), t(d)), o = r, l = d), (c !== a || p !== s || f !== h || m !== u) && (e.blendFuncSeparate(t(c), t(p), t(f), t(m)), a = c, s = p, h = f, u = m)) : u = h = l = s = a = o = null
        }, this.setDepthTest = function(t) {
            c !== t && (t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), c = t)
        }, this.setDepthWrite = function(t) {
            p !== t && (e.depthMask(t), p = t)
        }, this.setColorWrite = function(t) {
            d !== t && (e.colorMask(t, t, t, t), d = t)
        }, this.setDoubleSided = function(t) {
            f !== t && (t ? e.disable(e.CULL_FACE) : e.enable(e.CULL_FACE), f = t)
        }, this.setFlipSided = function(t) {
            m !== t && (e.frontFace(t ? e.CW : e.CCW), m = t)
        }, this.setLineWidth = function(t) {
            t !== E && (e.lineWidth(t), E = t)
        }, this.setPolygonOffset = function(t, i, r) {
            v !== t && (t ? e.enable(e.POLYGON_OFFSET_FILL) : e.disable(e.POLYGON_OFFSET_FILL), v = t), !t || g === i && y === r || (e.polygonOffset(i, r), g = i, y = r)
        }, this.reset = function() {
            for (var e = 0; e < r.length; e++) r[e] = 0;
            m = f = d = p = c = n = null
        }
    }, THREE.LensFlarePlugin = function(e, t) {
        var i, r, n, o, a, s, l, h, u, c, p = e.context,
            d, f, m, E, v, g;
        this.render = function(y, T, x, _) {
            if (0 !== t.length) {
                y = new THREE.Vector3;
                var R = _ / x,
                    b = .5 * x,
                    H = .5 * _,
                    w = 16 / _,
                    M = new THREE.Vector2(w * R, w),
                    S = new THREE.Vector3(1, 1, 0),
                    C = new THREE.Vector2(1, 1);
                if (void 0 === m) {
                    var w = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                        A = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    d = p.createBuffer(), f = p.createBuffer(), p.bindBuffer(p.ARRAY_BUFFER, d), p.bufferData(p.ARRAY_BUFFER, w, p.STATIC_DRAW), p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, f), p.bufferData(p.ELEMENT_ARRAY_BUFFER, A, p.STATIC_DRAW), v = p.createTexture(), g = p.createTexture(), p.bindTexture(p.TEXTURE_2D, v), p.texImage2D(p.TEXTURE_2D, 0, p.RGB, 16, 16, 0, p.RGB, p.UNSIGNED_BYTE, null), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.NEAREST), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.NEAREST), p.bindTexture(p.TEXTURE_2D, g), p.texImage2D(p.TEXTURE_2D, 0, p.RGBA, 16, 16, 0, p.RGBA, p.UNSIGNED_BYTE, null), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.NEAREST), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.NEAREST);
                    var w = (E = 0 < p.getParameter(p.MAX_VERTEX_TEXTURE_IMAGE_UNITS)) ? {
                            vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                            fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                        } : {
                            vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                            fragmentShader: "precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                        },
                        A = p.createProgram(),
                        P = p.createShader(p.FRAGMENT_SHADER),
                        L = p.createShader(p.VERTEX_SHADER),
                        D = "precision " + e.getPrecision() + " float;\n";
                    p.shaderSource(P, D + w.fragmentShader), p.shaderSource(L, D + w.vertexShader), p.compileShader(P), p.compileShader(L), p.attachShader(A, P), p.attachShader(A, L), p.linkProgram(A), m = A, u = p.getAttribLocation(m, "position"), c = p.getAttribLocation(m, "uv"), i = p.getUniformLocation(m, "renderType"), r = p.getUniformLocation(m, "map"), n = p.getUniformLocation(m, "occlusionMap"), o = p.getUniformLocation(m, "opacity"), a = p.getUniformLocation(m, "color"), s = p.getUniformLocation(m, "scale"), l = p.getUniformLocation(m, "rotation"), h = p.getUniformLocation(m, "screenPosition")
                }
                for (p.useProgram(m), p.enableVertexAttribArray(u), p.enableVertexAttribArray(c), p.uniform1i(n, 0), p.uniform1i(r, 1), p.bindBuffer(p.ARRAY_BUFFER, d), p.vertexAttribPointer(u, 2, p.FLOAT, !1, 16, 0), p.vertexAttribPointer(c, 2, p.FLOAT, !1, 16, 8), p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, f), p.disable(p.CULL_FACE), p.depthMask(!1), A = 0, P = t.length; P > A; A++)
                    if (w = 16 / _, M.set(w * R, w), L = t[A], y.set(L.matrixWorld.elements[12], L.matrixWorld.elements[13], L.matrixWorld.elements[14]), y.applyMatrix4(T.matrixWorldInverse), y.applyProjection(T.projectionMatrix), S.copy(y), C.x = S.x * b + b, C.y = S.y * H + H, E || 0 < C.x && C.x < x && 0 < C.y && C.y < _) {
                        p.activeTexture(p.TEXTURE1), p.bindTexture(p.TEXTURE_2D, v), p.copyTexImage2D(p.TEXTURE_2D, 0, p.RGB, C.x - 8, C.y - 8, 16, 16, 0), p.uniform1i(i, 0), p.uniform2f(s, M.x, M.y), p.uniform3f(h, S.x, S.y, S.z), p.disable(p.BLEND), p.enable(p.DEPTH_TEST), p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0), p.activeTexture(p.TEXTURE0), p.bindTexture(p.TEXTURE_2D, g), p.copyTexImage2D(p.TEXTURE_2D, 0, p.RGBA, C.x - 8, C.y - 8, 16, 16, 0), p.uniform1i(i, 1), p.disable(p.DEPTH_TEST), p.activeTexture(p.TEXTURE1), p.bindTexture(p.TEXTURE_2D, v), p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0), L.positionScreen.copy(S), L.customUpdateCallback ? L.customUpdateCallback(L) : L.updateLensFlares(), p.uniform1i(i, 2), p.enable(p.BLEND);
                        for (var D = 0, O = L.lensFlares.length; O > D; D++) {
                            var F = L.lensFlares[D];
                            .001 < F.opacity && .001 < F.scale && (S.x = F.x, S.y = F.y, S.z = F.z, w = F.size * F.scale / _, M.x = w * R, M.y = w, p.uniform3f(h, S.x, S.y, S.z), p.uniform2f(s, M.x, M.y), p.uniform1f(l, F.rotation), p.uniform1f(o, F.opacity), p.uniform3f(a, F.color.r, F.color.g, F.color.b), e.state.setBlending(F.blending, F.blendEquation, F.blendSrc, F.blendDst), e.setTexture(F.texture, 1), p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0))
                        }
                    }
                p.enable(p.CULL_FACE), p.enable(p.DEPTH_TEST), p.depthMask(!0), e.resetGLState()
            }
        }
    }, THREE.ShadowMapPlugin = function(e, t, i, r) {
        function n(e, t, r) {
            if (t.visible) {
                var o = i[t.id];
                if (o && t.castShadow && (!1 === t.frustumCulled || !0 === u.intersectsObject(t)))
                    for (var a = 0, s = o.length; s > a; a++) {
                        var l = o[a];
                        t._modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, t.matrixWorld), m.push(l)
                    }
                for (a = 0, s = t.children.length; s > a; a++) n(e, t.children[a], r)
            }
        }
        var o = e.context,
            a, s, l, h, u = new THREE.Frustum,
            c = new THREE.Matrix4,
            p = new THREE.Vector3,
            d = new THREE.Vector3,
            f = new THREE.Vector3,
            m = [],
            E = THREE.ShaderLib.depthRGBA,
            v = THREE.UniformsUtils.clone(E.uniforms);
        a = new THREE.ShaderMaterial({
            uniforms: v,
            vertexShader: E.vertexShader,
            fragmentShader: E.fragmentShader
        }), s = new THREE.ShaderMaterial({
            uniforms: v,
            vertexShader: E.vertexShader,
            fragmentShader: E.fragmentShader,
            morphTargets: !0
        }), l = new THREE.ShaderMaterial({
            uniforms: v,
            vertexShader: E.vertexShader,
            fragmentShader: E.fragmentShader,
            skinning: !0
        }), h = new THREE.ShaderMaterial({
            uniforms: v,
            vertexShader: E.vertexShader,
            fragmentShader: E.fragmentShader,
            morphTargets: !0,
            skinning: !0
        }), a._shadowPass = !0, s._shadowPass = !0, l._shadowPass = !0, h._shadowPass = !0, this.render = function(i, E) {
            if (!1 !== e.shadowMapEnabled) {
                var v, g, y, T, x, _, R, b, H = [];
                for (T = 0, o.clearColor(1, 1, 1, 1), o.disable(o.BLEND), o.enable(o.CULL_FACE), o.frontFace(o.CCW), o.cullFace(e.shadowMapCullFace === THREE.CullFaceFront ? o.FRONT : o.BACK), e.state.setDepthTest(!0), v = 0, g = t.length; g > v; v++)
                    if (y = t[v], y.castShadow)
                        if (y instanceof THREE.DirectionalLight && y.shadowCascade)
                            for (x = 0; x < y.shadowCascadeCount; x++) {
                                var w;
                                if (y.shadowCascadeArray[x]) w = y.shadowCascadeArray[x];
                                else {
                                    R = y;
                                    var M = x;
                                    w = new THREE.DirectionalLight, w.isVirtual = !0, w.onlyShadow = !0, w.castShadow = !0, w.shadowCameraNear = R.shadowCameraNear, w.shadowCameraFar = R.shadowCameraFar, w.shadowCameraLeft = R.shadowCameraLeft, w.shadowCameraRight = R.shadowCameraRight, w.shadowCameraBottom = R.shadowCameraBottom, w.shadowCameraTop = R.shadowCameraTop, w.shadowCameraVisible = R.shadowCameraVisible, w.shadowDarkness = R.shadowDarkness, w.shadowBias = R.shadowCascadeBias[M], w.shadowMapWidth = R.shadowCascadeWidth[M], w.shadowMapHeight = R.shadowCascadeHeight[M], w.pointsWorld = [], w.pointsFrustum = [], b = w.pointsWorld, _ = w.pointsFrustum;
                                    for (var S = 0; 8 > S; S++) b[S] = new THREE.Vector3, _[S] = new THREE.Vector3;
                                    b = R.shadowCascadeNearZ[M], R = R.shadowCascadeFarZ[M], _[0].set(-1, -1, b), _[1].set(1, -1, b), _[2].set(-1, 1, b), _[3].set(1, 1, b), _[4].set(-1, -1, R), _[5].set(1, -1, R), _[6].set(-1, 1, R), _[7].set(1, 1, R), w.originalCamera = E, _ = new THREE.Gyroscope, _.position.copy(y.shadowCascadeOffset), _.add(w), _.add(w.target), E.add(_), y.shadowCascadeArray[x] = w
                                }
                                M = y, b = x, R = M.shadowCascadeArray[b], R.position.copy(M.position), R.target.position.copy(M.target.position), R.lookAt(R.target), R.shadowCameraVisible = M.shadowCameraVisible, R.shadowDarkness = M.shadowDarkness, R.shadowBias = M.shadowCascadeBias[b], _ = M.shadowCascadeNearZ[b], M = M.shadowCascadeFarZ[b], R = R.pointsFrustum, R[0].z = _, R[1].z = _, R[2].z = _, R[3].z = _, R[4].z = M, R[5].z = M, R[6].z = M, R[7].z = M, H[T] = w, T++
                            } else H[T] = y, T++;
                for (v = 0, g = H.length; g > v; v++) {
                    if (y = H[v], y.shadowMap || (x = THREE.LinearFilter, e.shadowMapType === THREE.PCFSoftShadowMap && (x = THREE.NearestFilter), y.shadowMap = new THREE.WebGLRenderTarget(y.shadowMapWidth, y.shadowMapHeight, {
                            minFilter: x,
                            magFilter: x,
                            format: THREE.RGBAFormat
                        }), y.shadowMapSize = new THREE.Vector2(y.shadowMapWidth, y.shadowMapHeight), y.shadowMatrix = new THREE.Matrix4), !y.shadowCamera) {
                        if (y instanceof THREE.SpotLight) y.shadowCamera = new THREE.PerspectiveCamera(y.shadowCameraFov, y.shadowMapWidth / y.shadowMapHeight, y.shadowCameraNear, y.shadowCameraFar);
                        else {
                            if (!(y instanceof THREE.DirectionalLight)) {
                                THREE.error("THREE.ShadowMapPlugin: Unsupported light type for shadow", y);
                                continue
                            }
                            y.shadowCamera = new THREE.OrthographicCamera(y.shadowCameraLeft, y.shadowCameraRight, y.shadowCameraTop, y.shadowCameraBottom, y.shadowCameraNear, y.shadowCameraFar)
                        }
                        i.add(y.shadowCamera), !0 === i.autoUpdate && i.updateMatrixWorld()
                    }
                    if (y.shadowCameraVisible && !y.cameraHelper && (y.cameraHelper = new THREE.CameraHelper(y.shadowCamera), i.add(y.cameraHelper)), y.isVirtual && w.originalCamera == E) {
                        for (x = E, T = y.shadowCamera, _ = y.pointsFrustum, R = y.pointsWorld, p.set(1 / 0, 1 / 0, 1 / 0), d.set(-1 / 0, -1 / 0, -1 / 0), M = 0; 8 > M; M++) b = R[M], b.copy(_[M]), b.unproject(x), b.applyMatrix4(T.matrixWorldInverse), b.x < p.x && (p.x = b.x), b.x > d.x && (d.x = b.x), b.y < p.y && (p.y = b.y), b.y > d.y && (d.y = b.y), b.z < p.z && (p.z = b.z), b.z > d.z && (d.z = b.z);
                        T.left = p.x, T.right = d.x, T.top = d.y, T.bottom = p.y, T.updateProjectionMatrix()
                    }
                    for (T = y.shadowMap, _ = y.shadowMatrix, x = y.shadowCamera, x.position.setFromMatrixPosition(y.matrixWorld), f.setFromMatrixPosition(y.target.matrixWorld), x.lookAt(f), x.updateMatrixWorld(), x.matrixWorldInverse.getInverse(x.matrixWorld), y.cameraHelper && (y.cameraHelper.visible = y.shadowCameraVisible), y.shadowCameraVisible && y.cameraHelper.update(), _.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), _.multiply(x.projectionMatrix), _.multiply(x.matrixWorldInverse), c.multiplyMatrices(x.projectionMatrix, x.matrixWorldInverse), u.setFromMatrix(c), e.setRenderTarget(T), e.clear(), m.length = 0, n(i, i, x), y = 0, T = m.length; T > y; y++) R = m[y], _ = R.object, R = R.buffer, M = _.material instanceof THREE.MeshFaceMaterial ? _.material.materials[0] : _.material, b = void 0 !== _.geometry.morphTargets && 0 < _.geometry.morphTargets.length && M.morphTargets, S = _ instanceof THREE.SkinnedMesh && M.skinning, b = _.customDepthMaterial ? _.customDepthMaterial : S ? b ? h : l : b ? s : a, e.setMaterialFaces(M), R instanceof THREE.BufferGeometry ? e.renderBufferDirect(x, t, null, b, R, _) : e.renderBuffer(x, t, null, b, R, _);
                    for (y = 0, T = r.length; T > y; y++) R = r[y], _ = R.object, _.visible && _.castShadow && (_._modelViewMatrix.multiplyMatrices(x.matrixWorldInverse, _.matrixWorld), e.renderImmediateObject(x, t, null, a, _))
                }
                v = e.getClearColor(), g = e.getClearAlpha(), o.clearColor(v.r, v.g, v.b, g), o.enable(o.BLEND), e.shadowMapCullFace === THREE.CullFaceFront && o.cullFace(o.BACK), e.resetGLState()
            }
        }
    }, THREE.SpritePlugin = function(e, t) {
        function i(e, t) {
            return e.z !== t.z ? t.z - e.z : t.id - e.id
        }
        var r, n, o, a, s, l, h, u, c, p, d, f, m, E, v, g, y, T = e.context,
            x, _, R, b, H = new THREE.Vector3,
            w = new THREE.Quaternion,
            M = new THREE.Vector3;
        this.render = function(S, C) {
            if (0 !== t.length) {
                if (void 0 === R) {
                    var A = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                        P = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    x = T.createBuffer(), _ = T.createBuffer(), T.bindBuffer(T.ARRAY_BUFFER, x), T.bufferData(T.ARRAY_BUFFER, A, T.STATIC_DRAW), T.bindBuffer(T.ELEMENT_ARRAY_BUFFER, _), T.bufferData(T.ELEMENT_ARRAY_BUFFER, P, T.STATIC_DRAW);
                    var A = T.createProgram(),
                        P = T.createShader(T.VERTEX_SHADER),
                        L = T.createShader(T.FRAGMENT_SHADER);
                    T.shaderSource(P, ["precision " + e.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n")), T.shaderSource(L, ["precision " + e.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n")), T.compileShader(P), T.compileShader(L), T.attachShader(A, P), T.attachShader(A, L), T.linkProgram(A), R = A, g = T.getAttribLocation(R, "position"), y = T.getAttribLocation(R, "uv"), r = T.getUniformLocation(R, "uvOffset"), n = T.getUniformLocation(R, "uvScale"), o = T.getUniformLocation(R, "rotation"), a = T.getUniformLocation(R, "scale"), s = T.getUniformLocation(R, "color"), l = T.getUniformLocation(R, "map"), h = T.getUniformLocation(R, "opacity"), u = T.getUniformLocation(R, "modelViewMatrix"), c = T.getUniformLocation(R, "projectionMatrix"), p = T.getUniformLocation(R, "fogType"), d = T.getUniformLocation(R, "fogDensity"), f = T.getUniformLocation(R, "fogNear"), m = T.getUniformLocation(R, "fogFar"), E = T.getUniformLocation(R, "fogColor"), v = T.getUniformLocation(R, "alphaTest"), A = document.createElement("canvas"), A.width = 8, A.height = 8, P = A.getContext("2d"), P.fillStyle = "white", P.fillRect(0, 0, 8, 8), b = new THREE.Texture(A), b.needsUpdate = !0
                }
                T.useProgram(R), T.enableVertexAttribArray(g), T.enableVertexAttribArray(y), T.disable(T.CULL_FACE), T.enable(T.BLEND), T.bindBuffer(T.ARRAY_BUFFER, x), T.vertexAttribPointer(g, 2, T.FLOAT, !1, 16, 0), T.vertexAttribPointer(y, 2, T.FLOAT, !1, 16, 8), T.bindBuffer(T.ELEMENT_ARRAY_BUFFER, _), T.uniformMatrix4fv(c, !1, C.projectionMatrix.elements), T.activeTexture(T.TEXTURE0), T.uniform1i(l, 0), P = A = 0, (L = S.fog) ? (T.uniform3f(E, L.color.r, L.color.g, L.color.b), L instanceof THREE.Fog ? (T.uniform1f(f, L.near), T.uniform1f(m, L.far), T.uniform1i(p, 1), P = A = 1) : L instanceof THREE.FogExp2 && (T.uniform1f(d, L.density), T.uniform1i(p, 2), P = A = 2)) : (T.uniform1i(p, 0), P = A = 0);
                for (var L = 0, D = t.length; D > L; L++) {
                    var O = t[L];
                    O._modelViewMatrix.multiplyMatrices(C.matrixWorldInverse, O.matrixWorld), O.z = -O._modelViewMatrix.elements[14]
                }
                t.sort(i);
                for (var F = [], L = 0, D = t.length; D > L; L++) {
                    var O = t[L],
                        k = O.material;
                    T.uniform1f(v, k.alphaTest), T.uniformMatrix4fv(u, !1, O._modelViewMatrix.elements), O.matrixWorld.decompose(H, w, M), F[0] = M.x, F[1] = M.y, O = 0, S.fog && k.fog && (O = P), A !== O && (T.uniform1i(p, O), A = O), null !== k.map ? (T.uniform2f(r, k.map.offset.x, k.map.offset.y), T.uniform2f(n, k.map.repeat.x, k.map.repeat.y)) : (T.uniform2f(r, 0, 0), T.uniform2f(n, 1, 1)), T.uniform1f(h, k.opacity), T.uniform3f(s, k.color.r, k.color.g, k.color.b), T.uniform1f(o, k.rotation), T.uniform2fv(a, F), e.state.setBlending(k.blending, k.blendEquation, k.blendSrc, k.blendDst), e.state.setDepthTest(k.depthTest), e.state.setDepthWrite(k.depthWrite), k.map && k.map.image && k.map.image.width ? e.setTexture(k.map, 0) : e.setTexture(b, 0), T.drawElements(T.TRIANGLES, 6, T.UNSIGNED_SHORT, 0)
                }
                T.enable(T.CULL_FACE), e.resetGLState()
            }
        }
    }, THREE.GeometryUtils = {
        merge: function(e, t, i) {
            THREE.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
            var r;
            t instanceof THREE.Mesh && (t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, t = t.geometry), e.merge(t, r, i)
        },
        center: function(e) {
            return THREE.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
        }
    }, THREE.ImageUtils = {
        crossOrigin: void 0,
        loadTexture: function(e, t, i, r) {
            var n = new THREE.ImageLoader;
            n.crossOrigin = this.crossOrigin;
            var o = new THREE.Texture(void 0, t);
            return n.load(e, function(e) {
                o.image = e, o.needsUpdate = !0, i && i(o)
            }, void 0, function(e) {
                r && r(e)
            }), o.sourceFile = e, o
        },
        loadTextureCube: function(e, t, i, r) {
            var n = new THREE.ImageLoader;
            n.crossOrigin = this.crossOrigin;
            var o = new THREE.CubeTexture([], t);
            o.flipY = !1;
            var a = 0;
            t = function(t) {
                n.load(e[t], function(e) {
                    o.images[t] = e, a += 1, 6 === a && (o.needsUpdate = !0, i && i(o))
                }, void 0, r)
            };
            for (var s = 0, l = e.length; l > s; ++s) t(s);
            return o
        },
        loadCompressedTexture: function() {
            THREE.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        },
        loadCompressedTextureCube: function() {
            THREE.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        },
        getNormalMap: function(e, t) {
            var i = function(e) {
                var t = Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
                return [e[0] / t, e[1] / t, e[2] / t]
            };
            t |= 1;
            var r = e.width,
                n = e.height,
                o = document.createElement("canvas");
            o.width = r, o.height = n;
            var a = o.getContext("2d");
            a.drawImage(e, 0, 0);
            for (var s = a.getImageData(0, 0, r, n).data, l = a.createImageData(r, n), h = l.data, u = 0; r > u; u++)
                for (var c = 0; n > c; c++) {
                    var p = 0 > c - 1 ? 0 : c - 1,
                        d = c + 1 > n - 1 ? n - 1 : c + 1,
                        f = 0 > u - 1 ? 0 : u - 1,
                        m = u + 1 > r - 1 ? r - 1 : u + 1,
                        E = [],
                        v = [0, 0, s[4 * (c * r + u)] / 255 * t];
                    for (E.push([-1, 0, s[4 * (c * r + f)] / 255 * t]), E.push([-1, -1, s[4 * (p * r + f)] / 255 * t]), E.push([0, -1, s[4 * (p * r + u)] / 255 * t]), E.push([1, -1, s[4 * (p * r + m)] / 255 * t]), E.push([1, 0, s[4 * (c * r + m)] / 255 * t]), E.push([1, 1, s[4 * (d * r + m)] / 255 * t]), E.push([0, 1, s[4 * (d * r + u)] / 255 * t]), E.push([-1, 1, s[4 * (d * r + f)] / 255 * t]), p = [], f = E.length, d = 0; f > d; d++) {
                        var m = E[d],
                            g = E[(d + 1) % f],
                            m = [m[0] - v[0], m[1] - v[1], m[2] - v[2]],
                            g = [g[0] - v[0], g[1] - v[1], g[2] - v[2]];
                        p.push(i([m[1] * g[2] - m[2] * g[1], m[2] * g[0] - m[0] * g[2], m[0] * g[1] - m[1] * g[0]]))
                    }
                    for (E = [0, 0, 0], d = 0; d < p.length; d++) E[0] += p[d][0], E[1] += p[d][1], E[2] += p[d][2];
                    E[0] /= p.length, E[1] /= p.length, E[2] /= p.length, v = 4 * (c * r + u), h[v] = (E[0] + 1) / 2 * 255 | 0, h[v + 1] = (E[1] + 1) / 2 * 255 | 0, h[v + 2] = 255 * E[2] | 0, h[v + 3] = 255
                }
            return a.putImageData(l, 0, 0), o
        },
        generateDataTexture: function(e, t, i) {
            var r = e * t,
                n = new Uint8Array(3 * r),
                o = Math.floor(255 * i.r),
                a = Math.floor(255 * i.g);
            i = Math.floor(255 * i.b);
            for (var s = 0; r > s; s++) n[3 * s] = o, n[3 * s + 1] = a, n[3 * s + 2] = i;
            return e = new THREE.DataTexture(n, e, t, THREE.RGBFormat), e.needsUpdate = !0, e
        }
    }, THREE.SceneUtils = {
        createMultiMaterialObject: function(e, t) {
            for (var i = new THREE.Object3D, r = 0, n = t.length; n > r; r++) i.add(new THREE.Mesh(e, t[r]));
            return i
        },
        detach: function(e, t, i) {
            e.applyMatrix(t.matrixWorld), t.remove(e), i.add(e)
        },
        attach: function(e, t, i) {
            var r = new THREE.Matrix4;
            r.getInverse(i.matrixWorld), e.applyMatrix(r), t.remove(e), i.add(e)
        }
    }, THREE.FontUtils = {
        faces: {},
        face: "helvetiker",
        weight: "normal",
        style: "normal",
        size: 150,
        divisions: 10,
        getFace: function() {
            try {
                return this.faces[this.face][this.weight][this.style]
            } catch (e) {
                throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."
            }
        },
        loadFace: function(e) {
            var t = e.familyName.toLowerCase();
            return this.faces[t] = this.faces[t] || {}, this.faces[t][e.cssFontWeight] = this.faces[t][e.cssFontWeight] || {}, this.faces[t][e.cssFontWeight][e.cssFontStyle] = e, this.faces[t][e.cssFontWeight][e.cssFontStyle] = e
        },
        drawText: function(e) {
            var t = this.getFace(),
                i = this.size / t.resolution,
                r = 0,
                n = String(e).split(""),
                o = n.length,
                a = [];
            for (e = 0; o > e; e++) {
                var s = new THREE.Path,
                    s = this.extractGlyphPoints(n[e], t, i, r, s),
                    r = r + s.offset;
                a.push(s.path)
            }
            return {
                paths: a,
                offset: r / 2
            }
        },
        extractGlyphPoints: function(e, t, i, r, n) {
            var o = [],
                a, s, l, h, u, c, p, d, f, m, E, v = t.glyphs[e] || t.glyphs["?"];
            if (v) {
                if (v.o)
                    for (t = v._cachedOutline || (v._cachedOutline = v.o.split(" ")), h = t.length, e = 0; h > e;) switch (l = t[e++]) {
                        case "m":
                            l = t[e++] * i + r, u = t[e++] * i, n.moveTo(l, u);
                            break;
                        case "l":
                            l = t[e++] * i + r, u = t[e++] * i, n.lineTo(l, u);
                            break;
                        case "q":
                            if (l = t[e++] * i + r, u = t[e++] * i, d = t[e++] * i + r, f = t[e++] * i, n.quadraticCurveTo(d, f, l, u), a = o[o.length - 1])
                                for (c = a.x, p = a.y, a = 1, s = this.divisions; s >= a; a++) {
                                    var g = a / s;
                                    THREE.Shape.Utils.b2(g, c, d, l), THREE.Shape.Utils.b2(g, p, f, u)
                                }
                            break;
                        case "b":
                            if (l = t[e++] * i + r, u = t[e++] * i, d = t[e++] * i + r, f = t[e++] * i, m = t[e++] * i + r, E = t[e++] * i, n.bezierCurveTo(d, f, m, E, l, u), a = o[o.length - 1])
                                for (c = a.x, p = a.y, a = 1, s = this.divisions; s >= a; a++) g = a / s, THREE.Shape.Utils.b3(g, c, d, m, l), THREE.Shape.Utils.b3(g, p, f, E, u)
                    }
                return {
                    offset: v.ha * i,
                    path: n
                }
            }
        }
    }, THREE.FontUtils.generateShapes = function(e, t) {
        t = t || {};
        var i = void 0 !== t.curveSegments ? t.curveSegments : 4,
            r = void 0 !== t.font ? t.font : "helvetiker",
            n = void 0 !== t.weight ? t.weight : "normal",
            o = void 0 !== t.style ? t.style : "normal";
        for (THREE.FontUtils.size = void 0 !== t.size ? t.size : 100, THREE.FontUtils.divisions = i, THREE.FontUtils.face = r, THREE.FontUtils.weight = n, THREE.FontUtils.style = o, i = THREE.FontUtils.drawText(e).paths, r = [], n = 0, o = i.length; o > n; n++) Array.prototype.push.apply(r, i[n].toShapes());
        return r
    },
    function(e) {
        var t = function(e) {
            for (var t = e.length, i = 0, r = t - 1, n = 0; t > n; r = n++) i += e[r].x * e[n].y - e[n].x * e[r].y;
            return .5 * i
        };
        return e.Triangulate = function(e, i) {
            var r = e.length;
            if (3 > r) return null;
            var n = [],
                o = [],
                a = [],
                s, l, h;
            if (0 < t(e))
                for (l = 0; r > l; l++) o[l] = l;
            else
                for (l = 0; r > l; l++) o[l] = r - 1 - l;
            var u = 2 * r;
            for (l = r - 1; r > 2;) {
                if (0 >= u--) {
                    THREE.warn("THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()");
                    break
                }
                s = l, s >= r && (s = 0), l = s + 1, l >= r && (l = 0), h = l + 1, h >= r && (h = 0);
                var c;
                e: {
                    var p = c = void 0,
                        d = void 0,
                        f = void 0,
                        m = void 0,
                        E = void 0,
                        v = void 0,
                        g = void 0,
                        y = void 0,
                        p = e[o[s]].x,
                        d = e[o[s]].y,
                        f = e[o[l]].x,
                        m = e[o[l]].y,
                        E = e[o[h]].x,
                        v = e[o[h]].y;
                    if (1e-10 > (f - p) * (v - d) - (m - d) * (E - p)) c = !1;
                    else {
                        var T = void 0,
                            x = void 0,
                            _ = void 0,
                            R = void 0,
                            b = void 0,
                            H = void 0,
                            w = void 0,
                            M = void 0,
                            S = void 0,
                            C = void 0,
                            S = M = w = y = g = void 0,
                            T = E - f,
                            x = v - m,
                            _ = p - E,
                            R = d - v,
                            b = f - p,
                            H = m - d;
                        for (c = 0; r > c; c++)
                            if (g = e[o[c]].x, y = e[o[c]].y, !(g === p && y === d || g === f && y === m || g === E && y === v) && (w = g - p, M = y - d, S = g - f, C = y - m, g -= E, y -= v, S = T * C - x * S, w = b * M - H * w, M = _ * y - R * g, S >= -1e-10 && M >= -1e-10 && w >= -1e-10)) {
                                c = !1;
                                break e
                            }
                        c = !0
                    }
                }
                if (c) {
                    for (n.push([e[o[s]], e[o[l]], e[o[h]]]), a.push([o[s], o[l], o[h]]), s = l, h = l + 1; r > h; s++, h++) o[s] = o[h];
                    r--, u = 2 * r
                }
            }
            return i ? a : n
        }, e.Triangulate.area = t, e
    }(THREE.FontUtils), self._typeface_js = {
        faces: THREE.FontUtils.faces,
        loadFace: THREE.FontUtils.loadFace
    }, THREE.typeface_js = self._typeface_js, THREE.Audio = function(e) {
        THREE.Object3D.call(this), this.type = "Audio", this.context = e.context, this.source = this.context.createBufferSource(), this.source.onended = this.onEnded.bind(this), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.panner = this.context.createPanner(), this.panner.connect(this.gain), this.autoplay = !1, this.startTime = 0, this.isPlaying = !1
    }, THREE.Audio.prototype = Object.create(THREE.Object3D.prototype), THREE.Audio.prototype.constructor = THREE.Audio, THREE.Audio.prototype.load = function(e) {
        var t = this,
            i = new XMLHttpRequest;
        return i.open("GET", e, !0), i.responseType = "arraybuffer", i.onload = function(e) {
            t.context.decodeAudioData(this.response, function(e) {
                t.source.buffer = e, t.autoplay && t.play()
            })
        }, i.send(), this
    }, THREE.Audio.prototype.play = function() {
        if (!0 === this.isPlaying) THREE.warn("THREE.Audio: Audio is already playing.");
        else {
            var e = this.context.createBufferSource();
            e.buffer = this.source.buffer, e.loop = this.source.loop, e.onended = this.source.onended, e.connect(this.panner), e.start(0, this.startTime), this.isPlaying = !0, this.source = e
        }
    }, THREE.Audio.prototype.pause = function() {
        this.source.stop(), this.startTime = this.context.currentTime
    }, THREE.Audio.prototype.stop = function() {
        this.source.stop(), this.startTime = 0
    }, THREE.Audio.prototype.onEnded = function() {
        this.isPlaying = !1
    }, THREE.Audio.prototype.setLoop = function(e) {
        this.source.loop = e
    }, THREE.Audio.prototype.setRefDistance = function(e) {
        this.panner.refDistance = e
    }, THREE.Audio.prototype.setRolloffFactor = function(e) {
        this.panner.rolloffFactor = e
    }, THREE.Audio.prototype.setVolume = function(e) {
        this.gain.gain.value = e
    }, THREE.Audio.prototype.updateMatrixWorld = function() {
        var e = new THREE.Vector3;
        return function(t) {
            THREE.Object3D.prototype.updateMatrixWorld.call(this, t), e.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(e.x, e.y, e.z)
        }
    }(), THREE.AudioListener = function() {
        THREE.Object3D.call(this), this.type = "AudioListener", this.context = new(window.AudioContext || window.webkitAudioContext)
    }, THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype), THREE.AudioListener.prototype.constructor = THREE.AudioListener, THREE.AudioListener.prototype.updateMatrixWorld = function() {
        var e = new THREE.Vector3,
            t = new THREE.Quaternion,
            i = new THREE.Vector3,
            r = new THREE.Vector3,
            n = new THREE.Vector3,
            o = new THREE.Vector3;
        return function(a) {
            THREE.Object3D.prototype.updateMatrixWorld.call(this, a), a = this.context.listener;
            var s = this.up;
            this.matrixWorld.decompose(e, t, i), r.set(0, 0, -1).applyQuaternion(t), n.subVectors(e, o), a.setPosition(e.x, e.y, e.z), a.setOrientation(r.x, r.y, r.z, s.x, s.y, s.z), a.setVelocity(n.x, n.y, n.z), o.copy(e)
        }
    }(), THREE.Curve = function() {}, THREE.Curve.prototype.getPoint = function(e) {
        return THREE.warn("THREE.Curve: Warning, getPoint() not implemented!"), null
    }, THREE.Curve.prototype.getPointAt = function(e) {
        return e = this.getUtoTmapping(e), this.getPoint(e)
    }, THREE.Curve.prototype.getPoints = function(e) {
        e || (e = 5);
        var t, i = [];
        for (t = 0; e >= t; t++) i.push(this.getPoint(t / e));
        return i
    }, THREE.Curve.prototype.getSpacedPoints = function(e) {
        e || (e = 5);
        var t, i = [];
        for (t = 0; e >= t; t++) i.push(this.getPointAt(t / e));
        return i
    }, THREE.Curve.prototype.getLength = function() {
        var e = this.getLengths();
        return e[e.length - 1]
    }, THREE.Curve.prototype.getLengths = function(e) {
        if (e || (e = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length == e + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        var t = [],
            i, r = this.getPoint(0),
            n, o = 0;
        for (t.push(0), n = 1; e >= n; n++) i = this.getPoint(n / e), o += i.distanceTo(r), t.push(o), r = i;
        return this.cacheArcLengths = t
    }, THREE.Curve.prototype.updateArcLengths = function() {
        this.needsUpdate = !0, this.getLengths()
    }, THREE.Curve.prototype.getUtoTmapping = function(e, t) {
        var i = this.getLengths(),
            r = 0,
            n = i.length,
            o;
        o = t ? t : e * i[n - 1];
        for (var a = 0, s = n - 1, l; s >= a;)
            if (r = Math.floor(a + (s - a) / 2), l = i[r] - o, 0 > l) a = r + 1;
            else {
                if (!(l > 0)) {
                    s = r;
                    break
                }
                s = r - 1
            }
        return r = s, i[r] == o ? r / (n - 1) : (a = i[r], i = (r + (o - a) / (i[r + 1] - a)) / (n - 1))
    }, THREE.Curve.prototype.getTangent = function(e) {
        var t = e - 1e-4;
        return e += 1e-4, 0 > t && (t = 0), e > 1 && (e = 1), t = this.getPoint(t), this.getPoint(e).clone().sub(t).normalize()
    }, THREE.Curve.prototype.getTangentAt = function(e) {
        return e = this.getUtoTmapping(e), this.getTangent(e)
    }, THREE.Curve.Utils = {
        tangentQuadraticBezier: function(e, t, i, r) {
            return 2 * (1 - e) * (i - t) + 2 * e * (r - i)
        },
        tangentCubicBezier: function(e, t, i, r, n) {
            return -3 * t * (1 - e) * (1 - e) + 3 * i * (1 - e) * (1 - e) - 6 * e * i * (1 - e) + 6 * e * r * (1 - e) - 3 * e * e * r + 3 * e * e * n
        },
        tangentSpline: function(e, t, i, r, n) {
            return 6 * e * e - 6 * e + (3 * e * e - 4 * e + 1) + (-6 * e * e + 6 * e) + (3 * e * e - 2 * e)
        },
        interpolate: function(e, t, i, r, n) {
            e = .5 * (i - e), r = .5 * (r - t);
            var o = n * n;
            return (2 * t - 2 * i + e + r) * n * o + (-3 * t + 3 * i - 2 * e - r) * o + e * n + t
        }
    }, THREE.Curve.create = function(e, t) {
        return e.prototype = Object.create(THREE.Curve.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
    }, THREE.CurvePath = function() {
        this.curves = [], this.bends = [], this.autoClose = !1
    }, THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype), THREE.CurvePath.prototype.constructor = THREE.CurvePath, THREE.CurvePath.prototype.add = function(e) {
        this.curves.push(e)
    }, THREE.CurvePath.prototype.checkConnection = function() {}, THREE.CurvePath.prototype.closePath = function() {
        var e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new THREE.LineCurve(t, e))
    }, THREE.CurvePath.prototype.getPoint = function(e) {
        var t = e * this.getLength(),
            i = this.getCurveLengths();
        for (e = 0; e < i.length;) {
            if (i[e] >= t) return t = i[e] - t, e = this.curves[e], t = 1 - t / e.getLength(), e.getPointAt(t);
            e++
        }
        return null
    }, THREE.CurvePath.prototype.getLength = function() {
        var e = this.getCurveLengths();
        return e[e.length - 1]
    }, THREE.CurvePath.prototype.getCurveLengths = function() {
        if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;
        var e = [],
            t = 0,
            i, r = this.curves.length;
        for (i = 0; r > i; i++) t += this.curves[i].getLength(), e.push(t);
        return this.cacheLengths = e
    }, THREE.CurvePath.prototype.getBoundingBox = function() {
        var e = this.getPoints(),
            t, i, r, n, o, a;
        t = i = Number.NEGATIVE_INFINITY, n = o = Number.POSITIVE_INFINITY;
        var s, l, h, u, c = e[0] instanceof THREE.Vector3;
        for (u = c ? new THREE.Vector3 : new THREE.Vector2, l = 0, h = e.length; h > l; l++) s = e[l], s.x > t ? t = s.x : s.x < n && (n = s.x), s.y > i ? i = s.y : s.y < o && (o = s.y), c && (s.z > r ? r = s.z : s.z < a && (a = s.z)), u.add(s);
        return e = {
            minX: n,
            minY: o,
            maxX: t,
            maxY: i
        }, c && (e.maxZ = r, e.minZ = a), e
    }, THREE.CurvePath.prototype.createPointsGeometry = function(e) {
        return e = this.getPoints(e, !0), this.createGeometry(e)
    }, THREE.CurvePath.prototype.createSpacedPointsGeometry = function(e) {
        return e = this.getSpacedPoints(e, !0), this.createGeometry(e)
    }, THREE.CurvePath.prototype.createGeometry = function(e) {
        for (var t = new THREE.Geometry, i = 0; i < e.length; i++) t.vertices.push(new THREE.Vector3(e[i].x, e[i].y, e[i].z || 0));
        return t
    }, THREE.CurvePath.prototype.addWrapPath = function(e) {
        this.bends.push(e)
    }, THREE.CurvePath.prototype.getTransformedPoints = function(e, t) {
        var i = this.getPoints(e),
            r, n;
        for (t || (t = this.bends), r = 0, n = t.length; n > r; r++) i = this.getWrapPoints(i, t[r]);
        return i
    }, THREE.CurvePath.prototype.getTransformedSpacedPoints = function(e, t) {
        var i = this.getSpacedPoints(e),
            r, n;
        for (t || (t = this.bends), r = 0, n = t.length; n > r; r++) i = this.getWrapPoints(i, t[r]);
        return i
    }, THREE.CurvePath.prototype.getWrapPoints = function(e, t) {
        var i = this.getBoundingBox(),
            r, n, o, a, s, l;
        for (r = 0, n = e.length; n > r; r++) o = e[r], a = o.x, s = o.y, l = a / i.maxX, l = t.getUtoTmapping(l, a), a = t.getPoint(l), l = t.getTangent(l), l.set(-l.y, l.x).multiplyScalar(s), o.x = a.x + l.x, o.y = a.y + l.y;
        return e
    }, THREE.Gyroscope = function() {
        THREE.Object3D.call(this)
    }, THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype), THREE.Gyroscope.prototype.constructor = THREE.Gyroscope, THREE.Gyroscope.prototype.updateMatrixWorld = function() {
        var e = new THREE.Vector3,
            t = new THREE.Quaternion,
            i = new THREE.Vector3,
            r = new THREE.Vector3,
            n = new THREE.Quaternion,
            o = new THREE.Vector3;
        return function(a) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || a) && (this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(r, n, o), this.matrix.decompose(e, t, i), this.matrixWorld.compose(r, t, o)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0);
            for (var s = 0, l = this.children.length; l > s; s++) this.children[s].updateMatrixWorld(a)
        }
    }(), THREE.Path = function(e) {
        THREE.CurvePath.call(this), this.actions = [], e && this.fromPoints(e)
    }, THREE.Path.prototype = Object.create(THREE.CurvePath.prototype), THREE.Path.prototype.constructor = THREE.Path, THREE.PathActions = {
        MOVE_TO: "moveTo",
        LINE_TO: "lineTo",
        QUADRATIC_CURVE_TO: "quadraticCurveTo",
        BEZIER_CURVE_TO: "bezierCurveTo",
        CSPLINE_THRU: "splineThru",
        ARC: "arc",
        ELLIPSE: "ellipse"
    }, THREE.Path.prototype.fromPoints = function(e) {
        this.moveTo(e[0].x, e[0].y);
        for (var t = 1, i = e.length; i > t; t++) this.lineTo(e[t].x, e[t].y)
    }, THREE.Path.prototype.moveTo = function(e, t) {
        var i = Array.prototype.slice.call(arguments);
        this.actions.push({
            action: THREE.PathActions.MOVE_TO,
            args: i
        })
    }, THREE.Path.prototype.lineTo = function(e, t) {
        var i = Array.prototype.slice.call(arguments),
            r = this.actions[this.actions.length - 1].args,
            r = new THREE.LineCurve(new THREE.Vector2(r[r.length - 2], r[r.length - 1]), new THREE.Vector2(e, t));
        this.curves.push(r), this.actions.push({
            action: THREE.PathActions.LINE_TO,
            args: i
        })
    }, THREE.Path.prototype.quadraticCurveTo = function(e, t, i, r) {
        var n = Array.prototype.slice.call(arguments),
            o = this.actions[this.actions.length - 1].args,
            o = new THREE.QuadraticBezierCurve(new THREE.Vector2(o[o.length - 2], o[o.length - 1]), new THREE.Vector2(e, t), new THREE.Vector2(i, r));
        this.curves.push(o), this.actions.push({
            action: THREE.PathActions.QUADRATIC_CURVE_TO,
            args: n
        })
    }, THREE.Path.prototype.bezierCurveTo = function(e, t, i, r, n, o) {
        var a = Array.prototype.slice.call(arguments),
            s = this.actions[this.actions.length - 1].args,
            s = new THREE.CubicBezierCurve(new THREE.Vector2(s[s.length - 2], s[s.length - 1]), new THREE.Vector2(e, t), new THREE.Vector2(i, r), new THREE.Vector2(n, o));
        this.curves.push(s), this.actions.push({
            action: THREE.PathActions.BEZIER_CURVE_TO,
            args: a
        })
    }, THREE.Path.prototype.splineThru = function(e) {
        var t = Array.prototype.slice.call(arguments),
            i = this.actions[this.actions.length - 1].args,
            i = [new THREE.Vector2(i[i.length - 2], i[i.length - 1])];
        Array.prototype.push.apply(i, e), i = new THREE.SplineCurve(i), this.curves.push(i), this.actions.push({
            action: THREE.PathActions.CSPLINE_THRU,
            args: t
        })
    }, THREE.Path.prototype.arc = function(e, t, i, r, n, o) {
        var a = this.actions[this.actions.length - 1].args;
        this.absarc(e + a[a.length - 2], t + a[a.length - 1], i, r, n, o)
    }, THREE.Path.prototype.absarc = function(e, t, i, r, n, o) {
        this.absellipse(e, t, i, i, r, n, o)
    }, THREE.Path.prototype.ellipse = function(e, t, i, r, n, o, a) {
        var s = this.actions[this.actions.length - 1].args;
        this.absellipse(e + s[s.length - 2], t + s[s.length - 1], i, r, n, o, a)
    }, THREE.Path.prototype.absellipse = function(e, t, i, r, n, o, a) {
        var s = Array.prototype.slice.call(arguments),
            l = new THREE.EllipseCurve(e, t, i, r, n, o, a);
        this.curves.push(l), l = l.getPoint(1), s.push(l.x), s.push(l.y), this.actions.push({
            action: THREE.PathActions.ELLIPSE,
            args: s
        })
    }, THREE.Path.prototype.getSpacedPoints = function(e, t) {
        e || (e = 40);
        for (var i = [], r = 0; e > r; r++) i.push(this.getPoint(r / e));
        return i
    }, THREE.Path.prototype.getPoints = function(e, t) {
        if (this.useSpacedPoints) return console.log("tata"), this.getSpacedPoints(e, t);
        e = e || 12;
        var i = [],
            r, n, o, a, s, l, h, u, c, p, d, f, m;
        for (r = 0, n = this.actions.length; n > r; r++) switch (o = this.actions[r], a = o.action, o = o.args, a) {
            case THREE.PathActions.MOVE_TO:
                i.push(new THREE.Vector2(o[0], o[1]));
                break;
            case THREE.PathActions.LINE_TO:
                i.push(new THREE.Vector2(o[0], o[1]));
                break;
            case THREE.PathActions.QUADRATIC_CURVE_TO:
                for (s = o[2], l = o[3], c = o[0], p = o[1], 0 < i.length ? (a = i[i.length - 1], d = a.x, f = a.y) : (a = this.actions[r - 1].args, d = a[a.length - 2], f = a[a.length - 1]), o = 1; e >= o; o++) m = o / e, a = THREE.Shape.Utils.b2(m, d, c, s), m = THREE.Shape.Utils.b2(m, f, p, l), i.push(new THREE.Vector2(a, m));
                break;
            case THREE.PathActions.BEZIER_CURVE_TO:
                for (s = o[4], l = o[5], c = o[0], p = o[1], h = o[2], u = o[3], 0 < i.length ? (a = i[i.length - 1], d = a.x, f = a.y) : (a = this.actions[r - 1].args, d = a[a.length - 2], f = a[a.length - 1]), o = 1; e >= o; o++) m = o / e, a = THREE.Shape.Utils.b3(m, d, c, h, s), m = THREE.Shape.Utils.b3(m, f, p, u, l), i.push(new THREE.Vector2(a, m));
                break;
            case THREE.PathActions.CSPLINE_THRU:
                for (a = this.actions[r - 1].args, m = [new THREE.Vector2(a[a.length - 2], a[a.length - 1])], a = e * o[0].length, m = m.concat(o[0]), m = new THREE.SplineCurve(m), o = 1; a >= o; o++) i.push(m.getPointAt(o / a));
                break;
            case THREE.PathActions.ARC:
                for (s = o[0], l = o[1], p = o[2], h = o[3], a = o[4], c = !!o[5], d = a - h, f = 2 * e, o = 1; f >= o; o++) m = o / f, c || (m = 1 - m), m = h + m * d, a = s + p * Math.cos(m), m = l + p * Math.sin(m), i.push(new THREE.Vector2(a, m));
                break;
            case THREE.PathActions.ELLIPSE:
                for (s = o[0], l = o[1], p = o[2], u = o[3], h = o[4], a = o[5], c = !!o[6], d = a - h, f = 2 * e, o = 1; f >= o; o++) m = o / f, c || (m = 1 - m), m = h + m * d, a = s + p * Math.cos(m), m = l + u * Math.sin(m), i.push(new THREE.Vector2(a, m))
        }
        return r = i[i.length - 1], 1e-10 > Math.abs(r.x - i[0].x) && 1e-10 > Math.abs(r.y - i[0].y) && i.splice(i.length - 1, 1), t && i.push(i[0]), i
    }, THREE.Path.prototype.toShapes = function(e, t) {
        function i(e) {
            for (var t = [], i = 0, r = e.length; r > i; i++) {
                var n = e[i],
                    o = new THREE.Shape;
                o.actions = n.actions, o.curves = n.curves, t.push(o)
            }
            return t
        }

        function r(e, t) {
            for (var i = t.length, r = !1, n = i - 1, o = 0; i > o; n = o++) {
                var a = t[n],
                    s = t[o],
                    l = s.x - a.x,
                    h = s.y - a.y;
                if (1e-10 < Math.abs(h)) {
                    if (0 > h && (a = t[o], l = -l, s = t[n], h = -h), !(e.y < a.y || e.y > s.y))
                        if (e.y == a.y) {
                            if (e.x == a.x) return !0
                        } else {
                            if (n = h * (e.x - a.x) - l * (e.y - a.y), 0 == n) return !0;
                            0 > n || (r = !r)
                        }
                } else if (e.y == a.y && (s.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= s.x)) return !0
            }
            return r
        }
        var n = function(e) {
            var t, i, r, n, o = [],
                a = new THREE.Path;
            for (t = 0, i = e.length; i > t; t++) r = e[t], n = r.args, r = r.action, r == THREE.PathActions.MOVE_TO && 0 != a.actions.length && (o.push(a), a = new THREE.Path), a[r].apply(a, n);
            return 0 != a.actions.length && o.push(a), o
        }(this.actions);
        if (0 == n.length) return [];
        if (!0 === t) return i(n);
        var o, a, s, l = [];
        if (1 == n.length) return a = n[0], s = new THREE.Shape, s.actions = a.actions, s.curves = a.curves, l.push(s), l;
        var h = !THREE.Shape.Utils.isClockWise(n[0].getPoints()),
            h = e ? !h : h;
        s = [];
        var u = [],
            c = [],
            p = 0,
            d;
        u[p] = void 0, c[p] = [];
        var f, m;
        for (f = 0, m = n.length; m > f; f++) a = n[f], d = a.getPoints(), o = THREE.Shape.Utils.isClockWise(d), (o = e ? !o : o) ? (!h && u[p] && p++, u[p] = {
            s: new THREE.Shape,
            p: d
        }, u[p].s.actions = a.actions, u[p].s.curves = a.curves, h && p++, c[p] = []) : c[p].push({
            h: a,
            p: d[0]
        });
        if (!u[0]) return i(n);
        if (1 < u.length) {
            for (f = !1, m = [], a = 0, n = u.length; n > a; a++) s[a] = [];
            for (a = 0, n = u.length; n > a; a++)
                for (o = c[a], h = 0; h < o.length; h++) {
                    p = o[h], d = !0;
                    for (var E = 0; E < u.length; E++) r(p.p, u[E].p) && (a != E && m.push({
                        froms: a,
                        tos: E,
                        hole: h
                    }), d ? (d = !1, s[E].push(p)) : f = !0);
                    d && s[a].push(p)
                }
            0 < m.length && (f || (c = s))
        }
        for (f = 0, m = u.length; m > f; f++)
            for (s = u[f].s, l.push(s), a = c[f], n = 0, o = a.length; o > n; n++) s.holes.push(a[n].h);
        return l
    }, THREE.Shape = function() {
        THREE.Path.apply(this, arguments), this.holes = []
    }, THREE.Shape.prototype = Object.create(THREE.Path.prototype), THREE.Shape.prototype.constructor = THREE.Shape, THREE.Shape.prototype.extrude = function(e) {
        return new THREE.ExtrudeGeometry(this, e)
    }, THREE.Shape.prototype.makeGeometry = function(e) {
        return new THREE.ShapeGeometry(this, e)
    }, THREE.Shape.prototype.getPointsHoles = function(e) {
        var t, i = this.holes.length,
            r = [];
        for (t = 0; i > t; t++) r[t] = this.holes[t].getTransformedPoints(e, this.bends);
        return r
    }, THREE.Shape.prototype.getSpacedPointsHoles = function(e) {
        var t, i = this.holes.length,
            r = [];
        for (t = 0; i > t; t++) r[t] = this.holes[t].getTransformedSpacedPoints(e, this.bends);
        return r
    }, THREE.Shape.prototype.extractAllPoints = function(e) {
        return {
            shape: this.getTransformedPoints(e),
            holes: this.getPointsHoles(e)
        }
    }, THREE.Shape.prototype.extractPoints = function(e) {
        return this.useSpacedPoints ? this.extractAllSpacedPoints(e) : this.extractAllPoints(e)
    }, THREE.Shape.prototype.extractAllSpacedPoints = function(e) {
        return {
            shape: this.getTransformedSpacedPoints(e),
            holes: this.getSpacedPointsHoles(e)
        }
    }, THREE.Shape.Utils = {
        triangulateShape: function(e, t) {
            function i(e, t, i) {
                return e.x != t.x ? e.x < t.x ? e.x <= i.x && i.x <= t.x : t.x <= i.x && i.x <= e.x : e.y < t.y ? e.y <= i.y && i.y <= t.y : t.y <= i.y && i.y <= e.y
            }

            function r(e, t, r, n, o) {
                var a = t.x - e.x,
                    s = t.y - e.y,
                    l = n.x - r.x,
                    h = n.y - r.y,
                    u = e.x - r.x,
                    c = e.y - r.y,
                    p = s * l - a * h,
                    d = s * u - a * c;
                if (1e-10 < Math.abs(p)) {
                    if (p > 0) {
                        if (0 > d || d > p) return [];
                        if (l = h * u - l * c, 0 > l || l > p) return []
                    } else {
                        if (d > 0 || p > d) return [];
                        if (l = h * u - l * c, l > 0 || p > l) return []
                    }
                    return 0 == l ? !o || 0 != d && d != p ? [e] : [] : l == p ? !o || 0 != d && d != p ? [t] : [] : 0 == d ? [r] : d == p ? [n] : (o = l / p, [{
                        x: e.x + o * a,
                        y: e.y + o * s
                    }])
                }
                return 0 != d || h * u != l * c ? [] : (s = 0 == a && 0 == s, l = 0 == l && 0 == h, s && l ? e.x != r.x || e.y != r.y ? [] : [e] : s ? i(r, n, e) ? [e] : [] : l ? i(e, t, r) ? [r] : [] : (0 != a ? (e.x < t.x ? (a = e, l = e.x, s = t, e = t.x) : (a = t, l = t.x, s = e, e = e.x), r.x < n.x ? (t = r, p = r.x, h = n, r = n.x) : (t = n, p = n.x, h = r, r = r.x)) : (e.y < t.y ? (a = e, l = e.y, s = t, e = t.y) : (a = t, l = t.y, s = e, e = e.y), r.y < n.y ? (t = r, p = r.y, h = n, r = n.y) : (t = n, p = n.y, h = r, r = r.y)), p >= l ? p > e ? [] : e == p ? o ? [] : [t] : r >= e ? [t, s] : [t, h] : l > r ? [] : l == r ? o ? [] : [a] : r >= e ? [a, s] : [a, h]))
            }

            function n(e, t, i, r) {
                var n = t.x - e.x,
                    o = t.y - e.y;
                t = i.x - e.x, i = i.y - e.y;
                var a = r.x - e.x;
                return r = r.y - e.y, e = n * i - o * t, n = n * r - o * a, 1e-10 < Math.abs(e) ? (t = a * i - r * t, e > 0 ? n >= 0 && t >= 0 : n >= 0 || t >= 0) : n > 0
            }
            var o, a, s, l, h, u = {};
            for (s = e.concat(), o = 0, a = t.length; a > o; o++) Array.prototype.push.apply(s, t[o]);
            for (o = 0, a = s.length; a > o; o++) h = s[o].x + ":" + s[o].y, void 0 !== u[h] && THREE.warn("THREE.Shape: Duplicate point", h), u[h] = o;
            o = function(e, t) {
                function i(e, t) {
                    var i = s.length - 1,
                        r = e - 1;
                    0 > r && (r = i);
                    var o = e + 1;
                    return o > i && (o = 0), (i = n(s[e], s[r], s[o], l[t])) ? (i = l.length - 1, r = t - 1, 0 > r && (r = i), o = t + 1, o > i && (o = 0), (i = n(l[t], l[r], l[o], s[e])) ? !0 : !1) : !1
                }

                function o(e, t) {
                    var i, n;
                    for (i = 0; i < s.length; i++)
                        if (n = i + 1, n %= s.length, n = r(e, t, s[i], s[n], !0), 0 < n.length) return !0;
                    return !1
                }

                function a(e, i) {
                    var n, o, a, s;
                    for (n = 0; n < h.length; n++)
                        for (o = t[h[n]], a = 0; a < o.length; a++)
                            if (s = a + 1, s %= o.length, s = r(e, i, o[a], o[s], !0), 0 < s.length) return !0;
                    return !1
                }
                var s = e.concat(),
                    l, h = [],
                    u, c, p, d, f, m = [],
                    E, v, g, y = 0;
                for (u = t.length; u > y; y++) h.push(y);
                E = 0;
                for (var T = 2 * h.length; 0 < h.length;) {
                    if (T--, 0 > T) {
                        console.log("Infinite Loop! Holes left:" + h.length + ", Probably Hole outside Shape!");
                        break
                    }
                    for (c = E; c < s.length; c++) {
                        for (p = s[c], u = -1, y = 0; y < h.length; y++)
                            if (d = h[y], f = p.x + ":" + p.y + ":" + d, void 0 === m[f]) {
                                for (l = t[d], v = 0; v < l.length; v++)
                                    if (d = l[v], i(c, v) && !o(p, d) && !a(p, d)) {
                                        u = v, h.splice(y, 1), E = s.slice(0, c + 1), d = s.slice(c), v = l.slice(u), g = l.slice(0, u + 1), s = E.concat(v).concat(g).concat(d), E = c;
                                        break
                                    }
                                if (u >= 0) break;
                                m[f] = !0
                            }
                        if (u >= 0) break
                    }
                }
                return s
            }(e, t);
            var c = THREE.FontUtils.Triangulate(o, !1);
            for (o = 0, a = c.length; a > o; o++)
                for (l = c[o], s = 0; 3 > s; s++) h = l[s].x + ":" + l[s].y, h = u[h], void 0 !== h && (l[s] = h);
            return c.concat()
        },
        isClockWise: function(e) {
            return 0 > THREE.FontUtils.Triangulate.area(e)
        },
        b2p0: function(e, t) {
            var i = 1 - e;
            return i * i * t
        },
        b2p1: function(e, t) {
            return 2 * (1 - e) * e * t
        },
        b2p2: function(e, t) {
            return e * e * t
        },
        b2: function(e, t, i, r) {
            return this.b2p0(e, t) + this.b2p1(e, i) + this.b2p2(e, r)
        },
        b3p0: function(e, t) {
            var i = 1 - e;
            return i * i * i * t
        },
        b3p1: function(e, t) {
            var i = 1 - e;
            return 3 * i * i * e * t
        },
        b3p2: function(e, t) {
            return 3 * (1 - e) * e * e * t
        },
        b3p3: function(e, t) {
            return e * e * e * t
        },
        b3: function(e, t, i, r, n) {
            return this.b3p0(e, t) + this.b3p1(e, i) + this.b3p2(e, r) + this.b3p3(e, n)
        }
    }, THREE.LineCurve = function(e, t) {
        this.v1 = e, this.v2 = t
    }, THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.LineCurve.prototype.constructor = THREE.LineCurve, THREE.LineCurve.prototype.getPoint = function(e) {
        var t = this.v2.clone().sub(this.v1);
        return t.multiplyScalar(e).add(this.v1), t
    }, THREE.LineCurve.prototype.getPointAt = function(e) {
        return this.getPoint(e)
    }, THREE.LineCurve.prototype.getTangent = function(e) {
        return this.v2.clone().sub(this.v1).normalize()
    }, THREE.QuadraticBezierCurve = function(e, t, i) {
        this.v0 = e, this.v1 = t, this.v2 = i
    }, THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve, THREE.QuadraticBezierCurve.prototype.getPoint = function(e) {
        var t = new THREE.Vector2;
        return t.x = THREE.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x), t.y = THREE.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y), t
    }, THREE.QuadraticBezierCurve.prototype.getTangent = function(e) {
        var t = new THREE.Vector2;
        return t.x = THREE.Curve.Utils.tangentQuadraticBezier(e, this.v0.x, this.v1.x, this.v2.x), t.y = THREE.Curve.Utils.tangentQuadraticBezier(e, this.v0.y, this.v1.y, this.v2.y), t.normalize()
    }, THREE.CubicBezierCurve = function(e, t, i, r) {
        this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r
    }, THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve, THREE.CubicBezierCurve.prototype.getPoint = function(e) {
        var t;
        return t = THREE.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e = THREE.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), new THREE.Vector2(t, e)
    }, THREE.CubicBezierCurve.prototype.getTangent = function(e) {
        var t;
        return t = THREE.Curve.Utils.tangentCubicBezier(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e = THREE.Curve.Utils.tangentCubicBezier(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), t = new THREE.Vector2(t, e), t.normalize(), t
    }, THREE.SplineCurve = function(e) {
        this.points = void 0 == e ? [] : e
    }, THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.SplineCurve.prototype.constructor = THREE.SplineCurve, THREE.SplineCurve.prototype.getPoint = function(e) {
        var t = this.points;
        e *= t.length - 1;
        var i = Math.floor(e);
        e -= i;
        var r = t[0 == i ? i : i - 1],
            n = t[i],
            o = t[i > t.length - 2 ? t.length - 1 : i + 1],
            t = t[i > t.length - 3 ? t.length - 1 : i + 2],
            i = new THREE.Vector2;
        return i.x = THREE.Curve.Utils.interpolate(r.x, n.x, o.x, t.x, e), i.y = THREE.Curve.Utils.interpolate(r.y, n.y, o.y, t.y, e), i
    }, THREE.EllipseCurve = function(e, t, i, r, n, o, a) {
        this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = n, this.aEndAngle = o, this.aClockwise = a
    }, THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype), THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve, THREE.EllipseCurve.prototype.getPoint = function(e) {
        var t = this.aEndAngle - this.aStartAngle;
        return 0 > t && (t += 2 * Math.PI), t > 2 * Math.PI && (t -= 2 * Math.PI), e = !0 === this.aClockwise ? this.aEndAngle + (1 - e) * (2 * Math.PI - t) : this.aStartAngle + e * t, t = new THREE.Vector2, t.x = this.aX + this.xRadius * Math.cos(e), t.y = this.aY + this.yRadius * Math.sin(e), t
    }, THREE.ArcCurve = function(e, t, i, r, n, o) {
        THREE.EllipseCurve.call(this, e, t, i, i, r, n, o)
    }, THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype), THREE.ArcCurve.prototype.constructor = THREE.ArcCurve, THREE.LineCurve3 = THREE.Curve.create(function(e, t) {
        this.v1 = e, this.v2 = t
    }, function(e) {
        var t = new THREE.Vector3;
        return t.subVectors(this.v2, this.v1), t.multiplyScalar(e), t.add(this.v1), t
    }), THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(e, t, i) {
        this.v0 = e, this.v1 = t, this.v2 = i
    }, function(e) {
        var t = new THREE.Vector3;
        return t.x = THREE.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x), t.y = THREE.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y), t.z = THREE.Shape.Utils.b2(e, this.v0.z, this.v1.z, this.v2.z), t
    }), THREE.CubicBezierCurve3 = THREE.Curve.create(function(e, t, i, r) {
        this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r
    }, function(e) {
        var t = new THREE.Vector3;
        return t.x = THREE.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), t.y = THREE.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), t.z = THREE.Shape.Utils.b3(e, this.v0.z, this.v1.z, this.v2.z, this.v3.z), t
    }), THREE.SplineCurve3 = THREE.Curve.create(function(e) {
        this.points = void 0 == e ? [] : e
    }, function(e) {
        var t = this.points;
        e *= t.length - 1;
        var i = Math.floor(e);
        e -= i;
        var r = t[0 == i ? i : i - 1],
            n = t[i],
            o = t[i > t.length - 2 ? t.length - 1 : i + 1],
            t = t[i > t.length - 3 ? t.length - 1 : i + 2],
            i = new THREE.Vector3;
        return i.x = THREE.Curve.Utils.interpolate(r.x, n.x, o.x, t.x, e), i.y = THREE.Curve.Utils.interpolate(r.y, n.y, o.y, t.y, e), i.z = THREE.Curve.Utils.interpolate(r.z, n.z, o.z, t.z, e), i
    }), THREE.ClosedSplineCurve3 = THREE.Curve.create(function(e) {
        this.points = void 0 == e ? [] : e
    }, function(e) {
        var t = this.points;
        e *= t.length - 0;
        var i = Math.floor(e);
        e -= i;
        var i = i + (i > 0 ? 0 : (Math.floor(Math.abs(i) / t.length) + 1) * t.length),
            r = t[(i - 1) % t.length],
            n = t[i % t.length],
            o = t[(i + 1) % t.length],
            t = t[(i + 2) % t.length],
            i = new THREE.Vector3;
        return i.x = THREE.Curve.Utils.interpolate(r.x, n.x, o.x, t.x, e), i.y = THREE.Curve.Utils.interpolate(r.y, n.y, o.y, t.y, e), i.z = THREE.Curve.Utils.interpolate(r.z, n.z, o.z, t.z, e), i
    }), THREE.AnimationHandler = {
        LINEAR: 0,
        CATMULLROM: 1,
        CATMULLROM_FORWARD: 2,
        add: function() {
            THREE.warn("THREE.AnimationHandler.add() has been deprecated.")
        },
        get: function() {
            THREE.warn("THREE.AnimationHandler.get() has been deprecated.")
        },
        remove: function() {
            THREE.warn("THREE.AnimationHandler.remove() has been deprecated.")
        },
        animations: [],
        init: function(e) {
            if (!0 === e.initialized) return e;
            for (var t = 0; t < e.hierarchy.length; t++) {
                for (var i = 0; i < e.hierarchy[t].keys.length; i++)
                    if (0 > e.hierarchy[t].keys[i].time && (e.hierarchy[t].keys[i].time = 0), void 0 !== e.hierarchy[t].keys[i].rot && !(e.hierarchy[t].keys[i].rot instanceof THREE.Quaternion)) {
                        var r = e.hierarchy[t].keys[i].rot;
                        e.hierarchy[t].keys[i].rot = (new THREE.Quaternion).fromArray(r)
                    }
                if (e.hierarchy[t].keys.length && void 0 !== e.hierarchy[t].keys[0].morphTargets) {
                    for (r = {}, i = 0; i < e.hierarchy[t].keys.length; i++)
                        for (var n = 0; n < e.hierarchy[t].keys[i].morphTargets.length; n++) {
                            var o = e.hierarchy[t].keys[i].morphTargets[n];
                            r[o] = -1
                        }
                    for (e.hierarchy[t].usedMorphTargets = r, i = 0; i < e.hierarchy[t].keys.length; i++) {
                        var a = {};
                        for (o in r) {
                            for (n = 0; n < e.hierarchy[t].keys[i].morphTargets.length; n++)
                                if (e.hierarchy[t].keys[i].morphTargets[n] === o) {
                                    a[o] = e.hierarchy[t].keys[i].morphTargetsInfluences[n];
                                    break
                                }
                            n === e.hierarchy[t].keys[i].morphTargets.length && (a[o] = 0)
                        }
                        e.hierarchy[t].keys[i].morphTargetsInfluences = a
                    }
                }
                for (i = 1; i < e.hierarchy[t].keys.length; i++) e.hierarchy[t].keys[i].time === e.hierarchy[t].keys[i - 1].time && (e.hierarchy[t].keys.splice(i, 1), i--);
                for (i = 0; i < e.hierarchy[t].keys.length; i++) e.hierarchy[t].keys[i].index = i
            }
            return e.initialized = !0, e
        },
        parse: function(e) {
            var t = function(e, i) {
                    i.push(e);
                    for (var r = 0; r < e.children.length; r++) t(e.children[r], i)
                },
                i = [];
            if (e instanceof THREE.SkinnedMesh)
                for (var r = 0; r < e.skeleton.bones.length; r++) i.push(e.skeleton.bones[r]);
            else t(e, i);
            return i
        },
        play: function(e) {
            -1 === this.animations.indexOf(e) && this.animations.push(e)
        },
        stop: function(e) {
            e = this.animations.indexOf(e), -1 !== e && this.animations.splice(e, 1)
        },
        update: function(e) {
            for (var t = 0; t < this.animations.length; t++) this.animations[t].resetBlendWeights();
            for (t = 0; t < this.animations.length; t++) this.animations[t].update(e)
        }
    }, THREE.Animation = function(e, t) {
        this.root = e, this.data = THREE.AnimationHandler.init(t), this.hierarchy = THREE.AnimationHandler.parse(e), this.currentTime = 0, this.timeScale = 1, this.isPlaying = !1, this.loop = !0, this.weight = 0, this.interpolationType = THREE.AnimationHandler.LINEAR
    }, THREE.Animation.prototype = {
        constructor: THREE.Animation,
        keyTypes: ["pos", "rot", "scl"],
        play: function(e, t) {
            this.currentTime = void 0 !== e ? e : 0, this.weight = void 0 !== t ? t : 1, this.isPlaying = !0, this.reset(), THREE.AnimationHandler.play(this)
        },
        stop: function() {
            this.isPlaying = !1, THREE.AnimationHandler.stop(this)
        },
        reset: function() {
            for (var e = 0, t = this.hierarchy.length; t > e; e++) {
                var i = this.hierarchy[e];
                void 0 === i.animationCache && (i.animationCache = {
                    animations: {},
                    blending: {
                        positionWeight: 0,
                        quaternionWeight: 0,
                        scaleWeight: 0
                    }
                });
                var r = this.data.name,
                    n = i.animationCache.animations,
                    o = n[r];
                for (void 0 === o && (o = {
                        prevKey: {
                            pos: 0,
                            rot: 0,
                            scl: 0
                        },
                        nextKey: {
                            pos: 0,
                            rot: 0,
                            scl: 0
                        },
                        originalMatrix: i.matrix
                    }, n[r] = o), i = 0; 3 > i; i++) {
                    for (var r = this.keyTypes[i], n = this.data.hierarchy[e].keys[0], a = this.getNextKeyWith(r, e, 1); a.time < this.currentTime && a.index > n.index;) n = a, a = this.getNextKeyWith(r, e, a.index + 1);
                    o.prevKey[r] = n, o.nextKey[r] = a
                }
            }
        },
        resetBlendWeights: function() {
            for (var e = 0, t = this.hierarchy.length; t > e; e++) {
                var i = this.hierarchy[e].animationCache;
                void 0 !== i && (i = i.blending, i.positionWeight = 0, i.quaternionWeight = 0, i.scaleWeight = 0)
            }
        },
        update: function() {
            var e = [],
                t = new THREE.Vector3,
                i = new THREE.Vector3,
                r = new THREE.Quaternion,
                n = function(e, t) {
                    var i = [],
                        r = [],
                        n, a, s, l, h, u;
                    return n = (e.length - 1) * t, a = Math.floor(n), n -= a, i[0] = 0 === a ? a : a - 1, i[1] = a, i[2] = a > e.length - 2 ? a : a + 1, i[3] = a > e.length - 3 ? a : a + 2, a = e[i[0]], l = e[i[1]], h = e[i[2]], u = e[i[3]], i = n * n, s = n * i, r[0] = o(a[0], l[0], h[0], u[0], n, i, s), r[1] = o(a[1], l[1], h[1], u[1], n, i, s), r[2] = o(a[2], l[2], h[2], u[2], n, i, s), r
                },
                o = function(e, t, i, r, n, o, a) {
                    return e = .5 * (i - e), r = .5 * (r - t), (2 * (t - i) + e + r) * a + (-3 * (t - i) - 2 * e - r) * o + e * n + t
                };
            return function(o) {
                if (!1 !== this.isPlaying && (this.currentTime += o * this.timeScale, 0 !== this.weight)) {
                    o = this.data.length, (this.currentTime > o || 0 > this.currentTime) && (this.loop ? (this.currentTime %= o, 0 > this.currentTime && (this.currentTime += o), this.reset()) : this.stop()), o = 0;
                    for (var a = this.hierarchy.length; a > o; o++)
                        for (var s = this.hierarchy[o], l = s.animationCache.animations[this.data.name], h = s.animationCache.blending, u = 0; 3 > u; u++) {
                            var c = this.keyTypes[u],
                                p = l.prevKey[c],
                                d = l.nextKey[c];
                            if (0 < this.timeScale && d.time <= this.currentTime || 0 > this.timeScale && p.time >= this.currentTime) {
                                for (p = this.data.hierarchy[o].keys[0], d = this.getNextKeyWith(c, o, 1); d.time < this.currentTime && d.index > p.index;) p = d, d = this.getNextKeyWith(c, o, d.index + 1);
                                l.prevKey[c] = p, l.nextKey[c] = d
                            }
                            var f = (this.currentTime - p.time) / (d.time - p.time),
                                m = p[c],
                                E = d[c];
                            0 > f && (f = 0), f > 1 && (f = 1), "pos" === c ? this.interpolationType === THREE.AnimationHandler.LINEAR ? (i.x = m[0] + (E[0] - m[0]) * f, i.y = m[1] + (E[1] - m[1]) * f, i.z = m[2] + (E[2] - m[2]) * f, p = this.weight / (this.weight + h.positionWeight), s.position.lerp(i, p), h.positionWeight += this.weight) : (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) && (e[0] = this.getPrevKeyWith("pos", o, p.index - 1).pos, e[1] = m, e[2] = E, e[3] = this.getNextKeyWith("pos", o, d.index + 1).pos, f = .33 * f + .33, d = n(e, f), p = this.weight / (this.weight + h.positionWeight), h.positionWeight += this.weight, c = s.position, c.x += (d[0] - c.x) * p, c.y += (d[1] - c.y) * p, c.z += (d[2] - c.z) * p, this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (f = n(e, 1.01 * f), t.set(f[0], f[1], f[2]), t.sub(c), t.y = 0, t.normalize(), f = Math.atan2(t.x, t.z), s.rotation.set(0, f, 0))) : "rot" === c ? (THREE.Quaternion.slerp(m, E, r, f), 0 === h.quaternionWeight ? (s.quaternion.copy(r), h.quaternionWeight = this.weight) : (p = this.weight / (this.weight + h.quaternionWeight), THREE.Quaternion.slerp(s.quaternion, r, s.quaternion, p), h.quaternionWeight += this.weight)) : "scl" === c && (i.x = m[0] + (E[0] - m[0]) * f, i.y = m[1] + (E[1] - m[1]) * f, i.z = m[2] + (E[2] - m[2]) * f, p = this.weight / (this.weight + h.scaleWeight), s.scale.lerp(i, p), h.scaleWeight += this.weight)
                        }
                    return !0
                }
            }
        }(),
        getNextKeyWith: function(e, t, i) {
            var r = this.data.hierarchy[t].keys;
            for (i = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? i < r.length - 1 ? i : r.length - 1 : i % r.length; i < r.length; i++)
                if (void 0 !== r[i][e]) return r[i];
            return this.data.hierarchy[t].keys[0]
        },
        getPrevKeyWith: function(e, t, i) {
            var r = this.data.hierarchy[t].keys;
            for (i = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? i > 0 ? i : 0 : i >= 0 ? i : i + r.length; i >= 0; i--)
                if (void 0 !== r[i][e]) return r[i];
            return this.data.hierarchy[t].keys[r.length - 1]
        }
    }, THREE.KeyFrameAnimation = function(e) {
        this.root = e.node, this.data = THREE.AnimationHandler.init(e), this.hierarchy = THREE.AnimationHandler.parse(this.root), this.currentTime = 0, this.timeScale = .001, this.isPlaying = !1, this.loop = this.isPaused = !0, e = 0;
        for (var t = this.hierarchy.length; t > e; e++) {
            var i = this.data.hierarchy[e].sids,
                r = this.hierarchy[e];
            if (this.data.hierarchy[e].keys.length && i) {
                for (var n = 0; n < i.length; n++) {
                    var o = i[n],
                        a = this.getNextKeyWith(o, e, 0);
                    a && a.apply(o)
                }
                r.matrixAutoUpdate = !1, this.data.hierarchy[e].node.updateMatrix(), r.matrixWorldNeedsUpdate = !0
            }
        }
    }, THREE.KeyFrameAnimation.prototype = {
        constructor: THREE.KeyFrameAnimation,
        play: function(e) {
            if (this.currentTime = void 0 !== e ? e : 0, !1 === this.isPlaying) {
                this.isPlaying = !0;
                var t = this.hierarchy.length,
                    i, r;
                for (e = 0; t > e; e++) i = this.hierarchy[e], r = this.data.hierarchy[e], void 0 === r.animationCache && (r.animationCache = {}, r.animationCache.prevKey = null, r.animationCache.nextKey = null, r.animationCache.originalMatrix = i.matrix), i = this.data.hierarchy[e].keys, i.length && (r.animationCache.prevKey = i[0], r.animationCache.nextKey = i[1], this.startTime = Math.min(i[0].time, this.startTime), this.endTime = Math.max(i[i.length - 1].time, this.endTime));
                this.update(0)
            }
            this.isPaused = !1, THREE.AnimationHandler.play(this)
        },
        stop: function() {
            this.isPaused = this.isPlaying = !1, THREE.AnimationHandler.stop(this);
            for (var e = 0; e < this.data.hierarchy.length; e++) {
                var t = this.hierarchy[e],
                    i = this.data.hierarchy[e];
                if (void 0 !== i.animationCache) {
                    var r = i.animationCache.originalMatrix;
                    r.copy(t.matrix), t.matrix = r, delete i.animationCache
                }
            }
        },
        update: function(e) {
            if (!1 !== this.isPlaying) {
                this.currentTime += e * this.timeScale, e = this.data.length, !0 === this.loop && this.currentTime > e && (this.currentTime %= e), this.currentTime = Math.min(this.currentTime, e), e = 0;
                for (var t = this.hierarchy.length; t > e; e++) {
                    var i = this.hierarchy[e],
                        r = this.data.hierarchy[e],
                        n = r.keys,
                        r = r.animationCache;
                    if (n.length) {
                        var o = r.prevKey,
                            a = r.nextKey;
                        if (a.time <= this.currentTime) {
                            for (; a.time < this.currentTime && a.index > o.index;) o = a, a = n[o.index + 1];
                            r.prevKey = o, r.nextKey = a
                        }
                        a.time >= this.currentTime ? o.interpolate(a, this.currentTime) : o.interpolate(a, a.time), this.data.hierarchy[e].node.updateMatrix(), i.matrixWorldNeedsUpdate = !0
                    }
                }
            }
        },
        getNextKeyWith: function(e, t, i) {
            for (t = this.data.hierarchy[t].keys, i %= t.length; i < t.length; i++)
                if (t[i].hasTarget(e)) return t[i];
            return t[0]
        },
        getPrevKeyWith: function(e, t, i) {
            for (t = this.data.hierarchy[t].keys, i = i >= 0 ? i : i + t.length; i >= 0; i--)
                if (t[i].hasTarget(e)) return t[i];
            return t[t.length - 1]
        }
    }, THREE.MorphAnimation = function(e) {
        this.mesh = e, this.frames = e.morphTargetInfluences.length, this.currentTime = 0, this.duration = 1e3, this.loop = !0, this.currentFrame = this.lastFrame = 0, this.isPlaying = !1
    }, THREE.MorphAnimation.prototype = {
        constructor: THREE.MorphAnimation,
        play: function() {
            this.isPlaying = !0
        },
        pause: function() {
            this.isPlaying = !1
        },
        update: function(e) {
            if (!1 !== this.isPlaying) {
                this.currentTime += e, !0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration), this.currentTime = Math.min(this.currentTime, this.duration), e = this.duration / this.frames;
                var t = Math.floor(this.currentTime / e),
                    i = this.mesh.morphTargetInfluences;
                t != this.currentFrame && (i[this.lastFrame] = 0, i[this.currentFrame] = 1, i[t] = 0, this.lastFrame = this.currentFrame, this.currentFrame = t), i[t] = this.currentTime % e / e, i[this.lastFrame] = 1 - i[t]
            }
        }
    }, THREE.BoxGeometry = function(e, t, i, r, n, o) {
        function a(e, t, i, r, n, o, a, l) {
            var h, u = s.widthSegments,
                c = s.heightSegments,
                p = n / 2,
                d = o / 2,
                f = s.vertices.length;
            "x" === e && "y" === t || "y" === e && "x" === t ? h = "z" : "x" === e && "z" === t || "z" === e && "x" === t ? (h = "y", c = s.depthSegments) : ("z" === e && "y" === t || "y" === e && "z" === t) && (h = "x", u = s.depthSegments);
            var m = u + 1,
                E = c + 1,
                v = n / u,
                g = o / c,
                y = new THREE.Vector3;
            for (y[h] = a > 0 ? 1 : -1, n = 0; E > n; n++)
                for (o = 0; m > o; o++) {
                    var T = new THREE.Vector3;
                    T[e] = (o * v - p) * i, T[t] = (n * g - d) * r, T[h] = a, s.vertices.push(T)
                }
            for (n = 0; c > n; n++)
                for (o = 0; u > o; o++) d = o + m * n, e = o + m * (n + 1), t = o + 1 + m * (n + 1), i = o + 1 + m * n, r = new THREE.Vector2(o / u, 1 - n / c), a = new THREE.Vector2(o / u, 1 - (n + 1) / c), h = new THREE.Vector2((o + 1) / u, 1 - (n + 1) / c), p = new THREE.Vector2((o + 1) / u, 1 - n / c), d = new THREE.Face3(d + f, e + f, i + f), d.normal.copy(y), d.vertexNormals.push(y.clone(), y.clone(), y.clone()), d.materialIndex = l, s.faces.push(d), s.faceVertexUvs[0].push([r, a, p]), d = new THREE.Face3(e + f, t + f, i + f), d.normal.copy(y), d.vertexNormals.push(y.clone(), y.clone(), y.clone()), d.materialIndex = l, s.faces.push(d), s.faceVertexUvs[0].push([a.clone(), h, p.clone()])
        }
        THREE.Geometry.call(this), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: r,
            heightSegments: n,
            depthSegments: o
        }, this.widthSegments = r || 1, this.heightSegments = n || 1, this.depthSegments = o || 1;
        var s = this;
        r = e / 2, n = t / 2, o = i / 2, a("z", "y", -1, -1, i, t, r, 0), a("z", "y", 1, -1, i, t, -r, 1), a("x", "z", 1, 1, e, i, n, 2), a("x", "z", 1, -1, e, i, -n, 3), a("x", "y", 1, -1, e, t, o, 4), a("x", "y", -1, -1, e, t, -o, 5), this.mergeVertices()
    }, THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry, THREE.CircleGeometry = function(e, t, i, r) {
        THREE.Geometry.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: r
        }, e = e || 50, t = void 0 !== t ? Math.max(3, t) : 8, i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI;
        var n, o = [];
        n = new THREE.Vector3;
        var a = new THREE.Vector2(.5, .5);
        for (this.vertices.push(n), o.push(a), n = 0; t >= n; n++) {
            var s = new THREE.Vector3,
                l = i + n / t * r;
            s.x = e * Math.cos(l), s.y = e * Math.sin(l), this.vertices.push(s), o.push(new THREE.Vector2((s.x / e + 1) / 2, (s.y / e + 1) / 2))
        }
        for (i = new THREE.Vector3(0, 0, 1), n = 1; t >= n; n++) this.faces.push(new THREE.Face3(n, n + 1, 0, [i.clone(), i.clone(), i.clone()])), this.faceVertexUvs[0].push([o[n].clone(), o[n + 1].clone(), a.clone()]);
        this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, e)
    }, THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry, THREE.CubeGeometry = function(e, t, i, r, n, o) {
        return THREE.warn("THREE.CubeGeometry has been renamed to THREE.BoxGeometry."), new THREE.BoxGeometry(e, t, i, r, n, o)
    }, THREE.CylinderGeometry = function(e, t, i, r, n, o, a, s) {
        THREE.Geometry.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: r,
            heightSegments: n,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        }, e = void 0 !== e ? e : 20, t = void 0 !== t ? t : 20, i = void 0 !== i ? i : 100, r = r || 8, n = n || 1, o = void 0 !== o ? o : !1, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI;
        var l = i / 2,
            h, u, c = [],
            p = [];
        for (u = 0; n >= u; u++) {
            var d = [],
                f = [],
                m = u / n,
                E = m * (t - e) + e;
            for (h = 0; r >= h; h++) {
                var v = h / r,
                    g = new THREE.Vector3;
                g.x = E * Math.sin(v * s + a), g.y = -m * i + l, g.z = E * Math.cos(v * s + a), this.vertices.push(g), d.push(this.vertices.length - 1), f.push(new THREE.Vector2(v, 1 - m))
            }
            c.push(d), p.push(f)
        }
        for (i = (t - e) / i, h = 0; r > h; h++)
            for (0 !== e ? (a = this.vertices[c[0][h]].clone(), s = this.vertices[c[0][h + 1]].clone()) : (a = this.vertices[c[1][h]].clone(), s = this.vertices[c[1][h + 1]].clone()), a.setY(Math.sqrt(a.x * a.x + a.z * a.z) * i).normalize(), s.setY(Math.sqrt(s.x * s.x + s.z * s.z) * i).normalize(), u = 0; n > u; u++) {
                var d = c[u][h],
                    f = c[u + 1][h],
                    m = c[u + 1][h + 1],
                    E = c[u][h + 1],
                    v = a.clone(),
                    g = a.clone(),
                    y = s.clone(),
                    T = s.clone(),
                    x = p[u][h].clone(),
                    _ = p[u + 1][h].clone(),
                    R = p[u + 1][h + 1].clone(),
                    b = p[u][h + 1].clone();
                this.faces.push(new THREE.Face3(d, f, E, [v, g, T])), this.faceVertexUvs[0].push([x, _, b]), this.faces.push(new THREE.Face3(f, m, E, [g.clone(), y, T.clone()])), this.faceVertexUvs[0].push([_.clone(), R, b.clone()])
            }
        if (!1 === o && e > 0)
            for (this.vertices.push(new THREE.Vector3(0, l, 0)), h = 0; r > h; h++) d = c[0][h], f = c[0][h + 1], m = this.vertices.length - 1, v = new THREE.Vector3(0, 1, 0), g = new THREE.Vector3(0, 1, 0), y = new THREE.Vector3(0, 1, 0), x = p[0][h].clone(), _ = p[0][h + 1].clone(), R = new THREE.Vector2(_.x, 0), this.faces.push(new THREE.Face3(d, f, m, [v, g, y])), this.faceVertexUvs[0].push([x, _, R]);
        if (!1 === o && t > 0)
            for (this.vertices.push(new THREE.Vector3(0, -l, 0)), h = 0; r > h; h++) d = c[n][h + 1], f = c[n][h], m = this.vertices.length - 1, v = new THREE.Vector3(0, -1, 0), g = new THREE.Vector3(0, -1, 0), y = new THREE.Vector3(0, -1, 0), x = p[n][h + 1].clone(), _ = p[n][h].clone(), R = new THREE.Vector2(_.x, 1), this.faces.push(new THREE.Face3(d, f, m, [v, g, y])), this.faceVertexUvs[0].push([x, _, R]);
        this.computeFaceNormals()
    }, THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry, THREE.ExtrudeGeometry = function(e, t) {
        "undefined" != typeof e && (THREE.Geometry.call(this), this.type = "ExtrudeGeometry", e = e instanceof Array ? e : [e], this.addShapeList(e, t), this.computeFaceNormals())
    }, THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry, THREE.ExtrudeGeometry.prototype.addShapeList = function(e, t) {
        for (var i = e.length, r = 0; i > r; r++) this.addShape(e[r], t)
    }, THREE.ExtrudeGeometry.prototype.addShape = function(e, t) {
        function i(e, t, i) {
            return t || THREE.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(i).add(e)
        }

        function r(e, t, i) {
            var r = 1,
                r = e.x - t.x,
                n = e.y - t.y,
                o = i.x - e.x,
                a = i.y - e.y,
                s = r * r + n * n;
            if (1e-10 < Math.abs(r * a - n * o)) {
                var l = Math.sqrt(s),
                    h = Math.sqrt(o * o + a * a),
                    s = t.x - n / l;
                if (t = t.y + r / l, o = ((i.x - a / h - s) * a - (i.y + o / h - t) * o) / (r * a - n * o), i = s + r * o - e.x, e = t + n * o - e.y, r = i * i + e * e, 2 >= r) return new THREE.Vector2(i, e);
                r = Math.sqrt(r / 2)
            } else e = !1, r > 1e-10 ? o > 1e-10 && (e = !0) : -1e-10 > r ? -1e-10 > o && (e = !0) : Math.sign(n) == Math.sign(a) && (e = !0), e ? (i = -n, e = r, r = Math.sqrt(s)) : (i = r, e = n, r = Math.sqrt(s / 2));
            return new THREE.Vector2(i / r, e / r)
        }

        function n(e, t) {
            var i, r;
            for (z = e.length; 0 <= --z;) {
                i = z, r = z - 1, 0 > r && (r = e.length - 1);
                for (var n = 0, o = d + 2 * u, n = 0; o > n; n++) {
                    var a = U * n,
                        s = U * (n + 1),
                        l = t + i + a,
                        a = t + r + a,
                        h = t + r + s,
                        s = t + i + s,
                        l = l + S,
                        a = a + S,
                        h = h + S,
                        s = s + S;
                    M.faces.push(new THREE.Face3(l, a, s, null, null, g)), M.faces.push(new THREE.Face3(a, h, s, null, null, g)), l = y.generateSideWallUV(M, l, a, h, s), M.faceVertexUvs[0].push([l[0], l[1], l[3]]), M.faceVertexUvs[0].push([l[1], l[2], l[3]])
                }
            }
        }

        function o(e, t, i) {
            M.vertices.push(new THREE.Vector3(e, t, i))
        }

        function a(e, t, i) {
            e += S, t += S, i += S, M.faces.push(new THREE.Face3(e, t, i, null, null, v)), e = y.generateTopUV(M, e, t, i), M.faceVertexUvs[0].push(e)
        }
        var s = void 0 !== t.amount ? t.amount : 100,
            l = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
            h = void 0 !== t.bevelSize ? t.bevelSize : l - 2,
            u = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
            c = void 0 !== t.bevelEnabled ? t.bevelEnabled : !0,
            p = void 0 !== t.curveSegments ? t.curveSegments : 12,
            d = void 0 !== t.steps ? t.steps : 1,
            f = t.extrudePath,
            m, E = !1,
            v = t.material,
            g = t.extrudeMaterial,
            y = void 0 !== t.UVGenerator ? t.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator,
            T, x, _, R;
        f && (m = f.getSpacedPoints(d), E = !0, c = !1, T = void 0 !== t.frames ? t.frames : new THREE.TubeGeometry.FrenetFrames(f, d, !1), x = new THREE.Vector3, _ = new THREE.Vector3, R = new THREE.Vector3), c || (h = l = u = 0);
        var b, H, w, M = this,
            S = this.vertices.length,
            f = e.extractPoints(p),
            p = f.shape,
            C = f.holes;
        if (f = !THREE.Shape.Utils.isClockWise(p)) {
            for (p = p.reverse(), H = 0, w = C.length; w > H; H++) b = C[H], THREE.Shape.Utils.isClockWise(b) && (C[H] = b.reverse());
            f = !1
        }
        var A = THREE.Shape.Utils.triangulateShape(p, C),
            P = p;
        for (H = 0, w = C.length; w > H; H++) b = C[H], p = p.concat(b);
        var L, D, O, F, k, U = p.length,
            N, B = A.length,
            f = [],
            z = 0;
        for (O = P.length, L = O - 1, D = z + 1; O > z; z++, L++, D++) L === O && (L = 0), D === O && (D = 0), f[z] = r(P[z], P[L], P[D]);
        var V = [],
            I, j = f.concat();
        for (H = 0, w = C.length; w > H; H++) {
            for (b = C[H], I = [], z = 0, O = b.length, L = O - 1, D = z + 1; O > z; z++, L++, D++) L === O && (L = 0), D === O && (D = 0), I[z] = r(b[z], b[L], b[D]);
            V.push(I), j = j.concat(I)
        }
        for (L = 0; u > L; L++) {
            for (O = L / u, F = l * (1 - O), D = h * Math.sin(O * Math.PI / 2), z = 0, O = P.length; O > z; z++) k = i(P[z], f[z], D), o(k.x, k.y, -F);
            for (H = 0, w = C.length; w > H; H++)
                for (b = C[H], I = V[H], z = 0, O = b.length; O > z; z++) k = i(b[z], I[z], D), o(k.x, k.y, -F)
        }
        for (D = h, z = 0; U > z; z++) k = c ? i(p[z], j[z], D) : p[z], E ? (_.copy(T.normals[0]).multiplyScalar(k.x), x.copy(T.binormals[0]).multiplyScalar(k.y), R.copy(m[0]).add(_).add(x), o(R.x, R.y, R.z)) : o(k.x, k.y, 0);
        for (O = 1; d >= O; O++)
            for (z = 0; U > z; z++) k = c ? i(p[z], j[z], D) : p[z], E ? (_.copy(T.normals[O]).multiplyScalar(k.x), x.copy(T.binormals[O]).multiplyScalar(k.y), R.copy(m[O]).add(_).add(x), o(R.x, R.y, R.z)) : o(k.x, k.y, s / d * O);
        for (L = u - 1; L >= 0; L--) {
            for (O = L / u, F = l * (1 - O), D = h * Math.sin(O * Math.PI / 2), z = 0, O = P.length; O > z; z++) k = i(P[z], f[z], D), o(k.x, k.y, s + F);
            for (H = 0, w = C.length; w > H; H++)
                for (b = C[H], I = V[H], z = 0, O = b.length; O > z; z++) k = i(b[z], I[z], D), E ? o(k.x, k.y + m[d - 1].y, m[d - 1].x + F) : o(k.x, k.y, s + F)
        }! function() {
            if (c) {
                var e;
                for (e = 0 * U, z = 0; B > z; z++) N = A[z], a(N[2] + e, N[1] + e, N[0] + e);
                for (e = d + 2 * u, e *= U, z = 0; B > z; z++) N = A[z], a(N[0] + e, N[1] + e, N[2] + e)
            } else {
                for (z = 0; B > z; z++) N = A[z], a(N[2], N[1], N[0]);
                for (z = 0; B > z; z++) N = A[z], a(N[0] + U * d, N[1] + U * d, N[2] + U * d)
            }
        }(),
        function() {
            var e = 0;
            for (n(P, e), e += P.length, H = 0, w = C.length; w > H; H++) b = C[H], n(b, e), e += b.length
        }()
    }, THREE.ExtrudeGeometry.WorldUVGenerator = {
        generateTopUV: function(e, t, i, r) {
            return e = e.vertices, t = e[t], i = e[i], r = e[r], [new THREE.Vector2(t.x, t.y), new THREE.Vector2(i.x, i.y), new THREE.Vector2(r.x, r.y)]
        },
        generateSideWallUV: function(e, t, i, r, n) {
            return e = e.vertices, t = e[t], i = e[i], r = e[r], n = e[n], .01 > Math.abs(t.y - i.y) ? [new THREE.Vector2(t.x, 1 - t.z), new THREE.Vector2(i.x, 1 - i.z), new THREE.Vector2(r.x, 1 - r.z), new THREE.Vector2(n.x, 1 - n.z)] : [new THREE.Vector2(t.y, 1 - t.z), new THREE.Vector2(i.y, 1 - i.z), new THREE.Vector2(r.y, 1 - r.z), new THREE.Vector2(n.y, 1 - n.z)]
        }
    }, THREE.ShapeGeometry = function(e, t) {
        THREE.Geometry.call(this), this.type = "ShapeGeometry", !1 == e instanceof Array && (e = [e]), this.addShapeList(e, t), this.computeFaceNormals()
    }, THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry, THREE.ShapeGeometry.prototype.addShapeList = function(e, t) {
        for (var i = 0, r = e.length; r > i; i++) this.addShape(e[i], t);
        return this
    }, THREE.ShapeGeometry.prototype.addShape = function(e, t) {
        void 0 === t && (t = {});
        var i = t.material,
            r = void 0 === t.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : t.UVGenerator,
            n, o, a, s = this.vertices.length;
        n = e.extractPoints(void 0 !== t.curveSegments ? t.curveSegments : 12);
        var l = n.shape,
            h = n.holes;
        if (!THREE.Shape.Utils.isClockWise(l))
            for (l = l.reverse(), n = 0, o = h.length; o > n; n++) a = h[n], THREE.Shape.Utils.isClockWise(a) && (h[n] = a.reverse());
        var u = THREE.Shape.Utils.triangulateShape(l, h);
        for (n = 0, o = h.length; o > n; n++) a = h[n], l = l.concat(a);
        for (h = l.length, o = u.length, n = 0; h > n; n++) a = l[n], this.vertices.push(new THREE.Vector3(a.x, a.y, 0));
        for (n = 0; o > n; n++) h = u[n], l = h[0] + s, a = h[1] + s, h = h[2] + s, this.faces.push(new THREE.Face3(l, a, h, null, null, i)), this.faceVertexUvs[0].push(r.generateTopUV(this, l, a, h))
    }, THREE.LatheGeometry = function(e, t, i, r) {
        THREE.Geometry.call(this), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: r
        }, t = t || 12, i = i || 0, r = r || 2 * Math.PI;
        for (var n = 1 / (e.length - 1), o = 1 / t, a = 0, s = t; s >= a; a++)
            for (var l = i + a * o * r, h = Math.cos(l), u = Math.sin(l), l = 0, c = e.length; c > l; l++) {
                var p = e[l],
                    d = new THREE.Vector3;
                d.x = h * p.x - u * p.y, d.y = u * p.x + h * p.y, d.z = p.z, this.vertices.push(d)
            }
        for (i = e.length, a = 0, s = t; s > a; a++)
            for (l = 0, c = e.length - 1; c > l; l++) {
                t = u = l + i * a, r = u + i;
                var h = u + 1 + i,
                    u = u + 1,
                    p = a * o,
                    d = l * n,
                    f = p + o,
                    m = d + n;
                this.faces.push(new THREE.Face3(t, r, u)), this.faceVertexUvs[0].push([new THREE.Vector2(p, d), new THREE.Vector2(f, d), new THREE.Vector2(p, m)]), this.faces.push(new THREE.Face3(r, h, u)), this.faceVertexUvs[0].push([new THREE.Vector2(f, d), new THREE.Vector2(f, m), new THREE.Vector2(p, m)])
            }
        this.mergeVertices(), this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry, THREE.PlaneGeometry = function(e, t, i, r) {
        console.info("THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint."), THREE.Geometry.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: r
        }, this.fromBufferGeometry(new THREE.PlaneBufferGeometry(e, t, i, r))
    }, THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry, THREE.PlaneBufferGeometry = function(e, t, i, r) {
        THREE.BufferGeometry.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: r
        };
        var n = e / 2,
            o = t / 2;
        i = i || 1, r = r || 1;
        var a = i + 1,
            s = r + 1,
            l = e / i,
            h = t / r;
        t = new Float32Array(a * s * 3), e = new Float32Array(a * s * 3);
        for (var u = new Float32Array(a * s * 2), c = 0, p = 0, d = 0; s > d; d++)
            for (var f = d * h - o, m = 0; a > m; m++) t[c] = m * l - n, t[c + 1] = -f, e[c + 2] = 1, u[p] = m / i, u[p + 1] = 1 - d / r, c += 3, p += 2;
        for (c = 0, n = new(65535 < t.length / 3 ? Uint32Array : Uint16Array)(i * r * 6), d = 0; r > d; d++)
            for (m = 0; i > m; m++) o = m + a * (d + 1), s = m + 1 + a * (d + 1), l = m + 1 + a * d, n[c] = m + a * d, n[c + 1] = o, n[c + 2] = l, n[c + 3] = o, n[c + 4] = s, n[c + 5] = l, c += 6;
        this.addAttribute("index", new THREE.BufferAttribute(n, 1)), this.addAttribute("position", new THREE.BufferAttribute(t, 3)), this.addAttribute("normal", new THREE.BufferAttribute(e, 3)), this.addAttribute("uv", new THREE.BufferAttribute(u, 2))
    }, THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry, THREE.RingGeometry = function(e, t, i, r, n, o) {
        THREE.Geometry.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: r,
            thetaStart: n,
            thetaLength: o
        }, e = e || 0, t = t || 50, n = void 0 !== n ? n : 0, o = void 0 !== o ? o : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8, r = void 0 !== r ? Math.max(1, r) : 8;
        var a, s = [],
            l = e,
            h = (t - e) / r;
        for (e = 0; r + 1 > e; e++) {
            for (a = 0; i + 1 > a; a++) {
                var u = new THREE.Vector3,
                    c = n + a / i * o;
                u.x = l * Math.cos(c), u.y = l * Math.sin(c), this.vertices.push(u), s.push(new THREE.Vector2((u.x / t + 1) / 2, (u.y / t + 1) / 2))
            }
            l += h
        }
        for (t = new THREE.Vector3(0, 0, 1), e = 0; r > e; e++)
            for (n = e * (i + 1), a = 0; i > a; a++) o = c = a + n, h = c + i + 1, u = c + i + 2, this.faces.push(new THREE.Face3(o, h, u, [t.clone(), t.clone(), t.clone()])), this.faceVertexUvs[0].push([s[o].clone(), s[h].clone(), s[u].clone()]), o = c, h = c + i + 2, u = c + 1, this.faces.push(new THREE.Face3(o, h, u, [t.clone(), t.clone(), t.clone()])), this.faceVertexUvs[0].push([s[o].clone(), s[h].clone(), s[u].clone()]);
        this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, l)
    }, THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.RingGeometry.prototype.constructor = THREE.RingGeometry, THREE.SphereGeometry = function(e, t, i, r, n, o, a) {
        THREE.Geometry.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: r,
            phiLength: n,
            thetaStart: o,
            thetaLength: a
        }, e = e || 50, t = Math.max(3, Math.floor(t) || 8), i = Math.max(2, Math.floor(i) || 6), r = void 0 !== r ? r : 0, n = void 0 !== n ? n : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
        var s, l, h = [],
            u = [];
        for (l = 0; i >= l; l++) {
            var c = [],
                p = [];
            for (s = 0; t >= s; s++) {
                var d = s / t,
                    f = l / i,
                    m = new THREE.Vector3;
                m.x = -e * Math.cos(r + d * n) * Math.sin(o + f * a), m.y = e * Math.cos(o + f * a), m.z = e * Math.sin(r + d * n) * Math.sin(o + f * a), this.vertices.push(m), c.push(this.vertices.length - 1), p.push(new THREE.Vector2(d, 1 - f))
            }
            h.push(c), u.push(p)
        }
        for (l = 0; i > l; l++)
            for (s = 0; t > s; s++) {
                r = h[l][s + 1], n = h[l][s], o = h[l + 1][s], a = h[l + 1][s + 1];
                var c = this.vertices[r].clone().normalize(),
                    p = this.vertices[n].clone().normalize(),
                    d = this.vertices[o].clone().normalize(),
                    f = this.vertices[a].clone().normalize(),
                    m = u[l][s + 1].clone(),
                    E = u[l][s].clone(),
                    v = u[l + 1][s].clone(),
                    g = u[l + 1][s + 1].clone();
                Math.abs(this.vertices[r].y) === e ? (m.x = (m.x + E.x) / 2, this.faces.push(new THREE.Face3(r, o, a, [c, d, f])), this.faceVertexUvs[0].push([m, v, g])) : Math.abs(this.vertices[o].y) === e ? (v.x = (v.x + g.x) / 2, this.faces.push(new THREE.Face3(r, n, o, [c, p, d])), this.faceVertexUvs[0].push([m, E, v])) : (this.faces.push(new THREE.Face3(r, n, a, [c, p, f])), this.faceVertexUvs[0].push([m, E, g]), this.faces.push(new THREE.Face3(n, o, a, [p.clone(), d, f.clone()])), this.faceVertexUvs[0].push([E.clone(), v, g.clone()]))
            }
        this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, e)
    }, THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry, THREE.TextGeometry = function(e, t) {
        t = t || {};
        var i = THREE.FontUtils.generateShapes(e, t);
        t.amount = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), THREE.ExtrudeGeometry.call(this, i, t), this.type = "TextGeometry"
    }, THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype), THREE.TextGeometry.prototype.constructor = THREE.TextGeometry, THREE.TorusGeometry = function(e, t, i, r, n) {
        THREE.Geometry.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: r,
            arc: n
        }, e = e || 100, t = t || 40, i = i || 8, r = r || 6, n = n || 2 * Math.PI;
        for (var o = new THREE.Vector3, a = [], s = [], l = 0; i >= l; l++)
            for (var h = 0; r >= h; h++) {
                var u = h / r * n,
                    c = l / i * Math.PI * 2;
                o.x = e * Math.cos(u), o.y = e * Math.sin(u);
                var p = new THREE.Vector3;
                p.x = (e + t * Math.cos(c)) * Math.cos(u), p.y = (e + t * Math.cos(c)) * Math.sin(u), p.z = t * Math.sin(c), this.vertices.push(p), a.push(new THREE.Vector2(h / r, l / i)), s.push(p.clone().sub(o).normalize())
            }
        for (l = 1; i >= l; l++)
            for (h = 1; r >= h; h++) e = (r + 1) * l + h - 1, t = (r + 1) * (l - 1) + h - 1, n = (r + 1) * (l - 1) + h, o = (r + 1) * l + h, u = new THREE.Face3(e, t, o, [s[e].clone(), s[t].clone(), s[o].clone()]), this.faces.push(u), this.faceVertexUvs[0].push([a[e].clone(), a[t].clone(), a[o].clone()]), u = new THREE.Face3(t, n, o, [s[t].clone(), s[n].clone(), s[o].clone()]), this.faces.push(u), this.faceVertexUvs[0].push([a[t].clone(), a[n].clone(), a[o].clone()]);
        this.computeFaceNormals()
    }, THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry, THREE.TorusKnotGeometry = function(e, t, i, r, n, o, a) {
        function s(e, t, i, r, n) {
            var o = Math.cos(e),
                a = Math.sin(e);
            return e *= t / i, t = Math.cos(e), o *= r * (2 + t) * .5, a = r * (2 + t) * a * .5, r = n * r * Math.sin(e) * .5, new THREE.Vector3(o, a, r)
        }
        THREE.Geometry.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: r,
            p: n,
            q: o,
            heightScale: a
        }, e = e || 100, t = t || 40, i = i || 64, r = r || 8, n = n || 2, o = o || 3, a = a || 1;
        for (var l = Array(i), h = new THREE.Vector3, u = new THREE.Vector3, c = new THREE.Vector3, p = 0; i > p; ++p) {
            l[p] = Array(r);
            var d = p / i * 2 * n * Math.PI,
                f = s(d, o, n, e, a),
                d = s(d + .01, o, n, e, a);
            for (h.subVectors(d, f), u.addVectors(d, f), c.crossVectors(h, u), u.crossVectors(c, h), c.normalize(), u.normalize(), d = 0; r > d; ++d) {
                var m = d / r * 2 * Math.PI,
                    E = -t * Math.cos(m),
                    m = t * Math.sin(m),
                    v = new THREE.Vector3;
                v.x = f.x + E * u.x + m * c.x, v.y = f.y + E * u.y + m * c.y, v.z = f.z + E * u.z + m * c.z, l[p][d] = this.vertices.push(v) - 1
            }
        }
        for (p = 0; i > p; ++p)
            for (d = 0; r > d; ++d) n = (p + 1) % i, o = (d + 1) % r, e = l[p][d], t = l[n][d], n = l[n][o], o = l[p][o], a = new THREE.Vector2(p / i, d / r), h = new THREE.Vector2((p + 1) / i, d / r), u = new THREE.Vector2((p + 1) / i, (d + 1) / r), c = new THREE.Vector2(p / i, (d + 1) / r), this.faces.push(new THREE.Face3(e, t, o)), this.faceVertexUvs[0].push([a, h, c]), this.faces.push(new THREE.Face3(t, n, o)), this.faceVertexUvs[0].push([h.clone(), u, c.clone()]);
        this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry, THREE.TubeGeometry = function(e, t, i, r, n, o) {
        THREE.Geometry.call(this), this.type = "TubeGeometry", this.parameters = {
            path: e,
            segments: t,
            radius: i,
            radialSegments: r,
            closed: n
        }, t = t || 64, i = i || 1, r = r || 8, n = n || !1, o = o || THREE.TubeGeometry.NoTaper;
        var a = [],
            s, l, h = t + 1,
            u, c, p, d, f, m = new THREE.Vector3,
            E, v, g;
        for (E = new THREE.TubeGeometry.FrenetFrames(e, t, n), v = E.normals, g = E.binormals, this.tangents = E.tangents, this.normals = v, this.binormals = g, E = 0; h > E; E++)
            for (a[E] = [], u = E / (h - 1), f = e.getPointAt(u), s = v[E], l = g[E], p = i * o(u), u = 0; r > u; u++) c = u / r * 2 * Math.PI, d = -p * Math.cos(c), c = p * Math.sin(c), m.copy(f), m.x += d * s.x + c * l.x, m.y += d * s.y + c * l.y, m.z += d * s.z + c * l.z, a[E][u] = this.vertices.push(new THREE.Vector3(m.x, m.y, m.z)) - 1;
        for (E = 0; t > E; E++)
            for (u = 0; r > u; u++) o = n ? (E + 1) % t : E + 1, h = (u + 1) % r, e = a[E][u], i = a[o][u], o = a[o][h], h = a[E][h], m = new THREE.Vector2(E / t, u / r), v = new THREE.Vector2((E + 1) / t, u / r), g = new THREE.Vector2((E + 1) / t, (u + 1) / r), s = new THREE.Vector2(E / t, (u + 1) / r), this.faces.push(new THREE.Face3(e, i, h)), this.faceVertexUvs[0].push([m, v, s]), this.faces.push(new THREE.Face3(i, o, h)), this.faceVertexUvs[0].push([v.clone(), g, s.clone()]);
        this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry, THREE.TubeGeometry.NoTaper = function(e) {
        return 1
    }, THREE.TubeGeometry.SinusoidalTaper = function(e) {
        return Math.sin(Math.PI * e)
    }, THREE.TubeGeometry.FrenetFrames = function(e, t, i) {
        var r = new THREE.Vector3,
            n = [],
            o = [],
            a = [],
            s = new THREE.Vector3,
            l = new THREE.Matrix4;
        t += 1;
        var h, u, c;
        for (this.tangents = n, this.normals = o, this.binormals = a, h = 0; t > h; h++) u = h / (t - 1), n[h] = e.getTangentAt(u), n[h].normalize();
        for (o[0] = new THREE.Vector3, a[0] = new THREE.Vector3, e = Number.MAX_VALUE, h = Math.abs(n[0].x), u = Math.abs(n[0].y), c = Math.abs(n[0].z), e >= h && (e = h, r.set(1, 0, 0)), e >= u && (e = u, r.set(0, 1, 0)), e >= c && r.set(0, 0, 1), s.crossVectors(n[0], r).normalize(), o[0].crossVectors(n[0], s), a[0].crossVectors(n[0], o[0]), h = 1; t > h; h++) o[h] = o[h - 1].clone(), a[h] = a[h - 1].clone(), s.crossVectors(n[h - 1], n[h]), 1e-4 < s.length() && (s.normalize(), r = Math.acos(THREE.Math.clamp(n[h - 1].dot(n[h]), -1, 1)), o[h].applyMatrix4(l.makeRotationAxis(s, r))), a[h].crossVectors(n[h], o[h]);
        if (i)
            for (r = Math.acos(THREE.Math.clamp(o[0].dot(o[t - 1]), -1, 1)), r /= t - 1, 0 < n[0].dot(s.crossVectors(o[0], o[t - 1])) && (r = -r), h = 1; t > h; h++) o[h].applyMatrix4(l.makeRotationAxis(n[h], r * h)), a[h].crossVectors(n[h], o[h])
    }, THREE.PolyhedronGeometry = function(e, t, i, r) {
        function n(e) {
            var t = e.normalize().clone();
            t.index = l.vertices.push(t) - 1;
            var i = Math.atan2(e.z, -e.x) / 2 / Math.PI + .5;
            return e = Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5, t.uv = new THREE.Vector2(i, 1 - e), t
        }

        function o(e, t, i) {
            var r = new THREE.Face3(e.index, t.index, i.index, [e.clone(), t.clone(), i.clone()]);
            l.faces.push(r), E.copy(e).add(t).add(i).divideScalar(3), r = Math.atan2(E.z, -E.x), l.faceVertexUvs[0].push([s(e.uv, e, r), s(t.uv, t, r), s(i.uv, i, r)])
        }

        function a(e, t) {
            for (var i = Math.pow(2, t), r = n(l.vertices[e.a]), a = n(l.vertices[e.b]), s = n(l.vertices[e.c]), h = [], u = 0; i >= u; u++) {
                h[u] = [];
                for (var c = n(r.clone().lerp(s, u / i)), p = n(a.clone().lerp(s, u / i)), d = i - u, f = 0; d >= f; f++) h[u][f] = 0 == f && u == i ? c : n(c.clone().lerp(p, f / d))
            }
            for (u = 0; i > u; u++)
                for (f = 0; 2 * (i - u) - 1 > f; f++) r = Math.floor(f / 2), 0 == f % 2 ? o(h[u][r + 1], h[u + 1][r], h[u][r]) : o(h[u][r + 1], h[u + 1][r + 1], h[u + 1][r])
        }

        function s(e, t, i) {
            return 0 > i && 1 === e.x && (e = new THREE.Vector2(e.x - 1, e.y)), 0 === t.x && 0 === t.z && (e = new THREE.Vector2(i / 2 / Math.PI + .5, e.y)), e.clone()
        }
        THREE.Geometry.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: r
        }, i = i || 1, r = r || 0;
        for (var l = this, h = 0, u = e.length; u > h; h += 3) n(new THREE.Vector3(e[h], e[h + 1], e[h + 2]));
        e = this.vertices;
        for (var c = [], p = h = 0, u = t.length; u > h; h += 3, p++) {
            var d = e[t[h]],
                f = e[t[h + 1]],
                m = e[t[h + 2]];
            c[p] = new THREE.Face3(d.index, f.index, m.index, [d.clone(), f.clone(), m.clone()])
        }
        for (var E = new THREE.Vector3, h = 0, u = c.length; u > h; h++) a(c[h], r);
        for (h = 0, u = this.faceVertexUvs[0].length; u > h; h++) t = this.faceVertexUvs[0][h], r = t[0].x, e = t[1].x, c = t[2].x, p = Math.max(r, Math.max(e, c)), d = Math.min(r, Math.min(e, c)), p > .9 && .1 > d && (.2 > r && (t[0].x += 1), .2 > e && (t[1].x += 1), .2 > c && (t[2].x += 1));
        for (h = 0, u = this.vertices.length; u > h; h++) this.vertices[h].multiplyScalar(i);
        this.mergeVertices(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, i)
    }, THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry, THREE.DodecahedronGeometry = function(e, t) {
        this.parameters = {
            radius: e,
            detail: t
        };
        var i = (1 + Math.sqrt(5)) / 2,
            r = 1 / i;
        THREE.PolyhedronGeometry.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t)
    }, THREE.DodecahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry, THREE.IcosahedronGeometry = function(e, t) {
        var i = (1 + Math.sqrt(5)) / 2;
        THREE.PolyhedronGeometry.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }, THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry, THREE.OctahedronGeometry = function(e, t) {
        this.parameters = {
            radius: e,
            detail: t
        }, THREE.PolyhedronGeometry.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }, THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry, THREE.TetrahedronGeometry = function(e, t) {
        THREE.PolyhedronGeometry.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }, THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry, THREE.ParametricGeometry = function(e, t, i) {
        THREE.Geometry.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: i
        };
        var r = this.vertices,
            n = this.faces,
            o = this.faceVertexUvs[0],
            a, s, l, h, u = t + 1;
        for (a = 0; i >= a; a++)
            for (h = a / i, s = 0; t >= s; s++) l = s / t, l = e(l, h), r.push(l);
        var c, p, d, f;
        for (a = 0; i > a; a++)
            for (s = 0; t > s; s++) e = a * u + s, r = a * u + s + 1, h = (a + 1) * u + s + 1, l = (a + 1) * u + s, c = new THREE.Vector2(s / t, a / i), p = new THREE.Vector2((s + 1) / t, a / i), d = new THREE.Vector2((s + 1) / t, (a + 1) / i), f = new THREE.Vector2(s / t, (a + 1) / i), n.push(new THREE.Face3(e, r, l)), o.push([c, p, f]), n.push(new THREE.Face3(r, h, l)), o.push([p.clone(), d, f.clone()]);
        this.computeFaceNormals(), this.computeVertexNormals()
    }, THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry, THREE.AxisHelper = function(e) {
        e = e || 1;
        var t = new Float32Array([0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]),
            i = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]);
        e = new THREE.BufferGeometry, e.addAttribute("position", new THREE.BufferAttribute(t, 3)), e.addAttribute("color", new THREE.BufferAttribute(i, 3)), t = new THREE.LineBasicMaterial({
            vertexColors: THREE.VertexColors
        }), THREE.Line.call(this, e, t, THREE.LinePieces)
    }, THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype), THREE.AxisHelper.prototype.constructor = THREE.AxisHelper, THREE.ArrowHelper = function() {
        var e = new THREE.Geometry;
        e.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
        var t = new THREE.CylinderGeometry(0, .5, 1, 5, 1);
        return t.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0)),
            function(i, r, n, o, a, s) {
                THREE.Object3D.call(this), void 0 === o && (o = 16776960), void 0 === n && (n = 1), void 0 === a && (a = .2 * n), void 0 === s && (s = .2 * a), this.position.copy(r), this.line = new THREE.Line(e, new THREE.LineBasicMaterial({
                    color: o
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new THREE.Mesh(t, new THREE.MeshBasicMaterial({
                    color: o
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(i), this.setLength(n, a, s)
            }
    }(), THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper, THREE.ArrowHelper.prototype.setDirection = function() {
        var e = new THREE.Vector3,
            t;
        return function(i) {
            .99999 < i.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > i.y ? this.quaternion.set(1, 0, 0, 0) : (e.set(i.z, 0, -i.x).normalize(), t = Math.acos(i.y), this.quaternion.setFromAxisAngle(e, t))
        }
    }(), THREE.ArrowHelper.prototype.setLength = function(e, t, i) {
        void 0 === t && (t = .2 * e), void 0 === i && (i = .2 * t), this.line.scale.set(1, e - t, 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix()
    }, THREE.ArrowHelper.prototype.setColor = function(e) {
        this.line.material.color.set(e), this.cone.material.color.set(e)
    }, THREE.BoxHelper = function(e) {
        var t = new THREE.BufferGeometry;
        t.addAttribute("position", new THREE.BufferAttribute(new Float32Array(72), 3)), THREE.Line.call(this, t, new THREE.LineBasicMaterial({
            color: 16776960
        }), THREE.LinePieces), void 0 !== e && this.update(e)
    }, THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype), THREE.BoxHelper.prototype.constructor = THREE.BoxHelper, THREE.BoxHelper.prototype.update = function(e) {
        var t = e.geometry;
        null === t.boundingBox && t.computeBoundingBox();
        var i = t.boundingBox.min,
            t = t.boundingBox.max,
            r = this.geometry.attributes.position.array;
        r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = i.x, r[4] = t.y, r[5] = t.z, r[6] = i.x, r[7] = t.y, r[8] = t.z, r[9] = i.x, r[10] = i.y, r[11] = t.z, r[12] = i.x, r[13] = i.y, r[14] = t.z, r[15] = t.x, r[16] = i.y, r[17] = t.z, r[18] = t.x, r[19] = i.y, r[20] = t.z, r[21] = t.x, r[22] = t.y, r[23] = t.z, r[24] = t.x, r[25] = t.y, r[26] = i.z, r[27] = i.x, r[28] = t.y, r[29] = i.z, r[30] = i.x, r[31] = t.y, r[32] = i.z, r[33] = i.x, r[34] = i.y, r[35] = i.z, r[36] = i.x, r[37] = i.y, r[38] = i.z, r[39] = t.x, r[40] = i.y, r[41] = i.z, r[42] = t.x, r[43] = i.y, r[44] = i.z, r[45] = t.x, r[46] = t.y, r[47] = i.z, r[48] = t.x, r[49] = t.y, r[50] = t.z, r[51] = t.x, r[52] = t.y, r[53] = i.z, r[54] = i.x, r[55] = t.y, r[56] = t.z, r[57] = i.x, r[58] = t.y, r[59] = i.z, r[60] = i.x, r[61] = i.y, r[62] = t.z, r[63] = i.x, r[64] = i.y, r[65] = i.z, r[66] = t.x, r[67] = i.y, r[68] = t.z, r[69] = t.x, r[70] = i.y, r[71] = i.z, this.geometry.attributes.position.needsUpdate = !0, this.geometry.computeBoundingSphere(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
    }, THREE.BoundingBoxHelper = function(e, t) {
        var i = void 0 !== t ? t : 8947848;
        this.object = e, this.box = new THREE.Box3, THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
            color: i,
            wireframe: !0
        }))
    }, THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper, THREE.BoundingBoxHelper.prototype.update = function() {
        this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position)
    }, THREE.CameraHelper = function(e) {
        function t(e, t, r) {
            i(e, r), i(t, r)
        }

        function i(e, t) {
            r.vertices.push(new THREE.Vector3), r.colors.push(new THREE.Color(t)), void 0 === o[e] && (o[e] = []), o[e].push(r.vertices.length - 1)
        }
        var r = new THREE.Geometry,
            n = new THREE.LineBasicMaterial({
                color: 16777215,
                vertexColors: THREE.FaceColors
            }),
            o = {};
        t("n1", "n2", 16755200), t("n2", "n4", 16755200), t("n4", "n3", 16755200), t("n3", "n1", 16755200), t("f1", "f2", 16755200), t("f2", "f4", 16755200), t("f4", "f3", 16755200), t("f3", "f1", 16755200), t("n1", "f1", 16755200), t("n2", "f2", 16755200), t("n3", "f3", 16755200), t("n4", "f4", 16755200), t("p", "n1", 16711680), t("p", "n2", 16711680), t("p", "n3", 16711680), t("p", "n4", 16711680), t("u1", "u2", 43775), t("u2", "u3", 43775), t("u3", "u1", 43775), t("c", "t", 16777215), t("p", "c", 3355443), t("cn1", "cn2", 3355443), t("cn3", "cn4", 3355443), t("cf1", "cf2", 3355443), t("cf3", "cf4", 3355443), THREE.Line.call(this, r, n, THREE.LinePieces), this.camera = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
    }, THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype), THREE.CameraHelper.prototype.constructor = THREE.CameraHelper, THREE.CameraHelper.prototype.update = function() {
        var e, t, i = new THREE.Vector3,
            r = new THREE.Camera,
            n = function(n, o, a, s) {
                if (i.set(o, a, s).unproject(r), n = t[n], void 0 !== n)
                    for (o = 0, a = n.length; a > o; o++) e.vertices[n[o]].copy(i)
            };
        return function() {
            e = this.geometry, t = this.pointMap, r.projectionMatrix.copy(this.camera.projectionMatrix), n("c", 0, 0, -1), n("t", 0, 0, 1), n("n1", -1, -1, -1), n("n2", 1, -1, -1), n("n3", -1, 1, -1), n("n4", 1, 1, -1), n("f1", -1, -1, 1), n("f2", 1, -1, 1), n("f3", -1, 1, 1), n("f4", 1, 1, 1), n("u1", .7, 1.1, -1), n("u2", -.7, 1.1, -1), n("u3", 0, 2, -1), n("cf1", -1, 0, 1), n("cf2", 1, 0, 1), n("cf3", 0, -1, 1), n("cf4", 0, 1, 1), n("cn1", -1, 0, -1), n("cn2", 1, 0, -1), n("cn3", 0, -1, -1), n("cn4", 0, 1, -1), e.verticesNeedUpdate = !0
        }
    }(), THREE.DirectionalLightHelper = function(e, t) {
        THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, t = t || 1;
        var i = new THREE.Geometry;
        i.vertices.push(new THREE.Vector3(-t, t, 0), new THREE.Vector3(t, t, 0), new THREE.Vector3(t, -t, 0), new THREE.Vector3(-t, -t, 0), new THREE.Vector3(-t, t, 0));
        var r = new THREE.LineBasicMaterial({
            fog: !1
        });
        r.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.lightPlane = new THREE.Line(i, r), this.add(this.lightPlane), i = new THREE.Geometry, i.vertices.push(new THREE.Vector3, new THREE.Vector3), r = new THREE.LineBasicMaterial({
            fog: !1
        }), r.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine = new THREE.Line(i, r), this.add(this.targetLine), this.update()
    }, THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper, THREE.DirectionalLightHelper.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }, THREE.DirectionalLightHelper.prototype.update = function() {
        var e = new THREE.Vector3,
            t = new THREE.Vector3,
            i = new THREE.Vector3;
        return function() {
            e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(t, e), this.lightPlane.lookAt(i), this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine.geometry.vertices[1].copy(i), this.targetLine.geometry.verticesNeedUpdate = !0, this.targetLine.material.color.copy(this.lightPlane.material.color)
        }
    }(), THREE.EdgesHelper = function(e, t, i) {
        t = void 0 !== t ? t : 16777215, i = Math.cos(THREE.Math.degToRad(void 0 !== i ? i : 1));
        var r = [0, 0],
            n = {},
            o = function(e, t) {
                return e - t
            },
            a = ["a", "b", "c"],
            s = new THREE.BufferGeometry,
            l;
        e.geometry instanceof THREE.BufferGeometry ? (l = new THREE.Geometry, l.fromBufferGeometry(e.geometry)) : l = e.geometry.clone(), l.mergeVertices(), l.computeFaceNormals();
        var h = l.vertices;
        l = l.faces;
        for (var u = 0, c = 0, p = l.length; p > c; c++)
            for (var d = l[c], f = 0; 3 > f; f++) {
                r[0] = d[a[f]], r[1] = d[a[(f + 1) % 3]], r.sort(o);
                var m = r.toString();
                void 0 === n[m] ? (n[m] = {
                    vert1: r[0],
                    vert2: r[1],
                    face1: c,
                    face2: void 0
                }, u++) : n[m].face2 = c
            }
        r = new Float32Array(6 * u), o = 0;
        for (m in n) a = n[m], (void 0 === a.face2 || l[a.face1].normal.dot(l[a.face2].normal) <= i) && (u = h[a.vert1], r[o++] = u.x, r[o++] = u.y, r[o++] = u.z, u = h[a.vert2], r[o++] = u.x, r[o++] = u.y, r[o++] = u.z);
        s.addAttribute("position", new THREE.BufferAttribute(r, 3)), THREE.Line.call(this, s, new THREE.LineBasicMaterial({
            color: t
        }), THREE.LinePieces), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
    }, THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype), THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper, THREE.FaceNormalsHelper = function(e, t, i, r) {
        this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== i ? i : 16776960, r = void 0 !== r ? r : 1, t = new THREE.Geometry, i = 0;
        for (var n = this.object.geometry.faces.length; n > i; i++) t.vertices.push(new THREE.Vector3, new THREE.Vector3);
        THREE.Line.call(this, t, new THREE.LineBasicMaterial({
            color: e,
            linewidth: r
        }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3, this.update()
    }, THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper, THREE.FaceNormalsHelper.prototype.update = function() {
        var e = this.geometry.vertices,
            t = this.object,
            i = t.geometry.vertices,
            r = t.geometry.faces,
            n = t.matrixWorld;
        t.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(n);
        for (var o = t = 0, a = r.length; a > t; t++, o += 2) {
            var s = r[t];
            e[o].copy(i[s.a]).add(i[s.b]).add(i[s.c]).divideScalar(3).applyMatrix4(n), e[o + 1].copy(s.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(e[o])
        }
        return this.geometry.verticesNeedUpdate = !0, this
    }, THREE.GridHelper = function(e, t) {
        var i = new THREE.Geometry,
            r = new THREE.LineBasicMaterial({
                vertexColors: THREE.VertexColors
            });
        this.color1 = new THREE.Color(4473924), this.color2 = new THREE.Color(8947848);
        for (var n = -e; e >= n; n += t) {
            i.vertices.push(new THREE.Vector3(-e, 0, n), new THREE.Vector3(e, 0, n), new THREE.Vector3(n, 0, -e), new THREE.Vector3(n, 0, e));
            var o = 0 === n ? this.color1 : this.color2;
            i.colors.push(o, o, o, o)
        }
        THREE.Line.call(this, i, r, THREE.LinePieces)
    }, THREE.GridHelper.prototype = Object.create(THREE.Line.prototype), THREE.GridHelper.prototype.constructor = THREE.GridHelper, THREE.GridHelper.prototype.setColors = function(e, t) {
        this.color1.set(e), this.color2.set(t), this.geometry.colorsNeedUpdate = !0
    }, THREE.HemisphereLightHelper = function(e, t) {
        THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.colors = [new THREE.Color, new THREE.Color];
        var i = new THREE.SphereGeometry(t, 4, 2);
        i.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
        for (var r = 0; 8 > r; r++) i.faces[r].color = this.colors[4 > r ? 0 : 1];
        r = new THREE.MeshBasicMaterial({
            vertexColors: THREE.FaceColors,
            wireframe: !0
        }), this.lightSphere = new THREE.Mesh(i, r), this.add(this.lightSphere), this.update()
    }, THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper, THREE.HemisphereLightHelper.prototype.dispose = function() {
        this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose()
    }, THREE.HemisphereLightHelper.prototype.update = function() {
        var e = new THREE.Vector3;
        return function() {
            this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), this.lightSphere.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate()), this.lightSphere.geometry.colorsNeedUpdate = !0
        }
    }(), THREE.PointLightHelper = function(e, t) {
        this.light = e, this.light.updateMatrixWorld();
        var i = new THREE.SphereGeometry(t, 4, 2),
            r = new THREE.MeshBasicMaterial({
                wireframe: !0,
                fog: !1
            });
        r.color.copy(this.light.color).multiplyScalar(this.light.intensity), THREE.Mesh.call(this, i, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1
    }, THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper, THREE.PointLightHelper.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose()
    }, THREE.PointLightHelper.prototype.update = function() {
        this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
    }, THREE.SkeletonHelper = function(e) {
        this.bones = this.getBoneList(e);
        for (var t = new THREE.Geometry, i = 0; i < this.bones.length; i++) this.bones[i].parent instanceof THREE.Bone && (t.vertices.push(new THREE.Vector3), t.vertices.push(new THREE.Vector3), t.colors.push(new THREE.Color(0, 0, 1)), t.colors.push(new THREE.Color(0, 1, 0)));
        i = new THREE.LineBasicMaterial({
            vertexColors: THREE.VertexColors,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }), THREE.Line.call(this, t, i, THREE.LinePieces), this.root = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }, THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype), THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper, THREE.SkeletonHelper.prototype.getBoneList = function(e) {
        var t = [];
        e instanceof THREE.Bone && t.push(e);
        for (var i = 0; i < e.children.length; i++) t.push.apply(t, this.getBoneList(e.children[i]));
        return t
    }, THREE.SkeletonHelper.prototype.update = function() {
        for (var e = this.geometry, t = (new THREE.Matrix4).getInverse(this.root.matrixWorld), i = new THREE.Matrix4, r = 0, n = 0; n < this.bones.length; n++) {
            var o = this.bones[n];
            o.parent instanceof THREE.Bone && (i.multiplyMatrices(t, o.matrixWorld), e.vertices[r].setFromMatrixPosition(i), i.multiplyMatrices(t, o.parent.matrixWorld), e.vertices[r + 1].setFromMatrixPosition(i), r += 2)
        }
        e.verticesNeedUpdate = !0, e.computeBoundingSphere()
    }, THREE.SpotLightHelper = function(e) {
        THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, e = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0), e.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0)), e.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
        var t = new THREE.MeshBasicMaterial({
            wireframe: !0,
            fog: !1
        });
        this.cone = new THREE.Mesh(e, t), this.add(this.cone), this.update()
    }, THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper, THREE.SpotLightHelper.prototype.dispose = function() {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, THREE.SpotLightHelper.prototype.update = function() {
        var e = new THREE.Vector3,
            t = new THREE.Vector3;
        return function() {
            var i = this.light.distance ? this.light.distance : 1e4,
                r = i * Math.tan(this.light.angle);
            this.cone.scale.set(r, r, i), e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t.sub(e)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
        }
    }(), THREE.VertexNormalsHelper = function(e, t, i, r) {
        this.object = e, this.size = void 0 !== t ? t : 1, t = void 0 !== i ? i : 16711680, r = void 0 !== r ? r : 1, i = new THREE.Geometry, e = e.geometry.faces;
        for (var n = 0, o = e.length; o > n; n++)
            for (var a = 0, s = e[n].vertexNormals.length; s > a; a++) i.vertices.push(new THREE.Vector3, new THREE.Vector3);
        THREE.Line.call(this, i, new THREE.LineBasicMaterial({
            color: t,
            linewidth: r
        }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3, this.update()
    }, THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper, THREE.VertexNormalsHelper.prototype.update = function(e) {
        var t = new THREE.Vector3;
        return function(e) {
            e = ["a", "b", "c", "d"], this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
            for (var i = this.geometry.vertices, r = this.object.geometry.vertices, n = this.object.geometry.faces, o = this.object.matrixWorld, a = 0, s = 0, l = n.length; l > s; s++)
                for (var h = n[s], u = 0, c = h.vertexNormals.length; c > u; u++) {
                    var p = h.vertexNormals[u];
                    i[a].copy(r[h[e[u]]]).applyMatrix4(o), t.copy(p).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size), t.add(i[a]), a += 1, i[a].copy(t), a += 1
                }
            return this.geometry.verticesNeedUpdate = !0, this
        }
    }(), THREE.VertexTangentsHelper = function(e, t, i, r) {
        this.object = e, this.size = void 0 !== t ? t : 1, t = void 0 !== i ? i : 255, r = void 0 !== r ? r : 1, i = new THREE.Geometry, e = e.geometry.faces;
        for (var n = 0, o = e.length; o > n; n++)
            for (var a = 0, s = e[n].vertexTangents.length; s > a; a++) i.vertices.push(new THREE.Vector3), i.vertices.push(new THREE.Vector3);
        THREE.Line.call(this, i, new THREE.LineBasicMaterial({
            color: t,
            linewidth: r
        }), THREE.LinePieces), this.matrixAutoUpdate = !1, this.update()
    }, THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper, THREE.VertexTangentsHelper.prototype.update = function(e) {
        var t = new THREE.Vector3;
        return function(e) {
            e = ["a", "b", "c", "d"], this.object.updateMatrixWorld(!0);
            for (var i = this.geometry.vertices, r = this.object.geometry.vertices, n = this.object.geometry.faces, o = this.object.matrixWorld, a = 0, s = 0, l = n.length; l > s; s++)
                for (var h = n[s], u = 0, c = h.vertexTangents.length; c > u; u++) {
                    var p = h.vertexTangents[u];
                    i[a].copy(r[h[e[u]]]).applyMatrix4(o), t.copy(p).transformDirection(o).multiplyScalar(this.size), t.add(i[a]), a += 1, i[a].copy(t), a += 1
                }
            return this.geometry.verticesNeedUpdate = !0, this
        }
    }(), THREE.WireframeHelper = function(e, t) {
        var i = void 0 !== t ? t : 16777215,
            r = [0, 0],
            n = {},
            o = function(e, t) {
                return e - t
            },
            a = ["a", "b", "c"],
            s = new THREE.BufferGeometry;
        if (e.geometry instanceof THREE.Geometry) {
            for (var l = e.geometry.vertices, h = e.geometry.faces, u = 0, c = new Uint32Array(6 * h.length), p = 0, d = h.length; d > p; p++)
                for (var f = h[p], m = 0; 3 > m; m++) {
                    r[0] = f[a[m]], r[1] = f[a[(m + 1) % 3]], r.sort(o);
                    var E = r.toString();
                    void 0 === n[E] && (c[2 * u] = r[0], c[2 * u + 1] = r[1], n[E] = !0, u++)
                }
            for (r = new Float32Array(6 * u), p = 0, d = u; d > p; p++)
                for (m = 0; 2 > m; m++) u = l[c[2 * p + m]], a = 6 * p + 3 * m, r[a + 0] = u.x, r[a + 1] = u.y, r[a + 2] = u.z;
            s.addAttribute("position", new THREE.BufferAttribute(r, 3))
        } else if (e.geometry instanceof THREE.BufferGeometry) {
            if (void 0 !== e.geometry.attributes.index) {
                l = e.geometry.attributes.position.array, d = e.geometry.attributes.index.array, h = e.geometry.drawcalls, u = 0, 0 === h.length && (h = [{
                    count: d.length,
                    index: 0,
                    start: 0
                }]);
                for (var c = new Uint32Array(2 * d.length), f = 0, v = h.length; v > f; ++f)
                    for (var m = h[f].start, E = h[f].count, a = h[f].index, p = m, g = m + E; g > p; p += 3)
                        for (m = 0; 3 > m; m++) r[0] = a + d[p + m], r[1] = a + d[p + (m + 1) % 3], r.sort(o), E = r.toString(), void 0 === n[E] && (c[2 * u] = r[0], c[2 * u + 1] = r[1], n[E] = !0, u++);
                for (r = new Float32Array(6 * u), p = 0, d = u; d > p; p++)
                    for (m = 0; 2 > m; m++) a = 6 * p + 3 * m, u = 3 * c[2 * p + m], r[a + 0] = l[u], r[a + 1] = l[u + 1], r[a + 2] = l[u + 2]
            } else
                for (l = e.geometry.attributes.position.array, u = l.length / 3, c = u / 3, r = new Float32Array(6 * u), p = 0, d = c; d > p; p++)
                    for (m = 0; 3 > m; m++) a = 18 * p + 6 * m, c = 9 * p + 3 * m, r[a + 0] = l[c], r[a + 1] = l[c + 1], r[a + 2] = l[c + 2], u = 9 * p + (m + 1) % 3 * 3, r[a + 3] = l[u], r[a + 4] = l[u + 1], r[a + 5] = l[u + 2];
            s.addAttribute("position", new THREE.BufferAttribute(r, 3))
        }
        THREE.Line.call(this, s, new THREE.LineBasicMaterial({
            color: i
        }), THREE.LinePieces), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
    }, THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype), THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper, THREE.ImmediateRenderObject = function() {
        THREE.Object3D.call(this), this.render = function(e) {}
    }, THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype), THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject, THREE.MorphBlendMesh = function(e, t) {
        THREE.Mesh.call(this, e, t), this.animationsMap = {}, this.animationsList = [];
        var i = this.geometry.morphTargets.length;
        this.createAnimation("__default", 0, i - 1, i / 1), this.setAnimationWeight("__default", 1)
    }, THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh, THREE.MorphBlendMesh.prototype.createAnimation = function(e, t, i, r) {
        t = {
            startFrame: t,
            endFrame: i,
            length: i - t + 1,
            fps: r,
            duration: (i - t) / r,
            lastFrame: 0,
            currentFrame: 0,
            active: !1,
            time: 0,
            direction: 1,
            weight: 1,
            directionBackwards: !1,
            mirroredLoop: !1
        }, this.animationsMap[e] = t, this.animationsList.push(t)
    }, THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(e) {
        for (var t = /([a-z]+)_?(\d+)/, i, r = {}, n = this.geometry, o = 0, a = n.morphTargets.length; a > o; o++) {
            var s = n.morphTargets[o].name.match(t);
            if (s && 1 < s.length) {
                var l = s[1];
                r[l] || (r[l] = {
                    start: 1 / 0,
                    end: -1 / 0
                }), s = r[l], o < s.start && (s.start = o), o > s.end && (s.end = o), i || (i = l)
            }
        }
        for (l in r) s = r[l], this.createAnimation(l, s.start, s.end, e);
        this.firstAnimation = i
    }, THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(e) {
        (e = this.animationsMap[e]) && (e.direction = 1, e.directionBackwards = !1)
    }, THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(e) {
        (e = this.animationsMap[e]) && (e.direction = -1, e.directionBackwards = !0)
    }, THREE.MorphBlendMesh.prototype.setAnimationFPS = function(e, t) {
        var i = this.animationsMap[e];
        i && (i.fps = t, i.duration = (i.end - i.start) / i.fps)
    }, THREE.MorphBlendMesh.prototype.setAnimationDuration = function(e, t) {
        var i = this.animationsMap[e];
        i && (i.duration = t, i.fps = (i.end - i.start) / i.duration)
    }, THREE.MorphBlendMesh.prototype.setAnimationWeight = function(e, t) {
        var i = this.animationsMap[e];
        i && (i.weight = t)
    }, THREE.MorphBlendMesh.prototype.setAnimationTime = function(e, t) {
        var i = this.animationsMap[e];
        i && (i.time = t)
    }, THREE.MorphBlendMesh.prototype.getAnimationTime = function(e) {
        var t = 0;
        return (e = this.animationsMap[e]) && (t = e.time), t
    }, THREE.MorphBlendMesh.prototype.getAnimationDuration = function(e) {
        var t = -1;
        return (e = this.animationsMap[e]) && (t = e.duration), t
    }, THREE.MorphBlendMesh.prototype.playAnimation = function(e) {
        var t = this.animationsMap[e];
        t ? (t.time = 0, t.active = !0) : THREE.warn("THREE.MorphBlendMesh: animation[" + e + "] undefined in .playAnimation()")
    }, THREE.MorphBlendMesh.prototype.stopAnimation = function(e) {
        (e = this.animationsMap[e]) && (e.active = !1)
    }, THREE.MorphBlendMesh.prototype.update = function(e) {
        for (var t = 0, i = this.animationsList.length; i > t; t++) {
            var r = this.animationsList[t];
            if (r.active) {
                var n = r.duration / r.length;
                r.time += r.direction * e, r.mirroredLoop ? (r.time > r.duration || 0 > r.time) && (r.direction *= -1, r.time > r.duration && (r.time = r.duration, r.directionBackwards = !0), 0 > r.time && (r.time = 0, r.directionBackwards = !1)) : (r.time %= r.duration, 0 > r.time && (r.time += r.duration));
                var o = r.startFrame + THREE.Math.clamp(Math.floor(r.time / n), 0, r.length - 1),
                    a = r.weight;
                o !== r.currentFrame && (this.morphTargetInfluences[r.lastFrame] = 0, this.morphTargetInfluences[r.currentFrame] = 1 * a, this.morphTargetInfluences[o] = 0, r.lastFrame = r.currentFrame, r.currentFrame = o), n = r.time % n / n, r.directionBackwards && (n = 1 - n), this.morphTargetInfluences[r.currentFrame] = n * a, this.morphTargetInfluences[r.lastFrame] = (1 - n) * a
            }
        }
    };
var H = H || {};
H.vendor = /webkit/i.test(navigator.appVersion) ? "webkit" : /firefox/i.test(navigator.userAgent) ? "Moz" : "opera" in window ? "O" : navigator.userAgent.indexOf("Trident") > -1 ? "ms" : "", H.isIE9 = !1, H.isSafari = !1, -1 != navigator.userAgent.indexOf("Safari") && -1 == navigator.userAgent.indexOf("Chrome") && (H.isSafari = !0), H.soundExt = "Moz" == H.vendor ? ".ogg" : ".mp3", H.videoExt = "Moz" == H.vendor ? ".ogv" : ".mp4", H.createLink = function(e, t, i) {
    var r = document.createElement("a");
    r.setAttribute("href", t), i && r.setAttribute("target", i);
    var n = $(e).parent()[0];
    return n.removeChild(e), n.appendChild(r), r.appendChild(e), r
}, H.clear = function() {
    var e = document.createElement("div");
    return e.style.clear = "both", e
}, H.resizeToContainer = function(e, t, i, r, n, o) {
    var a, s, l = $(t).width(),
        h = $(t).height(),
        u = l / h,
        c = 1;
    o && (c = o), i > u ? (s = h * c, a = s * i) : (a = l * c, s = a / i), $(e).css("width", a + "px"), $(e).css("height", s + "px"), (1 == r || null == r) && $(e).css("left", (l - a) / 2 + "px"), (1 == n || null == n) && $(e).css("top", (h - s) / 2 + "px")
}, H.distance = function(e, t) {
    var i = e.x - t.x,
        r = e.y - t.y;
    return Math.sqrt(i * i + r * r)
}, H.Element = function(e) {
    e || (e = "div"), this.el = document.createElement(e), this.type = "el"
}, H.Element.prototype = {
    addStyle: function(e) {
        var t = this;
        this.styles || (this.styles = {});
        for (var i in e) t.el.style[i] = e[i], t.styles[i] = e[i];
        return this
    },
    addClass: function(e) {
        return this.el.setAttribute("class", e), this
    },
    add: function(e) {
        return this.el.appendChild(e.el ? e.el : e.mainEl ? e.mainEl.el : e), this
    },
    addTo: function(e) {
        return e.appendChild ? e.appendChild(this.el) : e.el.appendChild(this.el), this
    },
    width: function(e) {
        return this.el.style.width = "string" == typeof e ? e : e + "px", this
    },
    height: function(e) {
        return this.el.style.height = "string" == typeof e ? e : e + "px", this
    },
    resizeToContainer: function(e, t, i, r, n) {
        var o, a;
        e.el && (e = e.el);
        var s = $(e).width(),
            l = $(e).height(),
            h = s / l,
            u = 1;
        n && (u = n), t > h ? (a = l * u, o = a * t) : (o = s * u, a = o / t), $(this.el).css("width", o + "px"), $(this.el).css("height", a + "px"), (1 == i || null == i) && $(this.el).css("left", (s - o) / 2 + "px"), (1 == r || null == r) && $(this.el).css("top", (l - a) / 2 + "px")
    }
}, H.ImageElement = function(e) {
    this.el = new Image, this.el.src = e, this.type = "image"
}, H.ImageElement.prototype = Object.create(H.Element.prototype, {}), H.VideoElement = function(e) {
    this.el = document.createElement("video"), this.el.src = e
}, H.VideoElement.prototype = Object.create(H.Element.prototype, {});
var isMobile = {
    AndroidPhone: function() {
        return navigator.userAgent.match(/Android/i) && navigator.userAgent.match(/Mobile/i) ? !0 : !1
    },
    AndroidTablet: function() {
        return navigator.userAgent.match(/Android/i) && !navigator.userAgent.match(/Mobile/i) ? !0 : !1
    },
    BlackBerry: function() {
        return navigator.userAgent.match(/BlackBerry/i) ? !0 : !1
    },
    iPad: function() {
        return navigator.userAgent.match(/iPad/i) ? !0 : !1
    },
    iPhone: function() {
        return navigator.userAgent.match(/iPhone|iPod/i) ? !0 : !1
    },
    Windows: function() {
        return navigator.userAgent.match(/IEMobile/i) ? !0 : !1
    },
    any: function() {
        return isMobile.AndroidPhone() || isMobile.AndroidTablet() || isMobile.BlackBerry() || isMobile.iPad() || isMobile.Windows()
    }
};
isMobile.iPhone() || isMobile.BlackBerry() || isMobile.AndroidPhone() || isMobile.any();
try {
    jQuery.rsCSS3Easing && (jQuery.rsCSS3Easing.easeOutExpo = "cubic-bezier(0.165, 0.840, 0.440, 1.000)", jQuery.rsCSS3Easing.easeInOutExpo = "cubic-bezier(0.770, 0.000, 0.175, 1.000)")
} catch (e) {}
String.prototype.parseURL = function() {
    return this.replace(/[A-Za-z]+:\/\/[A-Za-z0-9-_]+\.[A-Za-z0-9-_:%&~\?\/.=]+/g, function(e) {
        return "<a href='" + e + "' target='_blank'>" + e + "</a>"
    })
}, String.prototype.parseUsername = function() {
    return this.replace(/[@]+[A-Za-z0-9-_]+/g, function(e) {
        var t = e.replace("@", "");
        return "<a href='http://twitter.com/" + t + "' target='_blank'>" + e + "</a>"
    })
}, String.prototype.parseTags = function() {
    return this.replace(/[#]+[A-Za-z0-9-_]+/g, function(e) {
        var t = e.replace("#", "%23");
        return "<a href='http://twitter.com/search?q=" + t + "&src=hash' target='_blank'>" + e + "</a>"
    })
};
/*!
 * VERSION: 1.17.0
 * DATE: 2015-05-27
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
        "use strict";
        _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(e, t, i) {
                var r = function(e) {
                        var t, i = [],
                            r = e.length;
                        for (t = 0; t !== r; i.push(e[t++]));
                        return i
                    },
                    n = function(e, t, r) {
                        i.call(this, e, t, r), this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._dirty = !0, this.render = n.prototype.render
                    },
                    o = 1e-10,
                    a = i._internals,
                    s = a.isSelector,
                    l = a.isArray,
                    h = n.prototype = i.to({}, .1, {}),
                    u = [];
                n.version = "1.17.0", h.constructor = n, h.kill()._gc = !1, n.killTweensOf = n.killDelayedCallsTo = i.killTweensOf, n.getTweensOf = i.getTweensOf, n.lagSmoothing = i.lagSmoothing, n.ticker = i.ticker, n.render = i.render, h.invalidate = function() {
                    return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), i.prototype.invalidate.call(this)
                }, h.updateTo = function(e, t) {
                    var r, n = this.ratio,
                        o = this.vars.immediateRender || e.immediateRender;
                    t && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
                    for (r in e) this.vars[r] = e[r];
                    if (this._initted || o)
                        if (t) this._initted = !1, o && this.render(0, !0, !0);
                        else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                        var a = this._time;
                        this.render(0, !0, !1), this._initted = !1, this.render(a, !0, !1)
                    } else if (this._time > 0 || o) {
                        this._initted = !1, this._init();
                        for (var s, l = 1 / (1 - n), h = this._firstPT; h;) s = h.s + h.c, h.c *= l, h.s = s - h.c, h = h._next
                    }
                    return this
                }, h.render = function(e, t, i) {
                    this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                    var r, n, s, l, h, u, c, p, d = this._dirty ? this.totalDuration() : this._totalDuration,
                        f = this._time,
                        m = this._totalTime,
                        E = this._cycle,
                        v = this._duration,
                        g = this._rawPrevTime;
                    if (e >= d ? (this._totalTime = d, this._cycle = this._repeat, this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = v, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, n = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === v && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (e = 0), (0 === e || 0 > g || g === o) && g !== e && (i = !0, g > o && (n = "onReverseComplete")), this._rawPrevTime = p = !t || e || g === e ? e : o)) : 1e-7 > e ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== m || 0 === v && g > 0) && (n = "onReverseComplete", r = this._reversed), 0 > e && (this._active = !1, 0 === v && (this._initted || !this.vars.lazy || i) && (g >= 0 && (i = !0), this._rawPrevTime = p = !t || e || g === e ? e : o)), this._initted || (i = !0)) : (this._totalTime = this._time = e, 0 !== this._repeat && (l = v + this._repeatDelay, this._cycle = this._totalTime / l >> 0, 0 !== this._cycle && this._cycle === this._totalTime / l && this._cycle--, this._time = this._totalTime - this._cycle * l, this._yoyo && 0 !== (1 & this._cycle) && (this._time = v - this._time), this._time > v ? this._time = v : 0 > this._time && (this._time = 0)), this._easeType ? (h = this._time / v, u = this._easeType, c = this._easePower, (1 === u || 3 === u && h >= .5) && (h = 1 - h), 3 === u && (h *= 2), 1 === c ? h *= h : 2 === c ? h *= h * h : 3 === c ? h *= h * h * h : 4 === c && (h *= h * h * h * h), this.ratio = 1 === u ? 1 - h : 2 === u ? h : .5 > this._time / v ? h / 2 : 1 - h / 2) : this.ratio = this._ease.getRatio(this._time / v)), f === this._time && !i && E === this._cycle) return void(m !== this._totalTime && this._onUpdate && (t || this._callback("onUpdate")));
                    if (!this._initted) {
                        if (this._init(), !this._initted || this._gc) return;
                        if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = f, this._totalTime = m, this._rawPrevTime = g, this._cycle = E, a.lazyTweens.push(this), void(this._lazy = [e, t]);
                        this._time && !r ? this.ratio = this._ease.getRatio(this._time / v) : r && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                    }
                    for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== f && e >= 0 && (this._active = !0), 0 === m && (2 === this._initted && e > 0 && this._init(), this._startAt && (e >= 0 ? this._startAt.render(e, t, i) : n || (n = "_dummyGS")), this.vars.onStart && (0 !== this._totalTime || 0 === v) && (t || this._callback("onStart"))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s, s = s._next;
                    this._onUpdate && (0 > e && this._startAt && this._startTime && this._startAt.render(e, t, i), t || (this._totalTime !== m || r) && this._callback("onUpdate")), this._cycle !== E && (t || this._gc || this.vars.onRepeat && this._callback("onRepeat")), n && (!this._gc || i) && (0 > e && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(e, t, i), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[n] && this._callback(n), 0 === v && this._rawPrevTime === o && p !== o && (this._rawPrevTime = 0))
                }, n.to = function(e, t, i) {
                    return new n(e, t, i)
                }, n.from = function(e, t, i) {
                    return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new n(e, t, i)
                }, n.fromTo = function(e, t, i, r) {
                    return r.startAt = i, r.immediateRender = 0 != r.immediateRender && 0 != i.immediateRender, new n(e, t, r)
                }, n.staggerTo = n.allTo = function(e, t, o, a, h, c, p) {
                    a = a || 0;
                    var d, f, m, E, v = o.delay || 0,
                        g = [],
                        y = function() {
                            o.onComplete && o.onComplete.apply(o.onCompleteScope || this, arguments), h.apply(p || o.callbackScope || this, c || u)
                        };
                    for (l(e) || ("string" == typeof e && (e = i.selector(e) || e), s(e) && (e = r(e))), e = e || [], 0 > a && (e = r(e), e.reverse(), a *= -1), d = e.length - 1, m = 0; d >= m; m++) {
                        f = {};
                        for (E in o) f[E] = o[E];
                        f.delay = v, m === d && h && (f.onComplete = y), g[m] = new n(e[m], t, f), v += a
                    }
                    return g
                }, n.staggerFrom = n.allFrom = function(e, t, i, r, o, a, s) {
                    return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, n.staggerTo(e, t, i, r, o, a, s)
                }, n.staggerFromTo = n.allFromTo = function(e, t, i, r, o, a, s, l) {
                    return r.startAt = i, r.immediateRender = 0 != r.immediateRender && 0 != i.immediateRender, n.staggerTo(e, t, r, o, a, s, l)
                }, n.delayedCall = function(e, t, i, r, o) {
                    return new n(t, 0, {
                        delay: e,
                        onComplete: t,
                        onCompleteParams: i,
                        callbackScope: r,
                        onReverseComplete: t,
                        onReverseCompleteParams: i,
                        immediateRender: !1,
                        useFrames: o,
                        overwrite: 0
                    })
                }, n.set = function(e, t) {
                    return new n(e, 0, t)
                }, n.isTweening = function(e) {
                    return i.getTweensOf(e, !0).length > 0
                };
                var c = function(e, t) {
                        for (var r = [], n = 0, o = e._first; o;) o instanceof i ? r[n++] = o : (t && (r[n++] = o), r = r.concat(c(o, t)), n = r.length), o = o._next;
                        return r
                    },
                    p = n.getAllTweens = function(t) {
                        return c(e._rootTimeline, t).concat(c(e._rootFramesTimeline, t))
                    };
                n.killAll = function(e, i, r, n) {
                    null == i && (i = !0), null == r && (r = !0);
                    var o, a, s, l = p(0 != n),
                        h = l.length,
                        u = i && r && n;
                    for (s = 0; h > s; s++) a = l[s], (u || a instanceof t || (o = a.target === a.vars.onComplete) && r || i && !o) && (e ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1))
                }, n.killChildTweensOf = function(e, t) {
                    if (null != e) {
                        var o, h, u, c, p, d = a.tweenLookup;
                        if ("string" == typeof e && (e = i.selector(e) || e), s(e) && (e = r(e)), l(e))
                            for (c = e.length; --c > -1;) n.killChildTweensOf(e[c], t);
                        else {
                            o = [];
                            for (u in d)
                                for (h = d[u].target.parentNode; h;) h === e && (o = o.concat(d[u].tweens)), h = h.parentNode;
                            for (p = o.length, c = 0; p > c; c++) t && o[c].totalTime(o[c].totalDuration()), o[c]._enabled(!1, !1)
                        }
                    }
                };
                var d = function(e, i, r, n) {
                    i = i !== !1, r = r !== !1, n = n !== !1;
                    for (var o, a, s = p(n), l = i && r && n, h = s.length; --h > -1;) a = s[h], (l || a instanceof t || (o = a.target === a.vars.onComplete) && r || i && !o) && a.paused(e)
                };
                return n.pauseAll = function(e, t, i) {
                    d(!0, e, t, i)
                }, n.resumeAll = function(e, t, i) {
                    d(!1, e, t, i)
                }, n.globalTimeScale = function(t) {
                    var r = e._rootTimeline,
                        n = i.ticker.time;
                    return arguments.length ? (t = t || o, r._startTime = n - (n - r._startTime) * r._timeScale / t, r = e._rootFramesTimeline, n = i.ticker.frame, r._startTime = n - (n - r._startTime) * r._timeScale / t, r._timeScale = e._rootTimeline._timeScale = t, t) : r._timeScale
                }, h.progress = function(e) {
                    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration()
                }, h.totalProgress = function(e) {
                    return arguments.length ? this.totalTime(this.totalDuration() * e, !1) : this._totalTime / this.totalDuration()
                }, h.time = function(e, t) {
                    return arguments.length ? (this._dirty && this.totalDuration(), e > this._duration && (e = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? e = this._duration - e + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (e += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(e, t)) : this._time
                }, h.duration = function(t) {
                    return arguments.length ? e.prototype.duration.call(this, t) : this._duration
                }, h.totalDuration = function(e) {
                    return arguments.length ? -1 === this._repeat ? this : this.duration((e - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
                }, h.repeat = function(e) {
                    return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat
                }, h.repeatDelay = function(e) {
                    return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay
                }, h.yoyo = function(e) {
                    return arguments.length ? (this._yoyo = e, this) : this._yoyo
                }, n
            }, !0), _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(e, t, i) {
                var r = function(e) {
                        t.call(this, e), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                        var i, r, n = this.vars;
                        for (r in n) i = n[r], l(i) && -1 !== i.join("").indexOf("{self}") && (n[r] = this._swapSelfInParams(i));
                        l(n.tweens) && this.add(n.tweens, 0, n.align, n.stagger)
                    },
                    n = 1e-10,
                    o = i._internals,
                    a = r._internals = {},
                    s = o.isSelector,
                    l = o.isArray,
                    h = o.lazyTweens,
                    u = o.lazyRender,
                    c = [],
                    p = _gsScope._gsDefine.globals,
                    d = function(e) {
                        var t, i = {};
                        for (t in e) i[t] = e[t];
                        return i
                    },
                    f = a.pauseCallback = function(e, t, i, r) {
                        var o, a = e._timeline,
                            s = a._totalTime,
                            l = e._startTime,
                            h = 0 > e._rawPrevTime || 0 === e._rawPrevTime && a._reversed,
                            u = h ? 0 : n,
                            p = h ? n : 0;
                        if (t || !this._forcingPlayhead) {
                            for (a.pause(l), o = e._prev; o && o._startTime === l;) o._rawPrevTime = p, o = o._prev;
                            for (o = e._next; o && o._startTime === l;) o._rawPrevTime = u, o = o._next;
                            t && t.apply(r || a.vars.callbackScope || a, i || c), (this._forcingPlayhead || !a._paused) && a.seek(s)
                        }
                    },
                    m = function(e) {
                        var t, i = [],
                            r = e.length;
                        for (t = 0; t !== r; i.push(e[t++]));
                        return i
                    },
                    E = r.prototype = new t;
                return r.version = "1.17.0", E.constructor = r, E.kill()._gc = E._forcingPlayhead = !1, E.to = function(e, t, r, n) {
                    var o = r.repeat && p.TweenMax || i;
                    return t ? this.add(new o(e, t, r), n) : this.set(e, r, n)
                }, E.from = function(e, t, r, n) {
                    return this.add((r.repeat && p.TweenMax || i).from(e, t, r), n)
                }, E.fromTo = function(e, t, r, n, o) {
                    var a = n.repeat && p.TweenMax || i;
                    return t ? this.add(a.fromTo(e, t, r, n), o) : this.set(e, n, o)
                }, E.staggerTo = function(e, t, n, o, a, l, h, u) {
                    var c, p = new r({
                        onComplete: l,
                        onCompleteParams: h,
                        callbackScope: u,
                        smoothChildTiming: this.smoothChildTiming
                    });
                    for ("string" == typeof e && (e = i.selector(e) || e), e = e || [], s(e) && (e = m(e)), o = o || 0, 0 > o && (e = m(e), e.reverse(), o *= -1), c = 0; e.length > c; c++) n.startAt && (n.startAt = d(n.startAt)), p.to(e[c], t, d(n), c * o);
                    return this.add(p, a)
                }, E.staggerFrom = function(e, t, i, r, n, o, a, s) {
                    return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(e, t, i, r, n, o, a, s)
                }, E.staggerFromTo = function(e, t, i, r, n, o, a, s, l) {
                    return r.startAt = i, r.immediateRender = 0 != r.immediateRender && 0 != i.immediateRender, this.staggerTo(e, t, r, n, o, a, s, l)
                }, E.call = function(e, t, r, n) {
                    return this.add(i.delayedCall(0, e, t, r), n)
                }, E.set = function(e, t, r) {
                    return r = this._parseTimeOrLabel(r, 0, !0), null == t.immediateRender && (t.immediateRender = r === this._time && !this._paused), this.add(new i(e, 0, t), r)
                }, r.exportRoot = function(e, t) {
                    e = e || {}, null == e.smoothChildTiming && (e.smoothChildTiming = !0);
                    var n, o, a = new r(e),
                        s = a._timeline;
                    for (null == t && (t = !0), s._remove(a, !0), a._startTime = 0, a._rawPrevTime = a._time = a._totalTime = s._time, n = s._first; n;) o = n._next, t && n instanceof i && n.target === n.vars.onComplete || a.add(n, n._startTime - n._delay), n = o;
                    return s.add(a, 0), a
                }, E.add = function(n, o, a, s) {
                    var h, u, c, p, d, f;
                    if ("number" != typeof o && (o = this._parseTimeOrLabel(o, 0, !0, n)), !(n instanceof e)) {
                        if (n instanceof Array || n && n.push && l(n)) {
                            for (a = a || "normal", s = s || 0, h = o, u = n.length, c = 0; u > c; c++) l(p = n[c]) && (p = new r({
                                tweens: p
                            })), this.add(p, h), "string" != typeof p && "function" != typeof p && ("sequence" === a ? h = p._startTime + p.totalDuration() / p._timeScale : "start" === a && (p._startTime -= p.delay())), h += s;
                            return this._uncache(!0)
                        }
                        if ("string" == typeof n) return this.addLabel(n, o);
                        if ("function" != typeof n) throw "Cannot add " + n + " into the timeline; it is not a tween, timeline, function, or string.";
                        n = i.delayedCall(0, n)
                    }
                    if (t.prototype.add.call(this, n, o), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                        for (d = this, f = d.rawTime() > n._startTime; d._timeline;) f && d._timeline.smoothChildTiming ? d.totalTime(d._totalTime, !0) : d._gc && d._enabled(!0, !1), d = d._timeline;
                    return this
                }, E.remove = function(t) {
                    if (t instanceof e) return this._remove(t, !1);
                    if (t instanceof Array || t && t.push && l(t)) {
                        for (var i = t.length; --i > -1;) this.remove(t[i]);
                        return this
                    }
                    return "string" == typeof t ? this.removeLabel(t) : this.kill(null, t)
                }, E._remove = function(e, i) {
                    t.prototype._remove.call(this, e, i);
                    var r = this._last;
                    return r ? this._time > r._startTime + r._totalDuration / r._timeScale && (this._time = this.duration(), this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
                }, E.append = function(e, t) {
                    return this.add(e, this._parseTimeOrLabel(null, t, !0, e))
                }, E.insert = E.insertMultiple = function(e, t, i, r) {
                    return this.add(e, t || 0, i, r)
                }, E.appendMultiple = function(e, t, i, r) {
                    return this.add(e, this._parseTimeOrLabel(null, t, !0, e), i, r)
                }, E.addLabel = function(e, t) {
                    return this._labels[e] = this._parseTimeOrLabel(t), this
                }, E.addPause = function(e, t, r, n) {
                    var o = i.delayedCall(0, f, ["{self}", t, r, n], this);
                    return o.data = "isPause", this.add(o, e)
                }, E.removeLabel = function(e) {
                    return delete this._labels[e], this
                }, E.getLabelTime = function(e) {
                    return null != this._labels[e] ? this._labels[e] : -1
                }, E._parseTimeOrLabel = function(t, i, r, n) {
                    var o;
                    if (n instanceof e && n.timeline === this) this.remove(n);
                    else if (n && (n instanceof Array || n.push && l(n)))
                        for (o = n.length; --o > -1;) n[o] instanceof e && n[o].timeline === this && this.remove(n[o]);
                    if ("string" == typeof i) return this._parseTimeOrLabel(i, r && "number" == typeof t && null == this._labels[i] ? t - this.duration() : 0, r);
                    if (i = i || 0, "string" != typeof t || !isNaN(t) && null == this._labels[t]) null == t && (t = this.duration());
                    else {
                        if (o = t.indexOf("="), -1 === o) return null == this._labels[t] ? r ? this._labels[t] = this.duration() + i : i : this._labels[t] + i;
                        i = parseInt(t.charAt(o - 1) + "1", 10) * Number(t.substr(o + 1)), t = o > 1 ? this._parseTimeOrLabel(t.substr(0, o - 1), 0, r) : this.duration()
                    }
                    return Number(t) + i
                }, E.seek = function(e, t) {
                    return this.totalTime("number" == typeof e ? e : this._parseTimeOrLabel(e), t !== !1)
                }, E.stop = function() {
                    return this.paused(!0)
                }, E.gotoAndPlay = function(e, t) {
                    return this.play(e, t)
                }, E.gotoAndStop = function(e, t) {
                    return this.pause(e, t)
                }, E.render = function(e, t, i) {
                    this._gc && this._enabled(!0, !1);
                    var r, o, a, s, l, c = this._dirty ? this.totalDuration() : this._totalDuration,
                        p = this._time,
                        d = this._startTime,
                        f = this._timeScale,
                        m = this._paused;
                    if (e >= c) this._totalTime = this._time = c, this._reversed || this._hasPausedChild() || (o = !0, s = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 === e || 0 > this._rawPrevTime || this._rawPrevTime === n) && this._rawPrevTime !== e && this._first && (l = !0, this._rawPrevTime > n && (s = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : n, e = c + 1e-4;
                    else if (1e-7 > e)
                        if (this._totalTime = this._time = 0, (0 !== p || 0 === this._duration && this._rawPrevTime !== n && (this._rawPrevTime > 0 || 0 > e && this._rawPrevTime >= 0)) && (s = "onReverseComplete", o = this._reversed), 0 > e) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = o = !0, s = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (l = !0), this._rawPrevTime = e;
                        else {
                            if (this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : n, 0 === e && o)
                                for (r = this._first; r && 0 === r._startTime;) r._duration || (o = !1), r = r._next;
                            e = 0, this._initted || (l = !0)
                        }
                    else this._totalTime = this._time = this._rawPrevTime = e;
                    if (this._time !== p && this._first || i || l) {
                        if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== p && e > 0 && (this._active = !0), 0 === p && this.vars.onStart && 0 !== this._time && (t || this._callback("onStart")), this._time >= p)
                            for (r = this._first; r && (a = r._next, !this._paused || m);)(r._active || r._startTime <= this._time && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, i) : r.render((e - r._startTime) * r._timeScale, t, i)), r = a;
                        else
                            for (r = this._last; r && (a = r._prev, !this._paused || m);)(r._active || p >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, i) : r.render((e - r._startTime) * r._timeScale, t, i)), r = a;
                        this._onUpdate && (t || (h.length && u(), this._callback("onUpdate"))), s && (this._gc || (d === this._startTime || f !== this._timeScale) && (0 === this._time || c >= this.totalDuration()) && (o && (h.length && u(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[s] && this._callback(s)))
                    }
                }, E._hasPausedChild = function() {
                    for (var e = this._first; e;) {
                        if (e._paused || e instanceof r && e._hasPausedChild()) return !0;
                        e = e._next
                    }
                    return !1
                }, E.getChildren = function(e, t, r, n) {
                    n = n || -9999999999;
                    for (var o = [], a = this._first, s = 0; a;) n > a._startTime || (a instanceof i ? t !== !1 && (o[s++] = a) : (r !== !1 && (o[s++] = a), e !== !1 && (o = o.concat(a.getChildren(!0, t, r)), s = o.length))), a = a._next;
                    return o
                }, E.getTweensOf = function(e, t) {
                    var r, n, o = this._gc,
                        a = [],
                        s = 0;
                    for (o && this._enabled(!0, !0), r = i.getTweensOf(e), n = r.length; --n > -1;)(r[n].timeline === this || t && this._contains(r[n])) && (a[s++] = r[n]);
                    return o && this._enabled(!1, !0), a
                }, E.recent = function() {
                    return this._recent
                }, E._contains = function(e) {
                    for (var t = e.timeline; t;) {
                        if (t === this) return !0;
                        t = t.timeline
                    }
                    return !1
                }, E.shiftChildren = function(e, t, i) {
                    i = i || 0;
                    for (var r, n = this._first, o = this._labels; n;) n._startTime >= i && (n._startTime += e), n = n._next;
                    if (t)
                        for (r in o) o[r] >= i && (o[r] += e);
                    return this._uncache(!0)
                }, E._kill = function(e, t) {
                    if (!e && !t) return this._enabled(!1, !1);
                    for (var i = t ? this.getTweensOf(t) : this.getChildren(!0, !0, !1), r = i.length, n = !1; --r > -1;) i[r]._kill(e, t) && (n = !0);
                    return n
                }, E.clear = function(e) {
                    var t = this.getChildren(!1, !0, !0),
                        i = t.length;
                    for (this._time = this._totalTime = 0; --i > -1;) t[i]._enabled(!1, !1);
                    return e !== !1 && (this._labels = {}), this._uncache(!0)
                }, E.invalidate = function() {
                    for (var t = this._first; t;) t.invalidate(), t = t._next;
                    return e.prototype.invalidate.call(this)
                }, E._enabled = function(e, i) {
                    if (e === this._gc)
                        for (var r = this._first; r;) r._enabled(e, !0), r = r._next;
                    return t.prototype._enabled.call(this, e, i)
                }, E.totalTime = function() {
                    this._forcingPlayhead = !0;
                    var t = e.prototype.totalTime.apply(this, arguments);
                    return this._forcingPlayhead = !1, t
                }, E.duration = function(e) {
                    return arguments.length ? (0 !== this.duration() && 0 !== e && this.timeScale(this._duration / e), this) : (this._dirty && this.totalDuration(), this._duration)
                }, E.totalDuration = function(e) {
                    if (!arguments.length) {
                        if (this._dirty) {
                            for (var t, i, r = 0, n = this._last, o = 999999999999; n;) t = n._prev, n._dirty && n.totalDuration(), n._startTime > o && this._sortChildren && !n._paused ? this.add(n, n._startTime - n._delay) : o = n._startTime, 0 > n._startTime && !n._paused && (r -= n._startTime, this._timeline.smoothChildTiming && (this._startTime += n._startTime / this._timeScale), this.shiftChildren(-n._startTime, !1, -9999999999), o = 0), i = n._startTime + n._totalDuration / n._timeScale, i > r && (r = i), n = t;
                            this._duration = this._totalDuration = r, this._dirty = !1
                        }
                        return this._totalDuration
                    }
                    return 0 !== this.totalDuration() && 0 !== e && this.timeScale(this._totalDuration / e), this
                }, E.paused = function(t) {
                    if (!t)
                        for (var i = this._first, r = this._time; i;) i._startTime === r && "isPause" === i.data && (i._rawPrevTime = 0), i = i._next;
                    return e.prototype.paused.apply(this, arguments)
                }, E.usesFrames = function() {
                    for (var t = this._timeline; t._timeline;) t = t._timeline;
                    return t === e._rootFramesTimeline
                }, E.rawTime = function() {
                    return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale
                }, r
            }, !0), _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(e, t, i) {
                var r = function(t) {
                        e.call(this, t), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0
                    },
                    n = 1e-10,
                    o = t._internals,
                    a = o.lazyTweens,
                    s = o.lazyRender,
                    l = new i(null, null, 1, 0),
                    h = r.prototype = new e;
                return h.constructor = r, h.kill()._gc = !1, r.version = "1.17.0", h.invalidate = function() {
                    return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), e.prototype.invalidate.call(this)
                }, h.addCallback = function(e, i, r, n) {
                    return this.add(t.delayedCall(0, e, r, n), i)
                }, h.removeCallback = function(e, t) {
                    if (e)
                        if (null == t) this._kill(null, e);
                        else
                            for (var i = this.getTweensOf(e, !1), r = i.length, n = this._parseTimeOrLabel(t); --r > -1;) i[r]._startTime === n && i[r]._enabled(!1, !1);
                    return this
                }, h.removePause = function(t) {
                    return this.removeCallback(e._internals.pauseCallback, t)
                }, h.tweenTo = function(e, i) {
                    i = i || {};
                    var r, n, o, a = {
                        ease: l,
                        useFrames: this.usesFrames(),
                        immediateRender: !1
                    };
                    for (n in i) a[n] = i[n];
                    return a.time = this._parseTimeOrLabel(e), r = Math.abs(Number(a.time) - this._time) / this._timeScale || .001, o = new t(this, r, a), a.onStart = function() {
                        o.target.paused(!0), o.vars.time !== o.target.time() && r === o.duration() && o.duration(Math.abs(o.vars.time - o.target.time()) / o.target._timeScale), i.onStart && o._callback("onStart")
                    }, o
                }, h.tweenFromTo = function(e, t, i) {
                    i = i || {}, e = this._parseTimeOrLabel(e), i.startAt = {
                        onComplete: this.seek,
                        onCompleteParams: [e],
                        callbackScope: this
                    }, i.immediateRender = i.immediateRender !== !1;
                    var r = this.tweenTo(t, i);
                    return r.duration(Math.abs(r.vars.time - e) / this._timeScale || .001)
                }, h.render = function(e, t, i) {
                    this._gc && this._enabled(!0, !1);
                    var r, o, l, h, u, c, p = this._dirty ? this.totalDuration() : this._totalDuration,
                        d = this._duration,
                        f = this._time,
                        m = this._totalTime,
                        E = this._startTime,
                        v = this._timeScale,
                        g = this._rawPrevTime,
                        y = this._paused,
                        T = this._cycle;
                    if (e >= p) this._locked || (this._totalTime = p, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (o = !0, h = "onComplete", u = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 === e || 0 > g || g === n) && g !== e && this._first && (u = !0, g > n && (h = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : n, this._yoyo && 0 !== (1 & this._cycle) ? this._time = e = 0 : (this._time = d, e = d + 1e-4);
                    else if (1e-7 > e)
                        if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== f || 0 === d && g !== n && (g > 0 || 0 > e && g >= 0) && !this._locked) && (h = "onReverseComplete", o = this._reversed), 0 > e) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (u = o = !0, h = "onReverseComplete") : g >= 0 && this._first && (u = !0), this._rawPrevTime = e;
                        else {
                            if (this._rawPrevTime = d || !t || e || this._rawPrevTime === e ? e : n, 0 === e && o)
                                for (r = this._first; r && 0 === r._startTime;) r._duration || (o = !1), r = r._next;
                            e = 0, this._initted || (u = !0)
                        }
                    else 0 === d && 0 > g && (u = !0), this._time = this._rawPrevTime = e, this._locked || (this._totalTime = e, 0 !== this._repeat && (c = d + this._repeatDelay, this._cycle = this._totalTime / c >> 0, 0 !== this._cycle && this._cycle === this._totalTime / c && this._cycle--, this._time = this._totalTime - this._cycle * c, this._yoyo && 0 !== (1 & this._cycle) && (this._time = d - this._time), this._time > d ? (this._time = d, e = d + 1e-4) : 0 > this._time ? this._time = e = 0 : e = this._time));
                    if (this._cycle !== T && !this._locked) {
                        var x = this._yoyo && 0 !== (1 & T),
                            _ = x === (this._yoyo && 0 !== (1 & this._cycle)),
                            R = this._totalTime,
                            b = this._cycle,
                            H = this._rawPrevTime,
                            w = this._time;
                        if (this._totalTime = T * d, T > this._cycle ? x = !x : this._totalTime += d, this._time = f, this._rawPrevTime = 0 === d ? g - 1e-4 : g, this._cycle = T, this._locked = !0, f = x ? 0 : d, this.render(f, t, 0 === d), t || this._gc || this.vars.onRepeat && this._callback("onRepeat"), _ && (f = x ? d + 1e-4 : -1e-4, this.render(f, !0, !1)), this._locked = !1, this._paused && !y) return;
                        this._time = w, this._totalTime = R, this._cycle = b, this._rawPrevTime = H
                    }
                    if (!(this._time !== f && this._first || i || u)) return void(m !== this._totalTime && this._onUpdate && (t || this._callback("onUpdate")));
                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== m && e > 0 && (this._active = !0), 0 === m && this.vars.onStart && 0 !== this._totalTime && (t || this._callback("onStart")), this._time >= f)
                        for (r = this._first; r && (l = r._next, !this._paused || y);)(r._active || r._startTime <= this._time && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, i) : r.render((e - r._startTime) * r._timeScale, t, i)), r = l;
                    else
                        for (r = this._last; r && (l = r._prev, !this._paused || y);)(r._active || f >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, i) : r.render((e - r._startTime) * r._timeScale, t, i)), r = l;
                    this._onUpdate && (t || (a.length && s(), this._callback("onUpdate"))), h && (this._locked || this._gc || (E === this._startTime || v !== this._timeScale) && (0 === this._time || p >= this.totalDuration()) && (o && (a.length && s(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[h] && this._callback(h)))
                }, h.getActive = function(e, t, i) {
                    null == e && (e = !0), null == t && (t = !0), null == i && (i = !1);
                    var r, n, o = [],
                        a = this.getChildren(e, t, i),
                        s = 0,
                        l = a.length;
                    for (r = 0; l > r; r++) n = a[r], n.isActive() && (o[s++] = n);
                    return o
                }, h.getLabelAfter = function(e) {
                    e || 0 !== e && (e = this._time);
                    var t, i = this.getLabelsArray(),
                        r = i.length;
                    for (t = 0; r > t; t++)
                        if (i[t].time > e) return i[t].name;
                    return null
                }, h.getLabelBefore = function(e) {
                    null == e && (e = this._time);
                    for (var t = this.getLabelsArray(), i = t.length; --i > -1;)
                        if (e > t[i].time) return t[i].name;
                    return null
                }, h.getLabelsArray = function() {
                    var e, t = [],
                        i = 0;
                    for (e in this._labels) t[i++] = {
                        time: this._labels[e],
                        name: e
                    };
                    return t.sort(function(e, t) {
                        return e.time - t.time
                    }), t
                }, h.progress = function(e, t) {
                    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), t) : this._time / this.duration()
                }, h.totalProgress = function(e, t) {
                    return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this._totalTime / this.totalDuration()
                }, h.totalDuration = function(t) {
                    return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (e.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
                }, h.time = function(e, t) {
                    return arguments.length ? (this._dirty && this.totalDuration(), e > this._duration && (e = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? e = this._duration - e + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (e += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(e, t)) : this._time
                }, h.repeat = function(e) {
                    return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat
                }, h.repeatDelay = function(e) {
                    return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay
                }, h.yoyo = function(e) {
                    return arguments.length ? (this._yoyo = e, this) : this._yoyo
                }, h.currentLabel = function(e) {
                    return arguments.length ? this.seek(e, !0) : this.getLabelBefore(this._time + 1e-8)
                }, r
            }, !0),
            function() {
                var e = 180 / Math.PI,
                    t = [],
                    i = [],
                    r = [],
                    n = {},
                    o = _gsScope._gsDefine.globals,
                    a = function(e, t, i, r) {
                        this.a = e, this.b = t, this.c = i, this.d = r, this.da = r - e, this.ca = i - e, this.ba = t - e
                    },
                    s = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
                    l = function(e, t, i, r) {
                        var n = {
                                a: e
                            },
                            o = {},
                            a = {},
                            s = {
                                c: r
                            },
                            l = (e + t) / 2,
                            h = (t + i) / 2,
                            u = (i + r) / 2,
                            c = (l + h) / 2,
                            p = (h + u) / 2,
                            d = (p - c) / 8;
                        return n.b = l + (e - l) / 4, o.b = c + d, n.c = o.a = (n.b + o.b) / 2, o.c = a.a = (c + p) / 2, a.b = p - d, s.b = u + (r - u) / 4, a.c = s.a = (a.b + s.b) / 2, [n, o, a, s]
                    },
                    h = function(e, n, o, a, s) {
                        var h, u, c, p, d, f, m, E, v, g, y, T, x, _ = e.length - 1,
                            R = 0,
                            b = e[0].a;
                        for (h = 0; _ > h; h++) d = e[R], u = d.a, c = d.d, p = e[R + 1].d, s ? (y = t[h], T = i[h], x = .25 * (T + y) * n / (a ? .5 : r[h] || .5), f = c - (c - u) * (a ? .5 * n : 0 !== y ? x / y : 0), m = c + (p - c) * (a ? .5 * n : 0 !== T ? x / T : 0), E = c - (f + ((m - f) * (3 * y / (y + T) + .5) / 4 || 0))) : (f = c - .5 * (c - u) * n, m = c + .5 * (p - c) * n, E = c - (f + m) / 2), f += E, m += E, d.c = v = f, d.b = 0 !== h ? b : b = d.a + .6 * (d.c - d.a), d.da = c - u, d.ca = v - u, d.ba = b - u, o ? (g = l(u, b, v, c), e.splice(R, 1, g[0], g[1], g[2], g[3]), R += 4) : R++, b = m;
                        d = e[R], d.b = b, d.c = b + .4 * (d.d - b), d.da = d.d - d.a, d.ca = d.c - d.a, d.ba = b - d.a, o && (g = l(d.a, b, d.c, d.d), e.splice(R, 1, g[0], g[1], g[2], g[3]))
                    },
                    u = function(e, r, n, o) {
                        var s, l, h, u, c, p, d = [];
                        if (o)
                            for (e = [o].concat(e), l = e.length; --l > -1;) "string" == typeof(p = e[l][r]) && "=" === p.charAt(1) && (e[l][r] = o[r] + Number(p.charAt(0) + p.substr(2)));
                        if (s = e.length - 2, 0 > s) return d[0] = new a(e[0][r], 0, 0, e[-1 > s ? 0 : 1][r]), d;
                        for (l = 0; s > l; l++) h = e[l][r], u = e[l + 1][r], d[l] = new a(h, 0, 0, u), n && (c = e[l + 2][r], t[l] = (t[l] || 0) + (u - h) * (u - h), i[l] = (i[l] || 0) + (c - u) * (c - u));
                        return d[l] = new a(e[l][r], 0, 0, e[l + 1][r]), d
                    },
                    c = function(e, o, a, l, c, p) {
                        var d, f, m, E, v, g, y, T, x = {},
                            _ = [],
                            R = p || e[0];
                        c = "string" == typeof c ? "," + c + "," : s, null == o && (o = 1);
                        for (f in e[0]) _.push(f);
                        if (e.length > 1) {
                            for (T = e[e.length - 1], y = !0, d = _.length; --d > -1;)
                                if (f = _[d], Math.abs(R[f] - T[f]) > .05) {
                                    y = !1;
                                    break
                                }
                            y && (e = e.concat(), p && e.unshift(p), e.push(e[1]), p = e[e.length - 3])
                        }
                        for (t.length = i.length = r.length = 0, d = _.length; --d > -1;) f = _[d], n[f] = -1 !== c.indexOf("," + f + ","), x[f] = u(e, f, n[f], p);
                        for (d = t.length; --d > -1;) t[d] = Math.sqrt(t[d]), i[d] = Math.sqrt(i[d]);
                        if (!l) {
                            for (d = _.length; --d > -1;)
                                if (n[f])
                                    for (m = x[_[d]], g = m.length - 1, E = 0; g > E; E++) v = m[E + 1].da / i[E] + m[E].da / t[E], r[E] = (r[E] || 0) + v * v;
                            for (d = r.length; --d > -1;) r[d] = Math.sqrt(r[d])
                        }
                        for (d = _.length, E = a ? 4 : 1; --d > -1;) f = _[d], m = x[f], h(m, o, a, l, n[f]), y && (m.splice(0, E), m.splice(m.length - E, E));
                        return x
                    },
                    p = function(e, t, i) {
                        t = t || "soft";
                        var r, n, o, s, l, h, u, c, p, d, f, m = {},
                            E = "cubic" === t ? 3 : 2,
                            v = "soft" === t,
                            g = [];
                        if (v && i && (e = [i].concat(e)), null == e || E + 1 > e.length) throw "invalid Bezier data";
                        for (p in e[0]) g.push(p);
                        for (h = g.length; --h > -1;) {
                            for (p = g[h], m[p] = l = [], d = 0, c = e.length, u = 0; c > u; u++) r = null == i ? e[u][p] : "string" == typeof(f = e[u][p]) && "=" === f.charAt(1) ? i[p] + Number(f.charAt(0) + f.substr(2)) : Number(f), v && u > 1 && c - 1 > u && (l[d++] = (r + l[d - 2]) / 2), l[d++] = r;
                            for (c = d - E + 1, d = 0, u = 0; c > u; u += E) r = l[u], n = l[u + 1], o = l[u + 2], s = 2 === E ? 0 : l[u + 3], l[d++] = f = 3 === E ? new a(r, n, o, s) : new a(r, (2 * n + r) / 3, (2 * n + o) / 3, o);
                            l.length = d
                        }
                        return m
                    },
                    d = function(e, t, i) {
                        for (var r, n, o, a, s, l, h, u, c, p, d, f = 1 / i, m = e.length; --m > -1;)
                            for (p = e[m], o = p.a, a = p.d - o, s = p.c - o, l = p.b - o, r = n = 0, u = 1; i >= u; u++) h = f * u, c = 1 - h, r = n - (n = (h * h * a + 3 * c * (h * s + c * l)) * h), d = m * i + u - 1, t[d] = (t[d] || 0) + r * r
                    },
                    f = function(e, t) {
                        t = t >> 0 || 6;
                        var i, r, n, o, a = [],
                            s = [],
                            l = 0,
                            h = 0,
                            u = t - 1,
                            c = [],
                            p = [];
                        for (i in e) d(e[i], a, t);
                        for (n = a.length, r = 0; n > r; r++) l += Math.sqrt(a[r]), o = r % t, p[o] = l, o === u && (h += l, o = r / t >> 0, c[o] = p, s[o] = h, l = 0, p = []);
                        return {
                            length: h,
                            lengths: s,
                            segments: c
                        }
                    },
                    m = _gsScope._gsDefine.plugin({
                        propName: "bezier",
                        priority: -1,
                        version: "1.3.4",
                        API: 2,
                        global: !0,
                        init: function(e, t, i) {
                            this._target = e, t instanceof Array && (t = {
                                values: t
                            }), this._func = {}, this._round = {}, this._props = [], this._timeRes = null == t.timeResolution ? 6 : parseInt(t.timeResolution, 10);
                            var r, n, o, a, s, l = t.values || [],
                                h = {},
                                u = l[0],
                                d = t.autoRotate || i.vars.orientToBezier;
                            this._autoRotate = d ? d instanceof Array ? d : [
                                ["x", "y", "rotation", d === !0 ? 0 : Number(d) || 0]
                            ] : null;
                            for (r in u) this._props.push(r);
                            for (o = this._props.length; --o > -1;) r = this._props[o], this._overwriteProps.push(r), n = this._func[r] = "function" == typeof e[r], h[r] = n ? e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)]() : parseFloat(e[r]), s || h[r] !== l[0][r] && (s = h);
                            if (this._beziers = "cubic" !== t.type && "quadratic" !== t.type && "soft" !== t.type ? c(l, isNaN(t.curviness) ? 1 : t.curviness, !1, "thruBasic" === t.type, t.correlate, s) : p(l, t.type, h), this._segCount = this._beziers[r].length, this._timeRes) {
                                var m = f(this._beziers, this._timeRes);
                                this._length = m.length, this._lengths = m.lengths, this._segments = m.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                            }
                            if (d = this._autoRotate)
                                for (this._initialRotations = [], d[0] instanceof Array || (this._autoRotate = d = [d]), o = d.length; --o > -1;) {
                                    for (a = 0; 3 > a; a++) r = d[o][a], this._func[r] = "function" == typeof e[r] ? e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)] : !1;
                                    r = d[o][2], this._initialRotations[o] = this._func[r] ? this._func[r].call(this._target) : this._target[r]
                                }
                            return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
                        },
                        set: function(t) {
                            var i, r, n, o, a, s, l, h, u, c, p = this._segCount,
                                d = this._func,
                                f = this._target,
                                m = t !== this._startRatio;
                            if (this._timeRes) {
                                if (u = this._lengths, c = this._curSeg, t *= this._length, n = this._li, t > this._l2 && p - 1 > n) {
                                    for (h = p - 1; h > n && t >= (this._l2 = u[++n]););
                                    this._l1 = u[n - 1], this._li = n, this._curSeg = c = this._segments[n], this._s2 = c[this._s1 = this._si = 0]
                                } else if (this._l1 > t && n > 0) {
                                    for (; n > 0 && (this._l1 = u[--n]) >= t;);
                                    0 === n && this._l1 > t ? this._l1 = 0 : n++, this._l2 = u[n], this._li = n, this._curSeg = c = this._segments[n], this._s1 = c[(this._si = c.length - 1) - 1] || 0, this._s2 = c[this._si]
                                }
                                if (i = n, t -= this._l1, n = this._si, t > this._s2 && c.length - 1 > n) {
                                    for (h = c.length - 1; h > n && t >= (this._s2 = c[++n]););
                                    this._s1 = c[n - 1], this._si = n
                                } else if (this._s1 > t && n > 0) {
                                    for (; n > 0 && (this._s1 = c[--n]) >= t;);
                                    0 === n && this._s1 > t ? this._s1 = 0 : n++, this._s2 = c[n], this._si = n
                                }
                                s = (n + (t - this._s1) / (this._s2 - this._s1)) * this._prec
                            } else i = 0 > t ? 0 : t >= 1 ? p - 1 : p * t >> 0, s = (t - i * (1 / p)) * p;
                            for (r = 1 - s, n = this._props.length; --n > -1;) o = this._props[n], a = this._beziers[o][i], l = (s * s * a.da + 3 * r * (s * a.ca + r * a.ba)) * s + a.a, this._round[o] && (l = Math.round(l)), d[o] ? f[o](l) : f[o] = l;
                            if (this._autoRotate) {
                                var E, v, g, y, T, x, _, R = this._autoRotate;
                                for (n = R.length; --n > -1;) o = R[n][2], x = R[n][3] || 0, _ = R[n][4] === !0 ? 1 : e, a = this._beziers[R[n][0]], E = this._beziers[R[n][1]], a && E && (a = a[i], E = E[i], v = a.a + (a.b - a.a) * s, y = a.b + (a.c - a.b) * s, v += (y - v) * s, y += (a.c + (a.d - a.c) * s - y) * s, g = E.a + (E.b - E.a) * s, T = E.b + (E.c - E.b) * s, g += (T - g) * s, T += (E.c + (E.d - E.c) * s - T) * s, l = m ? Math.atan2(T - g, y - v) * _ + x : this._initialRotations[n], d[o] ? f[o](l) : f[o] = l)
                            }
                        }
                    }),
                    E = m.prototype;
                m.bezierThrough = c, m.cubicToQuadratic = l, m._autoCSS = !0, m.quadraticToCubic = function(e, t, i) {
                    return new a(e, (2 * t + e) / 3, (2 * t + i) / 3, i)
                }, m._cssRegister = function() {
                    var e = o.CSSPlugin;
                    if (e) {
                        var t = e._internals,
                            i = t._parseToProxy,
                            r = t._setPluginRatio,
                            n = t.CSSPropTween;
                        t._registerComplexSpecialProp("bezier", {
                            parser: function(e, t, o, a, s, l) {
                                t instanceof Array && (t = {
                                    values: t
                                }), l = new m;
                                var h, u, c, p = t.values,
                                    d = p.length - 1,
                                    f = [],
                                    E = {};
                                if (0 > d) return s;
                                for (h = 0; d >= h; h++) c = i(e, p[h], a, s, l, d !== h), f[h] = c.end;
                                for (u in t) E[u] = t[u];
                                return E.values = f, s = new n(e, "bezier", 0, 0, c.pt, 2), s.data = c, s.plugin = l, s.setRatio = r, 0 === E.autoRotate && (E.autoRotate = !0), !E.autoRotate || E.autoRotate instanceof Array || (h = E.autoRotate === !0 ? 0 : Number(E.autoRotate), E.autoRotate = null != c.end.left ? [
                                    ["left", "top", "rotation", h, !1]
                                ] : null != c.end.x ? [
                                    ["x", "y", "rotation", h, !1]
                                ] : !1), E.autoRotate && (a._transform || a._enableTransforms(!1), c.autoRotate = a._target._gsTransform), l._onInitTween(c.proxy, E, a._tween), s
                            }
                        })
                    }
                }, E._roundProps = function(e, t) {
                    for (var i = this._overwriteProps, r = i.length; --r > -1;)(e[i[r]] || e.bezier || e.bezierThrough) && (this._round[i[r]] = t)
                }, E._kill = function(e) {
                    var t, i, r = this._props;
                    for (t in this._beziers)
                        if (t in e)
                            for (delete this._beziers[t], delete this._func[t], i = r.length; --i > -1;) r[i] === t && r.splice(i, 1);
                    return this._super._kill.call(this, e)
                }
            }(), _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(e, t) {
                var i, r, n, o, a = function() {
                        e.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = a.prototype.setRatio
                    },
                    s = _gsScope._gsDefine.globals,
                    l = {},
                    h = a.prototype = new e("css");
                h.constructor = a, a.version = "1.17.0", a.API = 2, a.defaultTransformPerspective = 0, a.defaultSkewType = "compensated", a.defaultSmoothOrigin = !0, h = "px", a.suffixMap = {
                    top: h,
                    right: h,
                    bottom: h,
                    left: h,
                    width: h,
                    height: h,
                    fontSize: h,
                    padding: h,
                    margin: h,
                    perspective: h,
                    lineHeight: ""
                };
                var u, c, p, d, f, m, E = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
                    v = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                    g = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                    y = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                    T = /(?:\d|\-|\+|=|#|\.)*/g,
                    x = /opacity *= *([^)]*)/i,
                    _ = /opacity:([^;]*)/i,
                    R = /alpha\(opacity *=.+?\)/i,
                    b = /^(rgb|hsl)/,
                    H = /([A-Z])/g,
                    w = /-([a-z])/gi,
                    M = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                    S = function(e, t) {
                        return t.toUpperCase()
                    },
                    C = /(?:Left|Right|Width)/i,
                    A = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                    P = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                    L = /,(?=[^\)]*(?:\(|$))/gi,
                    D = Math.PI / 180,
                    O = 180 / Math.PI,
                    F = {},
                    k = document,
                    U = function(e) {
                        return k.createElementNS ? k.createElementNS("http://www.w3.org/1999/xhtml", e) : k.createElement(e)
                    },
                    N = U("div"),
                    B = U("img"),
                    z = a._internals = {
                        _specialProps: l
                    },
                    V = navigator.userAgent,
                    I = function() {
                        var e = V.indexOf("Android"),
                            t = U("a");
                        return p = -1 !== V.indexOf("Safari") && -1 === V.indexOf("Chrome") && (-1 === e || Number(V.substr(e + 8, 1)) > 3), f = p && 6 > Number(V.substr(V.indexOf("Version/") + 8, 1)), d = -1 !== V.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(V) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(V)) && (m = parseFloat(RegExp.$1)), t ? (t.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(t.style.opacity)) : !1
                    }(),
                    j = function(e) {
                        return x.test("string" == typeof e ? e : (e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                    },
                    G = function(e) {
                        window.console && console.log(e)
                    },
                    W = "",
                    X = "",
                    q = function(e, t) {
                        t = t || N;
                        var i, r, n = t.style;
                        if (void 0 !== n[e]) return e;
                        for (e = e.charAt(0).toUpperCase() + e.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], r = 5; --r > -1 && void 0 === n[i[r] + e];);
                        return r >= 0 ? (X = 3 === r ? "ms" : i[r], W = "-" + X.toLowerCase() + "-", X + e) : null
                    },
                    Y = k.defaultView ? k.defaultView.getComputedStyle : function() {},
                    Q = a.getStyle = function(e, t, i, r, n) {
                        var o;
                        return I || "opacity" !== t ? (!r && e.style[t] ? o = e.style[t] : (i = i || Y(e)) ? o = i[t] || i.getPropertyValue(t) || i.getPropertyValue(t.replace(H, "-$1").toLowerCase()) : e.currentStyle && (o = e.currentStyle[t]), null == n || o && "none" !== o && "auto" !== o && "auto auto" !== o ? o : n) : j(e)
                    },
                    $ = z.convertToPixels = function(e, i, r, n, o) {
                        if ("px" === n || !n) return r;
                        if ("auto" === n || !r) return 0;
                        var s, l, h, u = C.test(i),
                            c = e,
                            p = N.style,
                            d = 0 > r;
                        if (d && (r = -r), "%" === n && -1 !== i.indexOf("border")) s = r / 100 * (u ? e.clientWidth : e.clientHeight);
                        else {
                            if (p.cssText = "border:0 solid red;position:" + Q(e, "position") + ";line-height:0;", "%" !== n && c.appendChild) p[u ? "borderLeftWidth" : "borderTopWidth"] = r + n;
                            else {
                                if (c = e.parentNode || k.body, l = c._gsCache, h = t.ticker.frame, l && u && l.time === h) return l.width * r / 100;
                                p[u ? "width" : "height"] = r + n
                            }
                            c.appendChild(N), s = parseFloat(N[u ? "offsetWidth" : "offsetHeight"]), c.removeChild(N), u && "%" === n && a.cacheWidths !== !1 && (l = c._gsCache = c._gsCache || {}, l.time = h, l.width = 100 * (s / r)), 0 !== s || o || (s = $(e, i, r, n, !0))
                        }
                        return d ? -s : s
                    },
                    K = z.calculateOffset = function(e, t, i) {
                        if ("absolute" !== Q(e, "position", i)) return 0;
                        var r = "left" === t ? "Left" : "Top",
                            n = Q(e, "margin" + r, i);
                        return e["offset" + r] - ($(e, t, parseFloat(n), n.replace(T, "")) || 0)
                    },
                    Z = function(e, t) {
                        var i, r, n, o = {};
                        if (t = t || Y(e, null))
                            if (i = t.length)
                                for (; --i > -1;) n = t[i], (-1 === n.indexOf("-transform") || bt === n) && (o[n.replace(w, S)] = t.getPropertyValue(n));
                            else
                                for (i in t)(-1 === i.indexOf("Transform") || Rt === i) && (o[i] = t[i]);
                        else if (t = e.currentStyle || e.style)
                            for (i in t) "string" == typeof i && void 0 === o[i] && (o[i.replace(w, S)] = t[i]);
                        return I || (o.opacity = j(e)), r = kt(e, t, !1), o.rotation = r.rotation, o.skewX = r.skewX, o.scaleX = r.scaleX, o.scaleY = r.scaleY, o.x = r.x, o.y = r.y, wt && (o.z = r.z, o.rotationX = r.rotationX, o.rotationY = r.rotationY, o.scaleZ = r.scaleZ), o.filters && delete o.filters, o
                    },
                    J = function(e, t, i, r, n) {
                        var o, a, s, l = {},
                            h = e.style;
                        for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (t[a] !== (o = i[a]) || n && n[a]) && -1 === a.indexOf("Origin") && ("number" == typeof o || "string" == typeof o) && (l[a] = "auto" !== o || "left" !== a && "top" !== a ? "" !== o && "auto" !== o && "none" !== o || "string" != typeof t[a] || "" === t[a].replace(y, "") ? o : 0 : K(e, a), void 0 !== h[a] && (s = new dt(h, a, h[a], s)));
                        if (r)
                            for (a in r) "className" !== a && (l[a] = r[a]);
                        return {
                            difs: l,
                            firstMPT: s
                        }
                    },
                    et = {
                        width: ["Left", "Right"],
                        height: ["Top", "Bottom"]
                    },
                    tt = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                    it = function(e, t, i) {
                        var r = parseFloat("width" === t ? e.offsetWidth : e.offsetHeight),
                            n = et[t],
                            o = n.length;
                        for (i = i || Y(e, null); --o > -1;) r -= parseFloat(Q(e, "padding" + n[o], i, !0)) || 0, r -= parseFloat(Q(e, "border" + n[o] + "Width", i, !0)) || 0;
                        return r
                    },
                    rt = function(e, t) {
                        (null == e || "" === e || "auto" === e || "auto auto" === e) && (e = "0 0");
                        var i = e.split(" "),
                            r = -1 !== e.indexOf("left") ? "0%" : -1 !== e.indexOf("right") ? "100%" : i[0],
                            n = -1 !== e.indexOf("top") ? "0%" : -1 !== e.indexOf("bottom") ? "100%" : i[1];
                        return null == n ? n = "center" === r ? "50%" : "0" : "center" === n && (n = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), e = r + " " + n + (i.length > 2 ? " " + i[2] : ""), t && (t.oxp = -1 !== r.indexOf("%"), t.oyp = -1 !== n.indexOf("%"), t.oxr = "=" === r.charAt(1), t.oyr = "=" === n.charAt(1), t.ox = parseFloat(r.replace(y, "")), t.oy = parseFloat(n.replace(y, "")), t.v = e), t || e
                    },
                    nt = function(e, t) {
                        return "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(t)
                    },
                    ot = function(e, t) {
                        return null == e ? t : "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) + t : parseFloat(e)
                    },
                    at = function(e, t, i, r) {
                        var n, o, a, s, l, h = 1e-6;
                        return null == e ? s = t : "number" == typeof e ? s = e : (n = 360, o = e.split("_"), l = "=" === e.charAt(1), a = (l ? parseInt(e.charAt(0) + "1", 10) * parseFloat(o[0].substr(2)) : parseFloat(o[0])) * (-1 === e.indexOf("rad") ? 1 : O) - (l ? 0 : t), o.length && (r && (r[i] = t + a), -1 !== e.indexOf("short") && (a %= n, a !== a % (n / 2) && (a = 0 > a ? a + n : a - n)), -1 !== e.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * n) % n - (0 | a / n) * n : -1 !== e.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * n) % n - (0 | a / n) * n)), s = t + a), h > s && s > -h && (s = 0), s
                    },
                    st = {
                        aqua: [0, 255, 255],
                        lime: [0, 255, 0],
                        silver: [192, 192, 192],
                        black: [0, 0, 0],
                        maroon: [128, 0, 0],
                        teal: [0, 128, 128],
                        blue: [0, 0, 255],
                        navy: [0, 0, 128],
                        white: [255, 255, 255],
                        fuchsia: [255, 0, 255],
                        olive: [128, 128, 0],
                        yellow: [255, 255, 0],
                        orange: [255, 165, 0],
                        gray: [128, 128, 128],
                        purple: [128, 0, 128],
                        green: [0, 128, 0],
                        red: [255, 0, 0],
                        pink: [255, 192, 203],
                        cyan: [0, 255, 255],
                        transparent: [255, 255, 255, 0]
                    },
                    lt = function(e, t, i) {
                        return e = 0 > e ? e + 1 : e > 1 ? e - 1 : e, 0 | 255 * (1 > 6 * e ? t + 6 * (i - t) * e : .5 > e ? i : 2 > 3 * e ? t + 6 * (i - t) * (2 / 3 - e) : t) + .5
                    },
                    ht = a.parseColor = function(e) {
                        var t, i, r, n, o, a;
                        return e && "" !== e ? "number" == typeof e ? [e >> 16, 255 & e >> 8, 255 & e] : ("," === e.charAt(e.length - 1) && (e = e.substr(0, e.length - 1)), st[e] ? st[e] : "#" === e.charAt(0) ? (4 === e.length && (t = e.charAt(1), i = e.charAt(2), r = e.charAt(3), e = "#" + t + t + i + i + r + r), e = parseInt(e.substr(1), 16), [e >> 16, 255 & e >> 8, 255 & e]) : "hsl" === e.substr(0, 3) ? (e = e.match(E), n = Number(e[0]) % 360 / 360, o = Number(e[1]) / 100, a = Number(e[2]) / 100, i = .5 >= a ? a * (o + 1) : a + o - a * o, t = 2 * a - i, e.length > 3 && (e[3] = Number(e[3])), e[0] = lt(n + 1 / 3, t, i), e[1] = lt(n, t, i), e[2] = lt(n - 1 / 3, t, i), e) : (e = e.match(E) || st.transparent, e[0] = Number(e[0]), e[1] = Number(e[1]), e[2] = Number(e[2]), e.length > 3 && (e[3] = Number(e[3])), e)) : st.black
                    },
                    ut = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b";
                for (h in st) ut += "|" + h + "\\b";
                ut = RegExp(ut + ")", "gi");
                var ct = function(e, t, i, r) {
                        if (null == e) return function(e) {
                            return e
                        };
                        var n, o = t ? (e.match(ut) || [""])[0] : "",
                            a = e.split(o).join("").match(g) || [],
                            s = e.substr(0, e.indexOf(a[0])),
                            l = ")" === e.charAt(e.length - 1) ? ")" : "",
                            h = -1 !== e.indexOf(" ") ? " " : ",",
                            u = a.length,
                            c = u > 0 ? a[0].replace(E, "") : "";
                        return u ? n = t ? function(e) {
                            var t, p, d, f;
                            if ("number" == typeof e) e += c;
                            else if (r && L.test(e)) {
                                for (f = e.replace(L, "|").split("|"), d = 0; f.length > d; d++) f[d] = n(f[d]);
                                return f.join(",")
                            }
                            if (t = (e.match(ut) || [o])[0], p = e.split(t).join("").match(g) || [], d = p.length, u > d--)
                                for (; u > ++d;) p[d] = i ? p[0 | (d - 1) / 2] : a[d];
                            return s + p.join(h) + h + t + l + (-1 !== e.indexOf("inset") ? " inset" : "")
                        } : function(e) {
                            var t, o, p;
                            if ("number" == typeof e) e += c;
                            else if (r && L.test(e)) {
                                for (o = e.replace(L, "|").split("|"), p = 0; o.length > p; p++) o[p] = n(o[p]);
                                return o.join(",")
                            }
                            if (t = e.match(g) || [], p = t.length, u > p--)
                                for (; u > ++p;) t[p] = i ? t[0 | (p - 1) / 2] : a[p];
                            return s + t.join(h) + l
                        } : function(e) {
                            return e
                        }
                    },
                    pt = function(e) {
                        return e = e.split(","),
                            function(t, i, r, n, o, a, s) {
                                var l, h = (i + "").split(" ");
                                for (s = {}, l = 0; 4 > l; l++) s[e[l]] = h[l] = h[l] || h[(l - 1) / 2 >> 0];
                                return n.parse(t, s, o, a)
                            }
                    },
                    dt = (z._setPluginRatio = function(e) {
                        this.plugin.setRatio(e);
                        for (var t, i, r, n, o = this.data, a = o.proxy, s = o.firstMPT, l = 1e-6; s;) t = a[s.v], s.r ? t = Math.round(t) : l > t && t > -l && (t = 0), s.t[s.p] = t, s = s._next;
                        if (o.autoRotate && (o.autoRotate.rotation = a.rotation), 1 === e)
                            for (s = o.firstMPT; s;) {
                                if (i = s.t, i.type) {
                                    if (1 === i.type) {
                                        for (n = i.xs0 + i.s + i.xs1, r = 1; i.l > r; r++) n += i["xn" + r] + i["xs" + (r + 1)];
                                        i.e = n
                                    }
                                } else i.e = i.s + i.xs0;
                                s = s._next
                            }
                    }, function(e, t, i, r, n) {
                        this.t = e, this.p = t, this.v = i, this.r = n, r && (r._prev = this, this._next = r)
                    }),
                    ft = (z._parseToProxy = function(e, t, i, r, n, o) {
                        var a, s, l, h, u, c = r,
                            p = {},
                            d = {},
                            f = i._transform,
                            m = F;
                        for (i._transform = null, F = t, r = u = i.parse(e, t, r, n), F = m, o && (i._transform = f, c && (c._prev = null, c._prev && (c._prev._next = null))); r && r !== c;) {
                            if (1 >= r.type && (s = r.p, d[s] = r.s + r.c, p[s] = r.s, o || (h = new dt(r, "s", s, h, r.r), r.c = 0), 1 === r.type))
                                for (a = r.l; --a > 0;) l = "xn" + a, s = r.p + "_" + l, d[s] = r.data[l], p[s] = r[l], o || (h = new dt(r, l, s, h, r.rxp[l]));
                            r = r._next
                        }
                        return {
                            proxy: p,
                            end: d,
                            firstMPT: h,
                            pt: u
                        }
                    }, z.CSSPropTween = function(e, t, r, n, a, s, l, h, u, c, p) {
                        this.t = e, this.p = t, this.s = r, this.c = n, this.n = l || t, e instanceof ft || o.push(this.n), this.r = h, this.type = s || 0, u && (this.pr = u, i = !0), this.b = void 0 === c ? r : c, this.e = void 0 === p ? r + n : p, a && (this._next = a, a._prev = this)
                    }),
                    mt = function(e, t, i, r, n, o) {
                        var a = new ft(e, t, i, r - i, n, -1, o);
                        return a.b = i, a.e = a.xs0 = r, a
                    },
                    Et = a.parseComplex = function(e, t, i, r, n, o, a, s, l, h) {
                        i = i || o || "", a = new ft(e, t, 0, 0, a, h ? 2 : 1, null, !1, s, i, r), r += "";
                        var c, p, d, f, m, g, y, T, x, _, R, H, w = i.split(", ").join(",").split(" "),
                            M = r.split(", ").join(",").split(" "),
                            S = w.length,
                            C = u !== !1;
                        for ((-1 !== r.indexOf(",") || -1 !== i.indexOf(",")) && (w = w.join(" ").replace(L, ", ").split(" "), M = M.join(" ").replace(L, ", ").split(" "), S = w.length), S !== M.length && (w = (o || "").split(" "), S = w.length), a.plugin = l, a.setRatio = h, c = 0; S > c; c++)
                            if (f = w[c], m = M[c], T = parseFloat(f), T || 0 === T) a.appendXtra("", T, nt(m, T), m.replace(v, ""), C && -1 !== m.indexOf("px"), !0);
                            else if (n && ("#" === f.charAt(0) || st[f] || b.test(f))) H = "," === m.charAt(m.length - 1) ? ")," : ")", f = ht(f), m = ht(m), x = f.length + m.length > 6, x && !I && 0 === m[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(M[c]).join("transparent")) : (I || (x = !1), a.appendXtra(x ? "rgba(" : "rgb(", f[0], m[0] - f[0], ",", !0, !0).appendXtra("", f[1], m[1] - f[1], ",", !0).appendXtra("", f[2], m[2] - f[2], x ? "," : H, !0), x && (f = 4 > f.length ? 1 : f[3], a.appendXtra("", f, (4 > m.length ? 1 : m[3]) - f, H, !1)));
                        else if (g = f.match(E)) {
                            if (y = m.match(v), !y || y.length !== g.length) return a;
                            for (d = 0, p = 0; g.length > p; p++) R = g[p], _ = f.indexOf(R, d), a.appendXtra(f.substr(d, _ - d), Number(R), nt(y[p], R), "", C && "px" === f.substr(_ + R.length, 2), 0 === p), d = _ + R.length;
                            a["xs" + a.l] += f.substr(d)
                        } else a["xs" + a.l] += a.l ? " " + f : f;
                        if (-1 !== r.indexOf("=") && a.data) {
                            for (H = a.xs0 + a.data.s, c = 1; a.l > c; c++) H += a["xs" + c] + a.data["xn" + c];
                            a.e = H + a["xs" + c]
                        }
                        return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a
                    },
                    vt = 9;
                for (h = ft.prototype, h.l = h.pr = 0; --vt > 0;) h["xn" + vt] = 0, h["xs" + vt] = "";
                h.xs0 = "", h._next = h._prev = h.xfirst = h.data = h.plugin = h.setRatio = h.rxp = null, h.appendXtra = function(e, t, i, r, n, o) {
                    var a = this,
                        s = a.l;
                    return a["xs" + s] += o && s ? " " + e : e || "", i || 0 === s || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = r || "", s > 0 ? (a.data["xn" + s] = t + i, a.rxp["xn" + s] = n, a["xn" + s] = t, a.plugin || (a.xfirst = new ft(a, "xn" + s, t, i, a.xfirst || a, 0, a.n, n, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {
                        s: t + i
                    }, a.rxp = {}, a.s = t, a.c = i, a.r = n, a)) : (a["xs" + s] += t + (r || ""), a)
                };
                var gt = function(e, t) {
                        t = t || {}, this.p = t.prefix ? q(e) || e : e, l[e] = l[this.p] = this, this.format = t.formatter || ct(t.defaultValue, t.color, t.collapsible, t.multi), t.parser && (this.parse = t.parser), this.clrs = t.color, this.multi = t.multi, this.keyword = t.keyword, this.dflt = t.defaultValue, this.pr = t.priority || 0
                    },
                    yt = z._registerComplexSpecialProp = function(e, t, i) {
                        "object" != typeof t && (t = {
                            parser: i
                        });
                        var r, n, o = e.split(","),
                            a = t.defaultValue;
                        for (i = i || [a], r = 0; o.length > r; r++) t.prefix = 0 === r && t.prefix, t.defaultValue = i[r] || a, n = new gt(o[r], t)
                    },
                    Tt = function(e) {
                        if (!l[e]) {
                            var t = e.charAt(0).toUpperCase() + e.substr(1) + "Plugin";
                            yt(e, {
                                parser: function(e, i, r, n, o, a, h) {
                                    var u = s.com.greensock.plugins[t];
                                    return u ? (u._cssRegister(), l[r].parse(e, i, r, n, o, a, h)) : (G("Error: " + t + " js file not loaded."), o)
                                }
                            })
                        }
                    };
                h = gt.prototype, h.parseComplex = function(e, t, i, r, n, o) {
                    var a, s, l, h, u, c, p = this.keyword;
                    if (this.multi && (L.test(i) || L.test(t) ? (s = t.replace(L, "|").split("|"), l = i.replace(L, "|").split("|")) : p && (s = [t], l = [i])), l) {
                        for (h = l.length > s.length ? l.length : s.length, a = 0; h > a; a++) t = s[a] = s[a] || this.dflt, i = l[a] = l[a] || this.dflt, p && (u = t.indexOf(p), c = i.indexOf(p), u !== c && (-1 === c ? s[a] = s[a].split(p).join("") : -1 === u && (s[a] += " " + p)));
                        t = s.join(", "), i = l.join(", ")
                    }
                    return Et(e, this.p, t, i, this.clrs, this.dflt, r, this.pr, n, o)
                }, h.parse = function(e, t, i, r, o, a) {
                    return this.parseComplex(e.style, this.format(Q(e, this.p, n, !1, this.dflt)), this.format(t), o, a)
                }, a.registerSpecialProp = function(e, t, i) {
                    yt(e, {
                        parser: function(e, r, n, o, a, s) {
                            var l = new ft(e, n, 0, 0, a, 2, n, !1, i);
                            return l.plugin = s, l.setRatio = t(e, r, o._tween, n), l
                        },
                        priority: i
                    })
                }, a.useSVGTransformAttr = p || d;
                var xt, _t = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                    Rt = q("transform"),
                    bt = W + "transform",
                    Ht = q("transformOrigin"),
                    wt = null !== q("perspective"),
                    Mt = z.Transform = function() {
                        this.perspective = parseFloat(a.defaultTransformPerspective) || 0, this.force3D = a.defaultForce3D !== !1 && wt ? a.defaultForce3D || "auto" : !1
                    },
                    St = window.SVGElement,
                    Ct = function(e, t, i) {
                        var r, n = k.createElementNS("http://www.w3.org/2000/svg", e),
                            o = /([a-z])([A-Z])/g;
                        for (r in i) n.setAttributeNS(null, r.replace(o, "$1-$2").toLowerCase(), i[r]);
                        return t.appendChild(n), n
                    },
                    At = k.documentElement,
                    Pt = function() {
                        var e, t, i, r = m || /Android/i.test(V) && !window.chrome;
                        return k.createElementNS && !r && (e = Ct("svg", At), t = Ct("rect", e, {
                            width: 100,
                            height: 50,
                            x: 100
                        }), i = t.getBoundingClientRect().width, t.style[Ht] = "50% 50%", t.style[Rt] = "scaleX(0.5)", r = i === t.getBoundingClientRect().width && !(d && wt), At.removeChild(e)), r
                    }(),
                    Lt = function(e, t, i, r, n) {
                        var o, s, l, h, u, c, p, d, f, m, E, v, g, y, T = e._gsTransform,
                            x = Ft(e, !0);
                        T && (g = T.xOrigin, y = T.yOrigin), (!r || 2 > (o = r.split(" ")).length) && (p = e.getBBox(), t = rt(t).split(" "), o = [(-1 !== t[0].indexOf("%") ? parseFloat(t[0]) / 100 * p.width : parseFloat(t[0])) + p.x, (-1 !== t[1].indexOf("%") ? parseFloat(t[1]) / 100 * p.height : parseFloat(t[1])) + p.y]), i.xOrigin = h = parseFloat(o[0]), i.yOrigin = u = parseFloat(o[1]), r && x !== Ot && (c = x[0], p = x[1], d = x[2], f = x[3], m = x[4], E = x[5], v = c * f - p * d, s = h * (f / v) + u * (-d / v) + (d * E - f * m) / v, l = h * (-p / v) + u * (c / v) - (c * E - p * m) / v, h = i.xOrigin = o[0] = s, u = i.yOrigin = o[1] = l), T && (n || n !== !1 && a.defaultSmoothOrigin !== !1 ? (s = h - g, l = u - y, T.xOffset += s * x[0] + l * x[2] - s, T.yOffset += s * x[1] + l * x[3] - l) : T.xOffset = T.yOffset = 0), e.setAttribute("data-svg-origin", o.join(" "))
                    },
                    Dt = function(e) {
                        return !!(St && "function" == typeof e.getBBox && e.getCTM && (!e.parentNode || e.parentNode.getBBox && e.parentNode.getCTM))
                    },
                    Ot = [1, 0, 0, 1, 0, 0],
                    Ft = function(e, t) {
                        var i, r, n, o, a, s = e._gsTransform || new Mt,
                            l = 1e5;
                        if (Rt ? r = Q(e, bt, null, !0) : e.currentStyle && (r = e.currentStyle.filter.match(A), r = r && 4 === r.length ? [r[0].substr(4), Number(r[2].substr(4)), Number(r[1].substr(4)), r[3].substr(4), s.x || 0, s.y || 0].join(",") : ""), i = !r || "none" === r || "matrix(1, 0, 0, 1, 0, 0)" === r, (s.svg || e.getBBox && Dt(e)) && (i && -1 !== (e.style[Rt] + "").indexOf("matrix") && (r = e.style[Rt], i = 0), n = e.getAttribute("transform"), i && n && (-1 !== n.indexOf("matrix") ? (r = n, i = 0) : -1 !== n.indexOf("translate") && (r = "matrix(1,0,0,1," + n.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")", i = 0))), i) return Ot;
                        for (n = (r || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], vt = n.length; --vt > -1;) o = Number(n[vt]), n[vt] = (a = o - (o |= 0)) ? (0 | a * l + (0 > a ? -.5 : .5)) / l + o : o;
                        return t && n.length > 6 ? [n[0], n[1], n[4], n[5], n[12], n[13]] : n
                    },
                    kt = z.getTransform = function(e, i, r, o) {
                        if (e._gsTransform && r && !o) return e._gsTransform;
                        var s, l, h, u, c, p, d = r ? e._gsTransform || new Mt : new Mt,
                            f = 0 > d.scaleX,
                            m = 2e-5,
                            E = 1e5,
                            v = wt ? parseFloat(Q(e, Ht, i, !1, "0 0 0").split(" ")[2]) || d.zOrigin || 0 : 0,
                            g = parseFloat(a.defaultTransformPerspective) || 0;
                        if (d.svg = !(!e.getBBox || !Dt(e)), d.svg && (Lt(e, Q(e, Ht, n, !1, "50% 50%") + "", d, e.getAttribute("data-svg-origin")), xt = a.useSVGTransformAttr || Pt), s = Ft(e), s !== Ot) {
                            if (16 === s.length) {
                                var y, T, x, _, R, b = s[0],
                                    H = s[1],
                                    w = s[2],
                                    M = s[3],
                                    S = s[4],
                                    C = s[5],
                                    A = s[6],
                                    P = s[7],
                                    L = s[8],
                                    D = s[9],
                                    F = s[10],
                                    k = s[12],
                                    U = s[13],
                                    N = s[14],
                                    B = s[11],
                                    z = Math.atan2(A, F);
                                d.zOrigin && (N = -d.zOrigin, k = L * N - s[12], U = D * N - s[13], N = F * N + d.zOrigin - s[14]), d.rotationX = z * O, z && (_ = Math.cos(-z), R = Math.sin(-z), y = S * _ + L * R, T = C * _ + D * R, x = A * _ + F * R, L = S * -R + L * _, D = C * -R + D * _, F = A * -R + F * _, B = P * -R + B * _, S = y, C = T, A = x), z = Math.atan2(L, F), d.rotationY = z * O, z && (_ = Math.cos(-z), R = Math.sin(-z), y = b * _ - L * R, T = H * _ - D * R, x = w * _ - F * R, D = H * R + D * _, F = w * R + F * _, B = M * R + B * _, b = y, H = T, w = x), z = Math.atan2(H, b), d.rotation = z * O, z && (_ = Math.cos(-z), R = Math.sin(-z), b = b * _ + S * R, T = H * _ + C * R, C = H * -R + C * _, A = w * -R + A * _, H = T), d.rotationX && Math.abs(d.rotationX) + Math.abs(d.rotation) > 359.9 && (d.rotationX = d.rotation = 0, d.rotationY += 180), d.scaleX = (0 | Math.sqrt(b * b + H * H) * E + .5) / E, d.scaleY = (0 | Math.sqrt(C * C + D * D) * E + .5) / E, d.scaleZ = (0 | Math.sqrt(A * A + F * F) * E + .5) / E, d.skewX = 0, d.perspective = B ? 1 / (0 > B ? -B : B) : 0, d.x = k, d.y = U, d.z = N, d.svg && (d.x -= d.xOrigin - (d.xOrigin * b - d.yOrigin * S), d.y -= d.yOrigin - (d.yOrigin * H - d.xOrigin * C))
                            } else if (!(wt && !o && s.length && d.x === s[4] && d.y === s[5] && (d.rotationX || d.rotationY) || void 0 !== d.x && "none" === Q(e, "display", i))) {
                                var V = s.length >= 6,
                                    I = V ? s[0] : 1,
                                    j = s[1] || 0,
                                    G = s[2] || 0,
                                    W = V ? s[3] : 1;
                                d.x = s[4] || 0, d.y = s[5] || 0, h = Math.sqrt(I * I + j * j), u = Math.sqrt(W * W + G * G), c = I || j ? Math.atan2(j, I) * O : d.rotation || 0, p = G || W ? Math.atan2(G, W) * O + c : d.skewX || 0, Math.abs(p) > 90 && 270 > Math.abs(p) && (f ? (h *= -1, p += 0 >= c ? 180 : -180, c += 0 >= c ? 180 : -180) : (u *= -1, p += 0 >= p ? 180 : -180)), d.scaleX = h, d.scaleY = u, d.rotation = c, d.skewX = p, wt && (d.rotationX = d.rotationY = d.z = 0, d.perspective = g, d.scaleZ = 1), d.svg && (d.x -= d.xOrigin - (d.xOrigin * I + d.yOrigin * G), d.y -= d.yOrigin - (d.xOrigin * j + d.yOrigin * W))
                            }
                            d.zOrigin = v;
                            for (l in d) m > d[l] && d[l] > -m && (d[l] = 0)
                        }
                        return r && (e._gsTransform = d, d.svg && (xt && e.style[Rt] ? t.delayedCall(.001, function() {
                            zt(e.style, Rt)
                        }) : !xt && e.getAttribute("transform") && t.delayedCall(.001, function() {
                            e.removeAttribute("transform")
                        }))), d
                    },
                    Ut = function(e) {
                        var t, i, r = this.data,
                            n = -r.rotation * D,
                            o = n + r.skewX * D,
                            a = 1e5,
                            s = (0 | Math.cos(n) * r.scaleX * a) / a,
                            l = (0 | Math.sin(n) * r.scaleX * a) / a,
                            h = (0 | Math.sin(o) * -r.scaleY * a) / a,
                            u = (0 | Math.cos(o) * r.scaleY * a) / a,
                            c = this.t.style,
                            p = this.t.currentStyle;
                        if (p) {
                            i = l, l = -h, h = -i, t = p.filter, c.filter = "";
                            var d, f, E = this.t.offsetWidth,
                                v = this.t.offsetHeight,
                                g = "absolute" !== p.position,
                                y = "progid:DXImageTransform.Microsoft.Matrix(M11=" + s + ", M12=" + l + ", M21=" + h + ", M22=" + u,
                                _ = r.x + E * r.xPercent / 100,
                                R = r.y + v * r.yPercent / 100;
                            if (null != r.ox && (d = (r.oxp ? .01 * E * r.ox : r.ox) - E / 2, f = (r.oyp ? .01 * v * r.oy : r.oy) - v / 2, _ += d - (d * s + f * l), R += f - (d * h + f * u)), g ? (d = E / 2, f = v / 2, y += ", Dx=" + (d - (d * s + f * l) + _) + ", Dy=" + (f - (d * h + f * u) + R) + ")") : y += ", sizingMethod='auto expand')", c.filter = -1 !== t.indexOf("DXImageTransform.Microsoft.Matrix(") ? t.replace(P, y) : y + " " + t, (0 === e || 1 === e) && 1 === s && 0 === l && 0 === h && 1 === u && (g && -1 === y.indexOf("Dx=0, Dy=0") || x.test(t) && 100 !== parseFloat(RegExp.$1) || -1 === t.indexOf("gradient(" && t.indexOf("Alpha")) && c.removeAttribute("filter")), !g) {
                                var b, H, w, M = 8 > m ? 1 : -1;
                                for (d = r.ieOffsetX || 0, f = r.ieOffsetY || 0, r.ieOffsetX = Math.round((E - ((0 > s ? -s : s) * E + (0 > l ? -l : l) * v)) / 2 + _), r.ieOffsetY = Math.round((v - ((0 > u ? -u : u) * v + (0 > h ? -h : h) * E)) / 2 + R), vt = 0; 4 > vt; vt++) H = tt[vt], b = p[H], i = -1 !== b.indexOf("px") ? parseFloat(b) : $(this.t, H, parseFloat(b), b.replace(T, "")) || 0, w = i !== r[H] ? 2 > vt ? -r.ieOffsetX : -r.ieOffsetY : 2 > vt ? d - r.ieOffsetX : f - r.ieOffsetY, c[H] = (r[H] = Math.round(i - w * (0 === vt || 2 === vt ? 1 : M))) + "px"
                            }
                        }
                    },
                    Nt = z.set3DTransformRatio = z.setTransformRatio = function(e) {
                        var t, i, r, n, o, a, s, l, h, u, c, p, f, m, E, v, g, y, T, x, _, R, b, H = this.data,
                            w = this.t.style,
                            M = H.rotation,
                            S = H.rotationX,
                            C = H.rotationY,
                            A = H.scaleX,
                            P = H.scaleY,
                            L = H.scaleZ,
                            O = H.x,
                            F = H.y,
                            k = H.z,
                            U = H.svg,
                            N = H.perspective,
                            B = H.force3D;
                        if (!((1 !== e && 0 !== e || "auto" !== B || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && B || k || N || C || S) || xt && U || !wt) return void(M || H.skewX || U ? (M *= D, R = H.skewX * D, b = 1e5, t = Math.cos(M) * A, n = Math.sin(M) * A, i = Math.sin(M - R) * -P, o = Math.cos(M - R) * P, R && "simple" === H.skewType && (g = Math.tan(R), g = Math.sqrt(1 + g * g), i *= g, o *= g, H.skewY && (t *= g, n *= g)), U && (O += H.xOrigin - (H.xOrigin * t + H.yOrigin * i) + H.xOffset, F += H.yOrigin - (H.xOrigin * n + H.yOrigin * o) + H.yOffset, xt && (H.xPercent || H.yPercent) && (m = this.t.getBBox(), O += .01 * H.xPercent * m.width, F += .01 * H.yPercent * m.height), m = 1e-6, m > O && O > -m && (O = 0), m > F && F > -m && (F = 0)), T = (0 | t * b) / b + "," + (0 | n * b) / b + "," + (0 | i * b) / b + "," + (0 | o * b) / b + "," + O + "," + F + ")", U && xt ? this.t.setAttribute("transform", "matrix(" + T) : w[Rt] = (H.xPercent || H.yPercent ? "translate(" + H.xPercent + "%," + H.yPercent + "%) matrix(" : "matrix(") + T) : w[Rt] = (H.xPercent || H.yPercent ? "translate(" + H.xPercent + "%," + H.yPercent + "%) matrix(" : "matrix(") + A + ",0,0," + P + "," + O + "," + F + ")");
                        if (d && (m = 1e-4, m > A && A > -m && (A = L = 2e-5), m > P && P > -m && (P = L = 2e-5), !N || H.z || H.rotationX || H.rotationY || (N = 0)), M || H.skewX) M *= D, E = t = Math.cos(M), v = n = Math.sin(M), H.skewX && (M -= H.skewX * D, E = Math.cos(M), v = Math.sin(M), "simple" === H.skewType && (g = Math.tan(H.skewX * D), g = Math.sqrt(1 + g * g), E *= g, v *= g, H.skewY && (t *= g, n *= g))), i = -v, o = E;
                        else {
                            if (!(C || S || 1 !== L || N || U)) return void(w[Rt] = (H.xPercent || H.yPercent ? "translate(" + H.xPercent + "%," + H.yPercent + "%) translate3d(" : "translate3d(") + O + "px," + F + "px," + k + "px)" + (1 !== A || 1 !== P ? " scale(" + A + "," + P + ")" : ""));
                            t = o = 1, i = n = 0
                        }
                        h = 1, r = a = s = l = u = c = 0, p = N ? -1 / N : 0, f = H.zOrigin, m = 1e-6, x = ",", _ = "0", M = C * D, M && (E = Math.cos(M), v = Math.sin(M), s = -v, u = p * -v, r = t * v, a = n * v, h = E, p *= E, t *= E, n *= E), M = S * D, M && (E = Math.cos(M), v = Math.sin(M), g = i * E + r * v, y = o * E + a * v, l = h * v, c = p * v, r = i * -v + r * E, a = o * -v + a * E, h *= E, p *= E, i = g, o = y), 1 !== L && (r *= L, a *= L, h *= L, p *= L), 1 !== P && (i *= P, o *= P, l *= P, c *= P), 1 !== A && (t *= A, n *= A, s *= A, u *= A), (f || U) && (f && (O += r * -f, F += a * -f, k += h * -f + f), U && (O += H.xOrigin - (H.xOrigin * t + H.yOrigin * i) + H.xOffset, F += H.yOrigin - (H.xOrigin * n + H.yOrigin * o) + H.yOffset), m > O && O > -m && (O = _), m > F && F > -m && (F = _), m > k && k > -m && (k = 0)), T = H.xPercent || H.yPercent ? "translate(" + H.xPercent + "%," + H.yPercent + "%) matrix3d(" : "matrix3d(", T += (m > t && t > -m ? _ : t) + x + (m > n && n > -m ? _ : n) + x + (m > s && s > -m ? _ : s), T += x + (m > u && u > -m ? _ : u) + x + (m > i && i > -m ? _ : i) + x + (m > o && o > -m ? _ : o), S || C ? (T += x + (m > l && l > -m ? _ : l) + x + (m > c && c > -m ? _ : c) + x + (m > r && r > -m ? _ : r), T += x + (m > a && a > -m ? _ : a) + x + (m > h && h > -m ? _ : h) + x + (m > p && p > -m ? _ : p) + x) : T += ",0,0,0,0,1,0,", T += O + x + F + x + k + x + (N ? 1 + -k / N : 1) + ")", w[Rt] = T
                    };
                h = Mt.prototype, h.x = h.y = h.z = h.skewX = h.skewY = h.rotation = h.rotationX = h.rotationY = h.zOrigin = h.xPercent = h.yPercent = h.xOffset = h.yOffset = 0, h.scaleX = h.scaleY = h.scaleZ = 1, yt("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                    parser: function(e, t, i, r, o, s, l) {
                        if (r._lastParsedTransform === l) return o;
                        r._lastParsedTransform = l;
                        var h, u, c, p, d, f, m, E, v, g = e._gsTransform,
                            y = r._transform = kt(e, n, !0, l.parseTransform),
                            T = e.style,
                            x = 1e-6,
                            _ = _t.length,
                            R = l,
                            b = {},
                            H = "transformOrigin";
                        if ("string" == typeof R.transform && Rt) c = N.style, c[Rt] = R.transform, c.display = "block", c.position = "absolute", k.body.appendChild(N), h = kt(N, null, !1), k.body.removeChild(N), null != R.xPercent && (h.xPercent = ot(R.xPercent, y.xPercent)), null != R.yPercent && (h.yPercent = ot(R.yPercent, y.yPercent));
                        else if ("object" == typeof R) {
                            if (h = {
                                    scaleX: ot(null != R.scaleX ? R.scaleX : R.scale, y.scaleX),
                                    scaleY: ot(null != R.scaleY ? R.scaleY : R.scale, y.scaleY),
                                    scaleZ: ot(R.scaleZ, y.scaleZ),
                                    x: ot(R.x, y.x),
                                    y: ot(R.y, y.y),
                                    z: ot(R.z, y.z),
                                    xPercent: ot(R.xPercent, y.xPercent),
                                    yPercent: ot(R.yPercent, y.yPercent),
                                    perspective: ot(R.transformPerspective, y.perspective)
                                }, m = R.directionalRotation, null != m)
                                if ("object" == typeof m)
                                    for (c in m) R[c] = m[c];
                                else R.rotation = m;
                            "string" == typeof R.x && -1 !== R.x.indexOf("%") && (h.x = 0, h.xPercent = ot(R.x, y.xPercent)), "string" == typeof R.y && -1 !== R.y.indexOf("%") && (h.y = 0, h.yPercent = ot(R.y, y.yPercent)), h.rotation = at("rotation" in R ? R.rotation : "shortRotation" in R ? R.shortRotation + "_short" : "rotationZ" in R ? R.rotationZ : y.rotation, y.rotation, "rotation", b), wt && (h.rotationX = at("rotationX" in R ? R.rotationX : "shortRotationX" in R ? R.shortRotationX + "_short" : y.rotationX || 0, y.rotationX, "rotationX", b), h.rotationY = at("rotationY" in R ? R.rotationY : "shortRotationY" in R ? R.shortRotationY + "_short" : y.rotationY || 0, y.rotationY, "rotationY", b)), h.skewX = null == R.skewX ? y.skewX : at(R.skewX, y.skewX), h.skewY = null == R.skewY ? y.skewY : at(R.skewY, y.skewY), (u = h.skewY - y.skewY) && (h.skewX += u, h.rotation += u)
                        }
                        for (wt && null != R.force3D && (y.force3D = R.force3D, f = !0), y.skewType = R.skewType || y.skewType || a.defaultSkewType, d = y.force3D || y.z || y.rotationX || y.rotationY || h.z || h.rotationX || h.rotationY || h.perspective, d || null == R.scale || (h.scaleZ = 1); --_ > -1;) i = _t[_], p = h[i] - y[i], (p > x || -x > p || null != R[i] || null != F[i]) && (f = !0, o = new ft(y, i, y[i], p, o), i in b && (o.e = b[i]), o.xs0 = 0, o.plugin = s, r._overwriteProps.push(o.n));
                        return p = R.transformOrigin, y.svg && (p || R.svgOrigin) && (E = y.xOffset, v = y.yOffset, Lt(e, rt(p), h, R.svgOrigin, R.smoothOrigin), o = mt(y, "xOrigin", (g ? y : h).xOrigin, h.xOrigin, o, H), o = mt(y, "yOrigin", (g ? y : h).yOrigin, h.yOrigin, o, H), (E !== y.xOffset || v !== y.yOffset) && (o = mt(y, "xOffset", g ? E : y.xOffset, y.xOffset, o, H), o = mt(y, "yOffset", g ? v : y.yOffset, y.yOffset, o, H)), p = xt ? null : "0px 0px"), (p || wt && d && y.zOrigin) && (Rt ? (f = !0, i = Ht, p = (p || Q(e, i, n, !1, "50% 50%")) + "", o = new ft(T, i, 0, 0, o, -1, H), o.b = T[i], o.plugin = s, wt ? (c = y.zOrigin, p = p.split(" "), y.zOrigin = (p.length > 2 && (0 === c || "0px" !== p[2]) ? parseFloat(p[2]) : c) || 0, o.xs0 = o.e = p[0] + " " + (p[1] || "50%") + " 0px", o = new ft(y, "zOrigin", 0, 0, o, -1, o.n), o.b = c, o.xs0 = o.e = y.zOrigin) : o.xs0 = o.e = p) : rt(p + "", y)), f && (r._transformType = y.svg && xt || !d && 3 !== this._transformType ? 2 : 3), o
                    },
                    prefix: !0
                }), yt("boxShadow", {
                    defaultValue: "0px 0px 0px 0px #999",
                    prefix: !0,
                    color: !0,
                    multi: !0,
                    keyword: "inset"
                }), yt("borderRadius", {
                    defaultValue: "0px",
                    parser: function(e, t, i, o, a) {
                        t = this.format(t);
                        var s, l, h, u, c, p, d, f, m, E, v, g, y, T, x, _, R = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                            b = e.style;
                        for (m = parseFloat(e.offsetWidth), E = parseFloat(e.offsetHeight), s = t.split(" "), l = 0; R.length > l; l++) this.p.indexOf("border") && (R[l] = q(R[l])), c = u = Q(e, R[l], n, !1, "0px"), -1 !== c.indexOf(" ") && (u = c.split(" "), c = u[0], u = u[1]), p = h = s[l], d = parseFloat(c), g = c.substr((d + "").length), y = "=" === p.charAt(1), y ? (f = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), f *= parseFloat(p), v = p.substr((f + "").length - (0 > f ? 1 : 0)) || "") : (f = parseFloat(p), v = p.substr((f + "").length)), "" === v && (v = r[i] || g), v !== g && (T = $(e, "borderLeft", d, g), x = $(e, "borderTop", d, g), "%" === v ? (c = 100 * (T / m) + "%", u = 100 * (x / E) + "%") : "em" === v ? (_ = $(e, "borderLeft", 1, "em"), c = T / _ + "em", u = x / _ + "em") : (c = T + "px", u = x + "px"), y && (p = parseFloat(c) + f + v, h = parseFloat(u) + f + v)), a = Et(b, R[l], c + " " + u, p + " " + h, !1, "0px", a);
                        return a
                    },
                    prefix: !0,
                    formatter: ct("0px 0px 0px 0px", !1, !0)
                }), yt("backgroundPosition", {
                    defaultValue: "0 0",
                    parser: function(e, t, i, r, o, a) {
                        var s, l, h, u, c, p, d = "background-position",
                            f = n || Y(e, null),
                            E = this.format((f ? m ? f.getPropertyValue(d + "-x") + " " + f.getPropertyValue(d + "-y") : f.getPropertyValue(d) : e.currentStyle.backgroundPositionX + " " + e.currentStyle.backgroundPositionY) || "0 0"),
                            v = this.format(t);
                        if (-1 !== E.indexOf("%") != (-1 !== v.indexOf("%")) && (p = Q(e, "backgroundImage").replace(M, ""), p && "none" !== p)) {
                            for (s = E.split(" "), l = v.split(" "), B.setAttribute("src", p), h = 2; --h > -1;) E = s[h], u = -1 !== E.indexOf("%"), u !== (-1 !== l[h].indexOf("%")) && (c = 0 === h ? e.offsetWidth - B.width : e.offsetHeight - B.height, s[h] = u ? parseFloat(E) / 100 * c + "px" : 100 * (parseFloat(E) / c) + "%");
                            E = s.join(" ")
                        }
                        return this.parseComplex(e.style, E, v, o, a)
                    },
                    formatter: rt
                }), yt("backgroundSize", {
                    defaultValue: "0 0",
                    formatter: rt
                }), yt("perspective", {
                    defaultValue: "0px",
                    prefix: !0
                }), yt("perspectiveOrigin", {
                    defaultValue: "50% 50%",
                    prefix: !0
                }), yt("transformStyle", {
                    prefix: !0
                }), yt("backfaceVisibility", {
                    prefix: !0
                }), yt("userSelect", {
                    prefix: !0
                }), yt("margin", {
                    parser: pt("marginTop,marginRight,marginBottom,marginLeft")
                }), yt("padding", {
                    parser: pt("paddingTop,paddingRight,paddingBottom,paddingLeft")
                }), yt("clip", {
                    defaultValue: "rect(0px,0px,0px,0px)",
                    parser: function(e, t, i, r, o, a) {
                        var s, l, h;
                        return 9 > m ? (l = e.currentStyle, h = 8 > m ? " " : ",", s = "rect(" + l.clipTop + h + l.clipRight + h + l.clipBottom + h + l.clipLeft + ")", t = this.format(t).split(",").join(h)) : (s = this.format(Q(e, this.p, n, !1, this.dflt)), t = this.format(t)), this.parseComplex(e.style, s, t, o, a)
                    }
                }), yt("textShadow", {
                    defaultValue: "0px 0px 0px #999",
                    color: !0,
                    multi: !0
                }), yt("autoRound,strictUnits", {
                    parser: function(e, t, i, r, n) {
                        return n
                    }
                }), yt("border", {
                    defaultValue: "0px solid #000",
                    parser: function(e, t, i, r, o, a) {
                        return this.parseComplex(e.style, this.format(Q(e, "borderTopWidth", n, !1, "0px") + " " + Q(e, "borderTopStyle", n, !1, "solid") + " " + Q(e, "borderTopColor", n, !1, "#000")), this.format(t), o, a)
                    },
                    color: !0,
                    formatter: function(e) {
                        var t = e.split(" ");
                        return t[0] + " " + (t[1] || "solid") + " " + (e.match(ut) || ["#000"])[0]
                    }
                }), yt("borderWidth", {
                    parser: pt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                }), yt("float,cssFloat,styleFloat", {
                    parser: function(e, t, i, r, n) {
                        var o = e.style,
                            a = "cssFloat" in o ? "cssFloat" : "styleFloat";
                        return new ft(o, a, 0, 0, n, -1, i, !1, 0, o[a], t)
                    }
                });
                var Bt = function(e) {
                    var t, i = this.t,
                        r = i.filter || Q(this.data, "filter") || "",
                        n = 0 | this.s + this.c * e;
                    100 === n && (-1 === r.indexOf("atrix(") && -1 === r.indexOf("radient(") && -1 === r.indexOf("oader(") ? (i.removeAttribute("filter"), t = !Q(this.data, "filter")) : (i.filter = r.replace(R, ""), t = !0)), t || (this.xn1 && (i.filter = r = r || "alpha(opacity=" + n + ")"), -1 === r.indexOf("pacity") ? 0 === n && this.xn1 || (i.filter = r + " alpha(opacity=" + n + ")") : i.filter = r.replace(x, "opacity=" + n))
                };
                yt("opacity,alpha,autoAlpha", {
                    defaultValue: "1",
                    parser: function(e, t, i, r, o, a) {
                        var s = parseFloat(Q(e, "opacity", n, !1, "1")),
                            l = e.style,
                            h = "autoAlpha" === i;
                        return "string" == typeof t && "=" === t.charAt(1) && (t = ("-" === t.charAt(0) ? -1 : 1) * parseFloat(t.substr(2)) + s), h && 1 === s && "hidden" === Q(e, "visibility", n) && 0 !== t && (s = 0), I ? o = new ft(l, "opacity", s, t - s, o) : (o = new ft(l, "opacity", 100 * s, 100 * (t - s), o), o.xn1 = h ? 1 : 0, l.zoom = 1, o.type = 2, o.b = "alpha(opacity=" + o.s + ")", o.e = "alpha(opacity=" + (o.s + o.c) + ")", o.data = e, o.plugin = a, o.setRatio = Bt), h && (o = new ft(l, "visibility", 0, 0, o, -1, null, !1, 0, 0 !== s ? "inherit" : "hidden", 0 === t ? "hidden" : "inherit"), o.xs0 = "inherit", r._overwriteProps.push(o.n), r._overwriteProps.push(i)), o
                    }
                });
                var zt = function(e, t) {
                        t && (e.removeProperty ? (("ms" === t.substr(0, 2) || "webkit" === t.substr(0, 6)) && (t = "-" + t), e.removeProperty(t.replace(H, "-$1").toLowerCase())) : e.removeAttribute(t))
                    },
                    Vt = function(e) {
                        if (this.t._gsClassPT = this, 1 === e || 0 === e) {
                            this.t.setAttribute("class", 0 === e ? this.b : this.e);
                            for (var t = this.data, i = this.t.style; t;) t.v ? i[t.p] = t.v : zt(i, t.p), t = t._next;
                            1 === e && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                        } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
                    };
                yt("className", {
                    parser: function(e, t, r, o, a, s, l) {
                        var h, u, c, p, d, f = e.getAttribute("class") || "",
                            m = e.style.cssText;
                        if (a = o._classNamePT = new ft(e, r, 0, 0, a, 2), a.setRatio = Vt, a.pr = -11, i = !0, a.b = f, u = Z(e, n), c = e._gsClassPT) {
                            for (p = {}, d = c.data; d;) p[d.p] = 1, d = d._next;
                            c.setRatio(1)
                        }
                        return e._gsClassPT = a, a.e = "=" !== t.charAt(1) ? t : f.replace(RegExp("\\s*\\b" + t.substr(2) + "\\b"), "") + ("+" === t.charAt(0) ? " " + t.substr(2) : ""), e.setAttribute("class", a.e), h = J(e, u, Z(e), l, p), e.setAttribute("class", f), a.data = h.firstMPT, e.style.cssText = m, a = a.xfirst = o.parse(e, h.difs, a, s)
                    }
                });
                var It = function(e) {
                    if ((1 === e || 0 === e) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                        var t, i, r, n, o, a = this.t.style,
                            s = l.transform.parse;
                        if ("all" === this.e) a.cssText = "", n = !0;
                        else
                            for (t = this.e.split(" ").join("").split(","), r = t.length; --r > -1;) i = t[r], l[i] && (l[i].parse === s ? n = !0 : i = "transformOrigin" === i ? Ht : l[i].p), zt(a, i);
                        n && (zt(a, Rt), o = this.t._gsTransform, o && (o.svg && this.t.removeAttribute("data-svg-origin"), delete this.t._gsTransform))
                    }
                };
                for (yt("clearProps", {
                        parser: function(e, t, r, n, o) {
                            return o = new ft(e, r, 0, 0, o, 2), o.setRatio = It, o.e = t, o.pr = -10, o.data = n._tween, i = !0, o
                        }
                    }), h = "bezier,throwProps,physicsProps,physics2D".split(","), vt = h.length; vt--;) Tt(h[vt]);
                h = a.prototype, h._firstPT = h._lastParsedTransform = h._transform = null, h._onInitTween = function(e, t, s) {
                    if (!e.nodeType) return !1;
                    this._target = e, this._tween = s, this._vars = t, u = t.autoRound, i = !1, r = t.suffixMap || a.suffixMap, n = Y(e, ""), o = this._overwriteProps;
                    var h, d, m, E, v, g, y, T, x, R = e.style;
                    if (c && "" === R.zIndex && (h = Q(e, "zIndex", n), ("auto" === h || "" === h) && this._addLazySet(R, "zIndex", 0)), "string" == typeof t && (E = R.cssText, h = Z(e, n), R.cssText = E + ";" + t, h = J(e, h, Z(e)).difs, !I && _.test(t) && (h.opacity = parseFloat(RegExp.$1)), t = h, R.cssText = E), this._firstPT = d = t.className ? l.className.parse(e, t.className, "className", this, null, null, t) : this.parse(e, t, null), this._transformType) {
                        for (x = 3 === this._transformType, Rt ? p && (c = !0, "" === R.zIndex && (y = Q(e, "zIndex", n), ("auto" === y || "" === y) && this._addLazySet(R, "zIndex", 0)), f && this._addLazySet(R, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (x ? "visible" : "hidden"))) : R.zoom = 1, m = d; m && m._next;) m = m._next;
                        T = new ft(e, "transform", 0, 0, null, 2), this._linkCSSP(T, null, m), T.setRatio = Rt ? Nt : Ut, T.data = this._transform || kt(e, n, !0), T.tween = s, T.pr = -1, o.pop()
                    }
                    if (i) {
                        for (; d;) {
                            for (g = d._next, m = E; m && m.pr > d.pr;) m = m._next;
                            (d._prev = m ? m._prev : v) ? d._prev._next = d: E = d, (d._next = m) ? m._prev = d : v = d, d = g
                        }
                        this._firstPT = E
                    }
                    return !0
                }, h.parse = function(e, t, i, o) {
                    var a, s, h, c, p, d, f, m, E, v, g = e.style;
                    for (a in t) d = t[a], s = l[a], s ? i = s.parse(e, d, a, this, i, o, t) : (p = Q(e, a, n) + "", E = "string" == typeof d, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || E && b.test(d) ? (E || (d = ht(d), d = (d.length > 3 ? "rgba(" : "rgb(") + d.join(",") + ")"), i = Et(g, a, p, d, !0, "transparent", i, 0, o)) : !E || -1 === d.indexOf(" ") && -1 === d.indexOf(",") ? (h = parseFloat(p), f = h || 0 === h ? p.substr((h + "").length) : "", ("" === p || "auto" === p) && ("width" === a || "height" === a ? (h = it(e, a, n), f = "px") : "left" === a || "top" === a ? (h = K(e, a, n), f = "px") : (h = "opacity" !== a ? 0 : 1, f = "")), v = E && "=" === d.charAt(1), v ? (c = parseInt(d.charAt(0) + "1", 10), d = d.substr(2), c *= parseFloat(d), m = d.replace(T, "")) : (c = parseFloat(d), m = E ? d.replace(T, "") : ""), "" === m && (m = a in r ? r[a] : f), d = c || 0 === c ? (v ? c + h : c) + m : t[a], f !== m && "" !== m && (c || 0 === c) && h && (h = $(e, a, h, f), "%" === m ? (h /= $(e, a, 100, "%") / 100, t.strictUnits !== !0 && (p = h + "%")) : "em" === m ? h /= $(e, a, 1, "em") : "px" !== m && (c = $(e, a, c, m), m = "px"), v && (c || 0 === c) && (d = c + h + m)), v && (c += h), !h && 0 !== h || !c && 0 !== c ? void 0 !== g[a] && (d || "NaN" != d + "" && null != d) ? (i = new ft(g, a, c || h || 0, 0, i, -1, a, !1, 0, p, d), i.xs0 = "none" !== d || "display" !== a && -1 === a.indexOf("Style") ? d : p) : G("invalid " + a + " tween value: " + t[a]) : (i = new ft(g, a, h, c - h, i, 0, a, u !== !1 && ("px" === m || "zIndex" === a), 0, p, d), i.xs0 = m)) : i = Et(g, a, p, d, !0, null, i, 0, o)), o && i && !i.plugin && (i.plugin = o);
                    return i
                }, h.setRatio = function(e) {
                    var t, i, r, n = this._firstPT,
                        o = 1e-6;
                    if (1 !== e || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                        if (e || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6)
                            for (; n;) {
                                if (t = n.c * e + n.s, n.r ? t = Math.round(t) : o > t && t > -o && (t = 0), n.type)
                                    if (1 === n.type)
                                        if (r = n.l, 2 === r) n.t[n.p] = n.xs0 + t + n.xs1 + n.xn1 + n.xs2;
                                        else if (3 === r) n.t[n.p] = n.xs0 + t + n.xs1 + n.xn1 + n.xs2 + n.xn2 + n.xs3;
                                else if (4 === r) n.t[n.p] = n.xs0 + t + n.xs1 + n.xn1 + n.xs2 + n.xn2 + n.xs3 + n.xn3 + n.xs4;
                                else if (5 === r) n.t[n.p] = n.xs0 + t + n.xs1 + n.xn1 + n.xs2 + n.xn2 + n.xs3 + n.xn3 + n.xs4 + n.xn4 + n.xs5;
                                else {
                                    for (i = n.xs0 + t + n.xs1, r = 1; n.l > r; r++) i += n["xn" + r] + n["xs" + (r + 1)];
                                    n.t[n.p] = i
                                } else -1 === n.type ? n.t[n.p] = n.xs0 : n.setRatio && n.setRatio(e);
                                else n.t[n.p] = t + n.xs0;
                                n = n._next
                            } else
                                for (; n;) 2 !== n.type ? n.t[n.p] = n.b : n.setRatio(e), n = n._next;
                        else
                            for (; n;) {
                                if (2 !== n.type)
                                    if (n.r && -1 !== n.type)
                                        if (t = Math.round(n.s + n.c), n.type) {
                                            if (1 === n.type) {
                                                for (r = n.l, i = n.xs0 + t + n.xs1, r = 1; n.l > r; r++) i += n["xn" + r] + n["xs" + (r + 1)];
                                                n.t[n.p] = i
                                            }
                                        } else n.t[n.p] = t + n.xs0;
                                else n.t[n.p] = n.e;
                                else n.setRatio(e);
                                n = n._next
                            }
                }, h._enableTransforms = function(e) {
                    this._transform = this._transform || kt(this._target, n, !0), this._transformType = this._transform.svg && xt || !e && 3 !== this._transformType ? 2 : 3
                };
                var jt = function() {
                    this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
                };
                h._addLazySet = function(e, t, i) {
                    var r = this._firstPT = new ft(e, t, 0, 0, this._firstPT, 2);
                    r.e = i, r.setRatio = jt, r.data = this
                }, h._linkCSSP = function(e, t, i, r) {
                    return e && (t && (t._prev = e), e._next && (e._next._prev = e._prev), e._prev ? e._prev._next = e._next : this._firstPT === e && (this._firstPT = e._next, r = !0), i ? i._next = e : r || null !== this._firstPT || (this._firstPT = e), e._next = t, e._prev = i), e
                }, h._kill = function(t) {
                    var i, r, n, o = t;
                    if (t.autoAlpha || t.alpha) {
                        o = {};
                        for (r in t) o[r] = t[r];
                        o.opacity = 1, o.autoAlpha && (o.visibility = 1)
                    }
                    return t.className && (i = this._classNamePT) && (n = i.xfirst, n && n._prev ? this._linkCSSP(n._prev, i._next, n._prev._prev) : n === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, n._prev), this._classNamePT = null), e.prototype._kill.call(this, o)
                };
                var Gt = function(e, t, i) {
                    var r, n, o, a;
                    if (e.slice)
                        for (n = e.length; --n > -1;) Gt(e[n], t, i);
                    else
                        for (r = e.childNodes, n = r.length; --n > -1;) o = r[n], a = o.type, o.style && (t.push(Z(o)), i && i.push(o)), 1 !== a && 9 !== a && 11 !== a || !o.childNodes.length || Gt(o, t, i)
                };
                return a.cascadeTo = function(e, i, r) {
                    var n, o, a, s, l = t.to(e, i, r),
                        h = [l],
                        u = [],
                        c = [],
                        p = [],
                        d = t._internals.reservedProps;
                    for (e = l._targets || l.target, Gt(e, u, p), l.render(i, !0, !0), Gt(e, c), l.render(0, !0, !0), l._enabled(!0), n = p.length; --n > -1;)
                        if (o = J(p[n], u[n], c[n]), o.firstMPT) {
                            o = o.difs;
                            for (a in r) d[a] && (o[a] = r[a]);
                            s = {};
                            for (a in o) s[a] = u[n][a];
                            h.push(t.fromTo(p[n], i, s, o))
                        }
                    return h
                }, e.activate([a]), a
            }, !0),
            function() {
                var e = _gsScope._gsDefine.plugin({
                        propName: "roundProps",
                        priority: -1,
                        API: 2,
                        init: function(e, t, i) {
                            return this._tween = i, !0
                        }
                    }),
                    t = e.prototype;
                t._onInitAllProps = function() {
                    for (var e, t, i, r = this._tween, n = r.vars.roundProps instanceof Array ? r.vars.roundProps : r.vars.roundProps.split(","), o = n.length, a = {}, s = r._propLookup.roundProps; --o > -1;) a[n[o]] = 1;
                    for (o = n.length; --o > -1;)
                        for (e = n[o], t = r._firstPT; t;) i = t._next, t.pg ? t.t._roundProps(a, !0) : t.n === e && (this._add(t.t, e, t.s, t.c), i && (i._prev = t._prev), t._prev ? t._prev._next = i : r._firstPT === t && (r._firstPT = i), t._next = t._prev = null, r._propLookup[e] = s), t = i;
                    return !1
                }, t._add = function(e, t, i, r) {
                    this._addTween(e, t, i, i + r, t, !0), this._overwriteProps.push(t)
                }
            }(),
            function() {
                var e = /(?:\d|\-|\+|=|#|\.)*/g,
                    t = /[A-Za-z%]/g;
                _gsScope._gsDefine.plugin({
                    propName: "attr",
                    API: 2,
                    version: "0.4.0",
                    init: function(i, r) {
                        var n, o, a, s, l;
                        if ("function" != typeof i.setAttribute) return !1;
                        this._target = i, this._proxy = {}, this._start = {}, this._end = {}, this._suffix = {};
                        for (n in r) this._start[n] = this._proxy[n] = o = i.getAttribute(n) + "", this._end[n] = a = r[n] + "", this._suffix[n] = s = t.test(a) ? a.replace(e, "") : t.test(o) ? o.replace(e, "") : "", s && (l = a.indexOf(s), -1 !== l && (a = a.substr(0, l))), this._addTween(this._proxy, n, parseFloat(o), a, n) || (this._suffix[n] = ""), "=" === a.charAt(1) && (this._end[n] = this._firstPT.s + this._firstPT.c + s), this._overwriteProps.push(n);
                        return !0
                    },
                    set: function(e) {
                        this._super.setRatio.call(this, e);
                        for (var t, i = this._overwriteProps, r = i.length, n = 1 === e ? this._end : e ? this._proxy : this._start, o = n === this._proxy; --r > -1;) t = i[r], this._target.setAttribute(t, n[t] + (o ? this._suffix[t] : ""))
                    }
                })
            }(), _gsScope._gsDefine.plugin({
                propName: "directionalRotation",
                version: "0.2.1",
                API: 2,
                init: function(e, t) {
                    "object" != typeof t && (t = {
                        rotation: t
                    }), this.finals = {};
                    var i, r, n, o, a, s, l = t.useRadians === !0 ? 2 * Math.PI : 360,
                        h = 1e-6;
                    for (i in t) "useRadians" !== i && (s = (t[i] + "").split("_"), r = s[0], n = parseFloat("function" != typeof e[i] ? e[i] : e[i.indexOf("set") || "function" != typeof e["get" + i.substr(3)] ? i : "get" + i.substr(3)]()), o = this.finals[i] = "string" == typeof r && "=" === r.charAt(1) ? n + parseInt(r.charAt(0) + "1", 10) * Number(r.substr(2)) : Number(r) || 0, a = o - n, s.length && (r = s.join("_"), -1 !== r.indexOf("short") && (a %= l, a !== a % (l / 2) && (a = 0 > a ? a + l : a - l)), -1 !== r.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * l) % l - (0 | a / l) * l : -1 !== r.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * l) % l - (0 | a / l) * l)), (a > h || -h > a) && (this._addTween(e, i, n, n + a, i), this._overwriteProps.push(i)));
                    return !0
                },
                set: function(e) {
                    var t;
                    if (1 !== e) this._super.setRatio.call(this, e);
                    else
                        for (t = this._firstPT; t;) t.f ? t.t[t.p](this.finals[t.p]) : t.t[t.p] = this.finals[t.p], t = t._next
                }
            })._autoCSS = !0, _gsScope._gsDefine("easing.Back", ["easing.Ease"], function(e) {
                var t, i, r, n = _gsScope.GreenSockGlobals || _gsScope,
                    o = n.com.greensock,
                    a = 2 * Math.PI,
                    s = Math.PI / 2,
                    l = o._class,
                    h = function(t, i) {
                        var r = l("easing." + t, function() {}, !0),
                            n = r.prototype = new e;
                        return n.constructor = r, n.getRatio = i, r
                    },
                    u = e.register || function() {},
                    c = function(e, t, i, r) {
                        var n = l("easing." + e, {
                            easeOut: new t,
                            easeIn: new i,
                            easeInOut: new r
                        }, !0);
                        return u(n, e), n
                    },
                    p = function(e, t, i) {
                        this.t = e, this.v = t, i && (this.next = i, i.prev = this, this.c = i.v - t, this.gap = i.t - e)
                    },
                    d = function(t, i) {
                        var r = l("easing." + t, function(e) {
                                this._p1 = e || 0 === e ? e : 1.70158, this._p2 = 1.525 * this._p1
                            }, !0),
                            n = r.prototype = new e;
                        return n.constructor = r, n.getRatio = i, n.config = function(e) {
                            return new r(e)
                        }, r
                    },
                    f = c("Back", d("BackOut", function(e) {
                        return (e -= 1) * e * ((this._p1 + 1) * e + this._p1) + 1
                    }), d("BackIn", function(e) {
                        return e * e * ((this._p1 + 1) * e - this._p1)
                    }), d("BackInOut", function(e) {
                        return 1 > (e *= 2) ? .5 * e * e * ((this._p2 + 1) * e - this._p2) : .5 * ((e -= 2) * e * ((this._p2 + 1) * e + this._p2) + 2)
                    })),
                    m = l("easing.SlowMo", function(e, t, i) {
                        t = t || 0 === t ? t : .7, null == e ? e = .7 : e > 1 && (e = 1), this._p = 1 !== e ? t : 0, this._p1 = (1 - e) / 2, this._p2 = e, this._p3 = this._p1 + this._p2, this._calcEnd = i === !0
                    }, !0),
                    E = m.prototype = new e;
                return E.constructor = m, E.getRatio = function(e) {
                    var t = e + (.5 - e) * this._p;
                    return this._p1 > e ? this._calcEnd ? 1 - (e = 1 - e / this._p1) * e : t - (e = 1 - e / this._p1) * e * e * e * t : e > this._p3 ? this._calcEnd ? 1 - (e = (e - this._p3) / this._p1) * e : t + (e - t) * (e = (e - this._p3) / this._p1) * e * e * e : this._calcEnd ? 1 : t
                }, m.ease = new m(.7, .7), E.config = m.config = function(e, t, i) {
                    return new m(e, t, i)
                }, t = l("easing.SteppedEase", function(e) {
                    e = e || 1, this._p1 = 1 / e, this._p2 = e + 1
                }, !0), E = t.prototype = new e, E.constructor = t, E.getRatio = function(e) {
                    return 0 > e ? e = 0 : e >= 1 && (e = .999999999), (this._p2 * e >> 0) * this._p1
                }, E.config = t.config = function(e) {
                    return new t(e)
                }, i = l("easing.RoughEase", function(t) {
                    t = t || {};
                    for (var i, r, n, o, a, s, l = t.taper || "none", h = [], u = 0, c = 0 | (t.points || 20), d = c, f = t.randomize !== !1, m = t.clamp === !0, E = t.template instanceof e ? t.template : null, v = "number" == typeof t.strength ? .4 * t.strength : .4; --d > -1;) i = f ? Math.random() : 1 / c * d, r = E ? E.getRatio(i) : i, "none" === l ? n = v : "out" === l ? (o = 1 - i, n = o * o * v) : "in" === l ? n = i * i * v : .5 > i ? (o = 2 * i, n = .5 * o * o * v) : (o = 2 * (1 - i), n = .5 * o * o * v), f ? r += Math.random() * n - .5 * n : d % 2 ? r += .5 * n : r -= .5 * n, m && (r > 1 ? r = 1 : 0 > r && (r = 0)), h[u++] = {
                        x: i,
                        y: r
                    };
                    for (h.sort(function(e, t) {
                            return e.x - t.x
                        }), s = new p(1, 1, null), d = c; --d > -1;) a = h[d], s = new p(a.x, a.y, s);
                    this._prev = new p(0, 0, 0 !== s.t ? s : s.next)
                }, !0), E = i.prototype = new e, E.constructor = i, E.getRatio = function(e) {
                    var t = this._prev;
                    if (e > t.t) {
                        for (; t.next && e >= t.t;) t = t.next;
                        t = t.prev
                    } else
                        for (; t.prev && t.t >= e;) t = t.prev;
                    return this._prev = t, t.v + (e - t.t) / t.gap * t.c
                }, E.config = function(e) {
                    return new i(e)
                }, i.ease = new i, c("Bounce", h("BounceOut", function(e) {
                    return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                }), h("BounceIn", function(e) {
                    return 1 / 2.75 > (e = 1 - e) ? 1 - 7.5625 * e * e : 2 / 2.75 > e ? 1 - (7.5625 * (e -= 1.5 / 2.75) * e + .75) : 2.5 / 2.75 > e ? 1 - (7.5625 * (e -= 2.25 / 2.75) * e + .9375) : 1 - (7.5625 * (e -= 2.625 / 2.75) * e + .984375)
                }), h("BounceInOut", function(e) {
                    var t = .5 > e;
                    return e = t ? 1 - 2 * e : 2 * e - 1, e = 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375, t ? .5 * (1 - e) : .5 * e + .5
                })), c("Circ", h("CircOut", function(e) {
                    return Math.sqrt(1 - (e -= 1) * e)
                }), h("CircIn", function(e) {
                    return -(Math.sqrt(1 - e * e) - 1)
                }), h("CircInOut", function(e) {
                    return 1 > (e *= 2) ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
                })), r = function(t, i, r) {
                    var n = l("easing." + t, function(e, t) {
                            this._p1 = e >= 1 ? e : 1, this._p2 = (t || r) / (1 > e ? e : 1), this._p3 = this._p2 / a * (Math.asin(1 / this._p1) || 0), this._p2 = a / this._p2
                        }, !0),
                        o = n.prototype = new e;
                    return o.constructor = n, o.getRatio = i, o.config = function(e, t) {
                        return new n(e, t)
                    }, n
                }, c("Elastic", r("ElasticOut", function(e) {
                    return this._p1 * Math.pow(2, -10 * e) * Math.sin((e - this._p3) * this._p2) + 1
                }, .3), r("ElasticIn", function(e) {
                    return -(this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2))
                }, .3), r("ElasticInOut", function(e) {
                    return 1 > (e *= 2) ? -.5 * this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) : .5 * this._p1 * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) + 1
                }, .45)), c("Expo", h("ExpoOut", function(e) {
                    return 1 - Math.pow(2, -10 * e)
                }), h("ExpoIn", function(e) {
                    return Math.pow(2, 10 * (e - 1)) - .001
                }), h("ExpoInOut", function(e) {
                    return 1 > (e *= 2) ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
                })), c("Sine", h("SineOut", function(e) {
                    return Math.sin(e * s)
                }), h("SineIn", function(e) {
                    return -Math.cos(e * s) + 1
                }), h("SineInOut", function(e) {
                    return -.5 * (Math.cos(Math.PI * e) - 1)
                })), l("easing.EaseLookup", {
                    find: function(t) {
                        return e.map[t]
                    }
                }, !0), u(n.SlowMo, "SlowMo", "ease,"), u(i, "RoughEase", "ease,"), u(t, "SteppedEase", "ease,"), f
            }, !0)
    }), _gsScope._gsDefine && _gsScope._gsQueue.pop()(),
    function(e, t) {
        "use strict";
        var i = e.GreenSockGlobals = e.GreenSockGlobals || e;
        if (!i.TweenLite) {
            var r, n, o, a, s, l = function(e) {
                    var t, r = e.split("."),
                        n = i;
                    for (t = 0; r.length > t; t++) n[r[t]] = n = n[r[t]] || {};
                    return n
                },
                h = l("com.greensock"),
                u = 1e-10,
                c = function(e) {
                    var t, i = [],
                        r = e.length;
                    for (t = 0; t !== r; i.push(e[t++]));
                    return i
                },
                p = function() {},
                d = function() {
                    var e = Object.prototype.toString,
                        t = e.call([]);
                    return function(i) {
                        return null != i && (i instanceof Array || "object" == typeof i && !!i.push && e.call(i) === t)
                    }
                }(),
                f = {},
                m = function(r, n, o, a) {
                    this.sc = f[r] ? f[r].sc : [], f[r] = this, this.gsClass = null, this.func = o;
                    var s = [];
                    this.check = function(h) {
                        for (var u, c, p, d, E = n.length, v = E; --E > -1;)(u = f[n[E]] || new m(n[E], [])).gsClass ? (s[E] = u.gsClass, v--) : h && u.sc.push(this);
                        if (0 === v && o)
                            for (c = ("com.greensock." + r).split("."), p = c.pop(), d = l(c.join("."))[p] = this.gsClass = o.apply(o, s), a && (i[p] = d, "function" == typeof define && define.amd ? define((e.GreenSockAMDPath ? e.GreenSockAMDPath + "/" : "") + r.split(".").pop(), [], function() {
                                    return d
                                }) : r === t && "undefined" != typeof module && module.exports && (module.exports = d)), E = 0; this.sc.length > E; E++) this.sc[E].check()
                    }, this.check(!0)
                },
                E = e._gsDefine = function(e, t, i, r) {
                    return new m(e, t, i, r)
                },
                v = h._class = function(e, t, i) {
                    return t = t || function() {}, E(e, [], function() {
                        return t
                    }, i), t
                };
            E.globals = i;
            var g = [0, 0, 1, 1],
                y = [],
                T = v("easing.Ease", function(e, t, i, r) {
                    this._func = e, this._type = i || 0, this._power = r || 0, this._params = t ? g.concat(t) : g
                }, !0),
                x = T.map = {},
                _ = T.register = function(e, t, i, r) {
                    for (var n, o, a, s, l = t.split(","), u = l.length, c = (i || "easeIn,easeOut,easeInOut").split(","); --u > -1;)
                        for (o = l[u], n = r ? v("easing." + o, null, !0) : h.easing[o] || {}, a = c.length; --a > -1;) s = c[a], x[o + "." + s] = x[s + o] = n[s] = e.getRatio ? e : e[s] || new e
                };
            for (o = T.prototype, o._calcEnd = !1, o.getRatio = function(e) {
                    if (this._func) return this._params[0] = e, this._func.apply(null, this._params);
                    var t = this._type,
                        i = this._power,
                        r = 1 === t ? 1 - e : 2 === t ? e : .5 > e ? 2 * e : 2 * (1 - e);
                    return 1 === i ? r *= r : 2 === i ? r *= r * r : 3 === i ? r *= r * r * r : 4 === i && (r *= r * r * r * r), 1 === t ? 1 - r : 2 === t ? r : .5 > e ? r / 2 : 1 - r / 2
                }, r = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], n = r.length; --n > -1;) o = r[n] + ",Power" + n, _(new T(null, null, 1, n), o, "easeOut", !0), _(new T(null, null, 2, n), o, "easeIn" + (0 === n ? ",easeNone" : "")), _(new T(null, null, 3, n), o, "easeInOut");
            x.linear = h.easing.Linear.easeIn, x.swing = h.easing.Quad.easeInOut;
            var R = v("events.EventDispatcher", function(e) {
                this._listeners = {}, this._eventTarget = e || this
            });
            o = R.prototype, o.addEventListener = function(e, t, i, r, n) {
                n = n || 0;
                var o, l, h = this._listeners[e],
                    u = 0;
                for (null == h && (this._listeners[e] = h = []), l = h.length; --l > -1;) o = h[l], o.c === t && o.s === i ? h.splice(l, 1) : 0 === u && n > o.pr && (u = l + 1);
                h.splice(u, 0, {
                    c: t,
                    s: i,
                    up: r,
                    pr: n
                }), this !== a || s || a.wake()
            }, o.removeEventListener = function(e, t) {
                var i, r = this._listeners[e];
                if (r)
                    for (i = r.length; --i > -1;)
                        if (r[i].c === t) return void r.splice(i, 1)
            }, o.dispatchEvent = function(e) {
                var t, i, r, n = this._listeners[e];
                if (n)
                    for (t = n.length, i = this._eventTarget; --t > -1;) r = n[t], r && (r.up ? r.c.call(r.s || i, {
                        type: e,
                        target: i
                    }) : r.c.call(r.s || i))
            };
            var b = e.requestAnimationFrame,
                H = e.cancelAnimationFrame,
                w = Date.now || function() {
                    return (new Date).getTime()
                },
                M = w();
            for (r = ["ms", "moz", "webkit", "o"], n = r.length; --n > -1 && !b;) b = e[r[n] + "RequestAnimationFrame"], H = e[r[n] + "CancelAnimationFrame"] || e[r[n] + "CancelRequestAnimationFrame"];
            v("Ticker", function(e, t) {
                var i, r, n, o, l, h = this,
                    c = w(),
                    d = t !== !1 && b,
                    f = 500,
                    m = 33,
                    E = "tick",
                    v = function(e) {
                        var t, a, s = w() - M;
                        s > f && (c += s - m), M += s, h.time = (M - c) / 1e3, t = h.time - l, (!i || t > 0 || e === !0) && (h.frame++, l += t + (t >= o ? .004 : o - t), a = !0), e !== !0 && (n = r(v)), a && h.dispatchEvent(E)
                    };
                R.call(h), h.time = h.frame = 0, h.tick = function() {
                    v(!0)
                }, h.lagSmoothing = function(e, t) {
                    f = e || 1 / u, m = Math.min(t, f, 0)
                }, h.sleep = function() {
                    null != n && (d && H ? H(n) : clearTimeout(n), r = p, n = null, h === a && (s = !1))
                }, h.wake = function() {
                    null !== n ? h.sleep() : h.frame > 10 && (M = w() - f + 5), r = 0 === i ? p : d && b ? b : function(e) {
                        return setTimeout(e, 0 | 1e3 * (l - h.time) + 1)
                    }, h === a && (s = !0), v(2)
                }, h.fps = function(e) {
                    return arguments.length ? (i = e, o = 1 / (i || 60), l = this.time + o, void h.wake()) : i
                }, h.useRAF = function(e) {
                    return arguments.length ? (h.sleep(), d = e, void h.fps(i)) : d
                }, h.fps(e), setTimeout(function() {
                    d && 5 > h.frame && h.useRAF(!1)
                }, 1500)
            }), o = h.Ticker.prototype = new h.events.EventDispatcher, o.constructor = h.Ticker;
            var S = v("core.Animation", function(e, t) {
                if (this.vars = t = t || {}, this._duration = this._totalDuration = e || 0, this._delay = Number(t.delay) || 0, this._timeScale = 1, this._active = t.immediateRender === !0, this.data = t.data, this._reversed = t.reversed === !0, j) {
                    s || a.wake();
                    var i = this.vars.useFrames ? I : j;
                    i.add(this, i._time), this.vars.paused && this.paused(!0)
                }
            });
            a = S.ticker = new h.Ticker, o = S.prototype, o._dirty = o._gc = o._initted = o._paused = !1, o._totalTime = o._time = 0, o._rawPrevTime = -1, o._next = o._last = o._onUpdate = o._timeline = o.timeline = null, o._paused = !1;
            var C = function() {
                s && w() - M > 2e3 && a.wake(), setTimeout(C, 2e3)
            };
            C(), o.play = function(e, t) {
                return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
            }, o.pause = function(e, t) {
                return null != e && this.seek(e, t), this.paused(!0)
            }, o.resume = function(e, t) {
                return null != e && this.seek(e, t), this.paused(!1)
            }, o.seek = function(e, t) {
                return this.totalTime(Number(e), t !== !1)
            }, o.restart = function(e, t) {
                return this.reversed(!1).paused(!1).totalTime(e ? -this._delay : 0, t !== !1, !0)
            }, o.reverse = function(e, t) {
                return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
            }, o.render = function() {}, o.invalidate = function() {
                return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, (this._gc || !this.timeline) && this._enabled(!0), this
            }, o.isActive = function() {
                var e, t = this._timeline,
                    i = this._startTime;
                return !t || !this._gc && !this._paused && t.isActive() && (e = t.rawTime()) >= i && i + this.totalDuration() / this._timeScale > e
            }, o._enabled = function(e, t) {
                return s || a.wake(), this._gc = !e, this._active = this.isActive(), t !== !0 && (e && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !e && this.timeline && this._timeline._remove(this, !0)), !1
            }, o._kill = function() {
                return this._enabled(!1, !1)
            }, o.kill = function(e, t) {
                return this._kill(e, t), this
            }, o._uncache = function(e) {
                for (var t = e ? this : this.timeline; t;) t._dirty = !0, t = t.timeline;
                return this
            }, o._swapSelfInParams = function(e) {
                for (var t = e.length, i = e.concat(); --t > -1;) "{self}" === e[t] && (i[t] = this);
                return i
            }, o._callback = function(e) {
                var t = this.vars;
                t[e].apply(t[e + "Scope"] || t.callbackScope || this, t[e + "Params"] || y)
            }, o.eventCallback = function(e, t, i, r) {
                if ("on" === (e || "").substr(0, 2)) {
                    var n = this.vars;
                    if (1 === arguments.length) return n[e];
                    null == t ? delete n[e] : (n[e] = t, n[e + "Params"] = d(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, n[e + "Scope"] = r), "onUpdate" === e && (this._onUpdate = t)
                }
                return this
            }, o.delay = function(e) {
                return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + e - this._delay), this._delay = e, this) : this._delay
            }, o.duration = function(e) {
                return arguments.length ? (this._duration = this._totalDuration = e, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== e && this.totalTime(this._totalTime * (e / this._duration), !0), this) : (this._dirty = !1, this._duration)
            }, o.totalDuration = function(e) {
                return this._dirty = !1, arguments.length ? this.duration(e) : this._totalDuration
            }, o.time = function(e, t) {
                return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(e > this._duration ? this._duration : e, t)) : this._time
            }, o.totalTime = function(e, t, i) {
                if (s || a.wake(), !arguments.length) return this._totalTime;
                if (this._timeline) {
                    if (0 > e && !i && (e += this.totalDuration()), this._timeline.smoothChildTiming) {
                        this._dirty && this.totalDuration();
                        var r = this._totalDuration,
                            n = this._timeline;
                        if (e > r && !i && (e = r), this._startTime = (this._paused ? this._pauseTime : n._time) - (this._reversed ? r - e : e) / this._timeScale, n._dirty || this._uncache(!1), n._timeline)
                            for (; n._timeline;) n._timeline._time !== (n._startTime + n._totalTime) / n._timeScale && n.totalTime(n._totalTime, !0), n = n._timeline
                    }
                    this._gc && this._enabled(!0, !1), (this._totalTime !== e || 0 === this._duration) && (this.render(e, t, !1), O.length && W())
                }
                return this
            }, o.progress = o.totalProgress = function(e, t) {
                return arguments.length ? this.totalTime(this.duration() * e, t) : this._time / this.duration()
            }, o.startTime = function(e) {
                return arguments.length ? (e !== this._startTime && (this._startTime = e, this.timeline && this.timeline._sortChildren && this.timeline.add(this, e - this._delay)), this) : this._startTime
            }, o.endTime = function(e) {
                return this._startTime + (0 != e ? this.totalDuration() : this.duration()) / this._timeScale
            }, o.timeScale = function(e) {
                if (!arguments.length) return this._timeScale;
                if (e = e || u, this._timeline && this._timeline.smoothChildTiming) {
                    var t = this._pauseTime,
                        i = t || 0 === t ? t : this._timeline.totalTime();
                    this._startTime = i - (i - this._startTime) * this._timeScale / e
                }
                return this._timeScale = e, this._uncache(!1)
            }, o.reversed = function(e) {
                return arguments.length ? (e != this._reversed && (this._reversed = e, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
            }, o.paused = function(e) {
                if (!arguments.length) return this._paused;
                var t, i, r = this._timeline;
                return e != this._paused && r && (s || e || a.wake(), t = r.rawTime(), i = t - this._pauseTime, !e && r.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = e ? t : null, this._paused = e, this._active = this.isActive(), !e && 0 !== i && this._initted && this.duration() && this.render(r.smoothChildTiming ? this._totalTime : (t - this._startTime) / this._timeScale, !0, !0)), this._gc && !e && this._enabled(!0, !1), this
            };
            var A = v("core.SimpleTimeline", function(e) {
                S.call(this, 0, e), this.autoRemoveChildren = this.smoothChildTiming = !0
            });
            o = A.prototype = new S, o.constructor = A, o.kill()._gc = !1, o._first = o._last = o._recent = null, o._sortChildren = !1, o.add = o.insert = function(e, t) {
                var i, r;
                if (e._startTime = Number(t || 0) + e._delay, e._paused && this !== e._timeline && (e._pauseTime = e._startTime + (this.rawTime() - e._startTime) / e._timeScale), e.timeline && e.timeline._remove(e, !0), e.timeline = e._timeline = this, e._gc && e._enabled(!0, !0), i = this._last, this._sortChildren)
                    for (r = e._startTime; i && i._startTime > r;) i = i._prev;
                return i ? (e._next = i._next, i._next = e) : (e._next = this._first, this._first = e), e._next ? e._next._prev = e : this._last = e, e._prev = i, this._recent = e, this._timeline && this._uncache(!0), this
            }, o._remove = function(e, t) {
                return e.timeline === this && (t || e._enabled(!1, !0), e._prev ? e._prev._next = e._next : this._first === e && (this._first = e._next), e._next ? e._next._prev = e._prev : this._last === e && (this._last = e._prev), e._next = e._prev = e.timeline = null, e === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
            }, o.render = function(e, t, i) {
                var r, n = this._first;
                for (this._totalTime = this._time = this._rawPrevTime = e; n;) r = n._next, (n._active || e >= n._startTime && !n._paused) && (n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (e - n._startTime) * n._timeScale, t, i) : n.render((e - n._startTime) * n._timeScale, t, i)), n = r
            }, o.rawTime = function() {
                return s || a.wake(), this._totalTime
            };
            var P = v("TweenLite", function(t, i, r) {
                    if (S.call(this, i, r), this.render = P.prototype.render, null == t) throw "Cannot tween a null target.";
                    this.target = t = "string" != typeof t ? t : P.selector(t) || t;
                    var n, o, a, s = t.jquery || t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType),
                        l = this.vars.overwrite;
                    if (this._overwrite = l = null == l ? V[P.defaultOverwrite] : "number" == typeof l ? l >> 0 : V[l], (s || t instanceof Array || t.push && d(t)) && "number" != typeof t[0])
                        for (this._targets = a = c(t), this._propLookup = [], this._siblings = [], n = 0; a.length > n; n++) o = a[n], o ? "string" != typeof o ? o.length && o !== e && o[0] && (o[0] === e || o[0].nodeType && o[0].style && !o.nodeType) ? (a.splice(n--, 1), this._targets = a = a.concat(c(o))) : (this._siblings[n] = X(o, this, !1), 1 === l && this._siblings[n].length > 1 && Y(o, this, null, 1, this._siblings[n])) : (o = a[n--] = P.selector(o), "string" == typeof o && a.splice(n + 1, 1)) : a.splice(n--, 1);
                    else this._propLookup = {}, this._siblings = X(t, this, !1), 1 === l && this._siblings.length > 1 && Y(t, this, null, 1, this._siblings);
                    (this.vars.immediateRender || 0 === i && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -u, this.render(-this._delay))
                }, !0),
                L = function(t) {
                    return t && t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType)
                },
                D = function(e, t) {
                    var i, r = {};
                    for (i in e) z[i] || i in t && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!U[i] || U[i] && U[i]._autoCSS) || (r[i] = e[i], delete e[i]);
                    e.css = r
                };
            o = P.prototype = new S, o.constructor = P, o.kill()._gc = !1, o.ratio = 0, o._firstPT = o._targets = o._overwrittenProps = o._startAt = null, o._notifyPluginsOfEnabled = o._lazy = !1, P.version = "1.17.0", P.defaultEase = o._ease = new T(null, null, 1, 1), P.defaultOverwrite = "auto", P.ticker = a, P.autoSleep = 120, P.lagSmoothing = function(e, t) {
                a.lagSmoothing(e, t)
            }, P.selector = e.$ || e.jQuery || function(t) {
                var i = e.$ || e.jQuery;
                return i ? (P.selector = i, i(t)) : "undefined" == typeof document ? t : document.querySelectorAll ? document.querySelectorAll(t) : document.getElementById("#" === t.charAt(0) ? t.substr(1) : t)
            };
            var O = [],
                F = {},
                k = P._internals = {
                    isArray: d,
                    isSelector: L,
                    lazyTweens: O
                },
                U = P._plugins = {},
                N = k.tweenLookup = {},
                B = 0,
                z = k.reservedProps = {
                    ease: 1,
                    delay: 1,
                    overwrite: 1,
                    onComplete: 1,
                    onCompleteParams: 1,
                    onCompleteScope: 1,
                    useFrames: 1,
                    runBackwards: 1,
                    startAt: 1,
                    onUpdate: 1,
                    onUpdateParams: 1,
                    onUpdateScope: 1,
                    onStart: 1,
                    onStartParams: 1,
                    onStartScope: 1,
                    onReverseComplete: 1,
                    onReverseCompleteParams: 1,
                    onReverseCompleteScope: 1,
                    onRepeat: 1,
                    onRepeatParams: 1,
                    onRepeatScope: 1,
                    easeParams: 1,
                    yoyo: 1,
                    immediateRender: 1,
                    repeat: 1,
                    repeatDelay: 1,
                    data: 1,
                    paused: 1,
                    reversed: 1,
                    autoCSS: 1,
                    lazy: 1,
                    onOverwrite: 1,
                    callbackScope: 1
                },
                V = {
                    none: 0,
                    all: 1,
                    auto: 2,
                    concurrent: 3,
                    allOnStart: 4,
                    preexisting: 5,
                    "true": 1,
                    "false": 0
                },
                I = S._rootFramesTimeline = new A,
                j = S._rootTimeline = new A,
                G = 30,
                W = k.lazyRender = function() {
                    var e, t = O.length;
                    for (F = {}; --t > -1;) e = O[t], e && e._lazy !== !1 && (e.render(e._lazy[0], e._lazy[1], !0), e._lazy = !1);
                    O.length = 0
                };
            j._startTime = a.time, I._startTime = a.frame, j._active = I._active = !0, setTimeout(W, 1), S._updateRoot = P.render = function() {
                var e, t, i;
                if (O.length && W(), j.render((a.time - j._startTime) * j._timeScale, !1, !1), I.render((a.frame - I._startTime) * I._timeScale, !1, !1), O.length && W(), a.frame >= G) {
                    G = a.frame + (parseInt(P.autoSleep, 10) || 120);
                    for (i in N) {
                        for (t = N[i].tweens, e = t.length; --e > -1;) t[e]._gc && t.splice(e, 1);
                        0 === t.length && delete N[i]
                    }
                    if (i = j._first, (!i || i._paused) && P.autoSleep && !I._first && 1 === a._listeners.tick.length) {
                        for (; i && i._paused;) i = i._next;
                        i || a.sleep()
                    }
                }
            }, a.addEventListener("tick", S._updateRoot);
            var X = function(e, t, i) {
                    var r, n, o = e._gsTweenID;
                    if (N[o || (e._gsTweenID = o = "t" + B++)] || (N[o] = {
                            target: e,
                            tweens: []
                        }), t && (r = N[o].tweens, r[n = r.length] = t, i))
                        for (; --n > -1;) r[n] === t && r.splice(n, 1);
                    return N[o].tweens
                },
                q = function(e, t, i, r) {
                    var n, o, a = e.vars.onOverwrite;
                    return a && (n = a(e, t, i, r)), a = P.onOverwrite, a && (o = a(e, t, i, r)), n !== !1 && o !== !1
                },
                Y = function(e, t, i, r, n) {
                    var o, a, s, l;
                    if (1 === r || r >= 4) {
                        for (l = n.length, o = 0; l > o; o++)
                            if ((s = n[o]) !== t) s._gc || s._kill(null, e, t) && (a = !0);
                            else if (5 === r) break;
                        return a
                    }
                    var h, c = t._startTime + u,
                        p = [],
                        d = 0,
                        f = 0 === t._duration;
                    for (o = n.length; --o > -1;)(s = n[o]) === t || s._gc || s._paused || (s._timeline !== t._timeline ? (h = h || Q(t, 0, f), 0 === Q(s, h, f) && (p[d++] = s)) : c >= s._startTime && s._startTime + s.totalDuration() / s._timeScale > c && ((f || !s._initted) && 2e-10 >= c - s._startTime || (p[d++] = s)));
                    for (o = d; --o > -1;)
                        if (s = p[o], 2 === r && s._kill(i, e, t) && (a = !0), 2 !== r || !s._firstPT && s._initted) {
                            if (2 !== r && !q(s, t)) continue;
                            s._enabled(!1, !1) && (a = !0)
                        }
                    return a
                },
                Q = function(e, t, i) {
                    for (var r = e._timeline, n = r._timeScale, o = e._startTime; r._timeline;) {
                        if (o += r._startTime, n *= r._timeScale, r._paused) return -100;
                        r = r._timeline
                    }
                    return o /= n, o > t ? o - t : i && o === t || !e._initted && 2 * u > o - t ? u : (o += e.totalDuration() / e._timeScale / n) > t + u ? 0 : o - t - u
                };
            o._init = function() {
                var e, t, i, r, n, o = this.vars,
                    a = this._overwrittenProps,
                    s = this._duration,
                    l = !!o.immediateRender,
                    h = o.ease;
                if (o.startAt) {
                    this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), n = {};
                    for (r in o.startAt) n[r] = o.startAt[r];
                    if (n.overwrite = !1, n.immediateRender = !0, n.lazy = l && o.lazy !== !1, n.startAt = n.delay = null, this._startAt = P.to(this.target, 0, n), l)
                        if (this._time > 0) this._startAt = null;
                        else if (0 !== s) return
                } else if (o.runBackwards && 0 !== s)
                    if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                    else {
                        0 !== this._time && (l = !1), i = {};
                        for (r in o) z[r] && "autoCSS" !== r || (i[r] = o[r]);
                        if (i.overwrite = 0, i.data = "isFromStart", i.lazy = l && o.lazy !== !1, i.immediateRender = l, this._startAt = P.to(this.target, 0, i), l) {
                            if (0 === this._time) return
                        } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                    }
                if (this._ease = h = h ? h instanceof T ? h : "function" == typeof h ? new T(h, o.easeParams) : x[h] || P.defaultEase : P.defaultEase, o.easeParams instanceof Array && h.config && (this._ease = h.config.apply(h, o.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                    for (e = this._targets.length; --e > -1;) this._initProps(this._targets[e], this._propLookup[e] = {}, this._siblings[e], a ? a[e] : null) && (t = !0);
                else t = this._initProps(this.target, this._propLookup, this._siblings, a);
                if (t && P._onPluginEvent("_onInitAllProps", this), a && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), o.runBackwards)
                    for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                this._onUpdate = o.onUpdate, this._initted = !0
            }, o._initProps = function(t, i, r, n) {
                var o, a, s, l, h, u;
                if (null == t) return !1;
                F[t._gsTweenID] && W(), this.vars.css || t.style && t !== e && t.nodeType && U.css && this.vars.autoCSS !== !1 && D(this.vars, t);
                for (o in this.vars) {
                    if (u = this.vars[o], z[o]) u && (u instanceof Array || u.push && d(u)) && -1 !== u.join("").indexOf("{self}") && (this.vars[o] = u = this._swapSelfInParams(u, this));
                    else if (U[o] && (l = new U[o])._onInitTween(t, this.vars[o], this)) {
                        for (this._firstPT = h = {
                                _next: this._firstPT,
                                t: l,
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: !0,
                                n: o,
                                pg: !0,
                                pr: l._priority
                            }, a = l._overwriteProps.length; --a > -1;) i[l._overwriteProps[a]] = this._firstPT;
                        (l._priority || l._onInitAllProps) && (s = !0), (l._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled = !0)
                    } else this._firstPT = i[o] = h = {
                        _next: this._firstPT,
                        t: t,
                        p: o,
                        f: "function" == typeof t[o],
                        n: o,
                        pg: !1,
                        pr: 0
                    }, h.s = h.f ? t[o.indexOf("set") || "function" != typeof t["get" + o.substr(3)] ? o : "get" + o.substr(3)]() : parseFloat(t[o]), h.c = "string" == typeof u && "=" === u.charAt(1) ? parseInt(u.charAt(0) + "1", 10) * Number(u.substr(2)) : Number(u) - h.s || 0;
                    h && h._next && (h._next._prev = h)
                }
                return n && this._kill(n, t) ? this._initProps(t, i, r, n) : this._overwrite > 1 && this._firstPT && r.length > 1 && Y(t, this, i, this._overwrite, r) ? (this._kill(i, t), this._initProps(t, i, r, n)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (F[t._gsTweenID] = !0), s)
            }, o.render = function(e, t, i) {
                var r, n, o, a, s = this._time,
                    l = this._duration,
                    h = this._rawPrevTime;
                if (e >= l) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (r = !0, n = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (e = 0), (0 === e || 0 > h || h === u && "isPause" !== this.data) && h !== e && (i = !0, h > u && (n = "onReverseComplete")), this._rawPrevTime = a = !t || e || h === e ? e : u);
                else if (1e-7 > e) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== s || 0 === l && h > 0) && (n = "onReverseComplete", r = this._reversed), 0 > e && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || i) && (h >= 0 && (h !== u || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !t || e || h === e ? e : u)), this._initted || (i = !0);
                else if (this._totalTime = this._time = e, this._easeType) {
                    var c = e / l,
                        p = this._easeType,
                        d = this._easePower;
                    (1 === p || 3 === p && c >= .5) && (c = 1 - c), 3 === p && (c *= 2), 1 === d ? c *= c : 2 === d ? c *= c * c : 3 === d ? c *= c * c * c : 4 === d && (c *= c * c * c * c), this.ratio = 1 === p ? 1 - c : 2 === p ? c : .5 > e / l ? c / 2 : 1 - c / 2
                } else this.ratio = this._ease.getRatio(e / l);
                if (this._time !== s || i) {
                    if (!this._initted) {
                        if (this._init(), !this._initted || this._gc) return;
                        if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = h, O.push(this), void(this._lazy = [e, t]);
                        this._time && !r ? this.ratio = this._ease.getRatio(this._time / l) : r && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                    }
                    for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== s && e >= 0 && (this._active = !0), 0 === s && (this._startAt && (e >= 0 ? this._startAt.render(e, t, i) : n || (n = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === l) && (t || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                    this._onUpdate && (0 > e && this._startAt && e !== -1e-4 && this._startAt.render(e, t, i), t || (this._time !== s || r) && this._callback("onUpdate")), n && (!this._gc || i) && (0 > e && this._startAt && !this._onUpdate && e !== -1e-4 && this._startAt.render(e, t, i), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[n] && this._callback(n), 0 === l && this._rawPrevTime === u && a !== u && (this._rawPrevTime = 0))
                }
            }, o._kill = function(e, t, i) {
                if ("all" === e && (e = null), null == e && (null == t || t === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                t = "string" != typeof t ? t || this._targets || this.target : P.selector(t) || t;
                var r, n, o, a, s, l, h, u, c, p = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline;
                if ((d(t) || L(t)) && "number" != typeof t[0])
                    for (r = t.length; --r > -1;) this._kill(e, t[r], i) && (l = !0);
                else {
                    if (this._targets) {
                        for (r = this._targets.length; --r > -1;)
                            if (t === this._targets[r]) {
                                s = this._propLookup[r] || {}, this._overwrittenProps = this._overwrittenProps || [], n = this._overwrittenProps[r] = e ? this._overwrittenProps[r] || {} : "all";
                                break
                            }
                    } else {
                        if (t !== this.target) return !1;
                        s = this._propLookup, n = this._overwrittenProps = e ? this._overwrittenProps || {} : "all"
                    }
                    if (s) {
                        if (h = e || s, u = e !== n && "all" !== n && e !== s && ("object" != typeof e || !e._tempKill), i && (P.onOverwrite || this.vars.onOverwrite)) {
                            for (o in h) s[o] && (c || (c = []), c.push(o));
                            if ((c || !e) && !q(this, i, t, c)) return !1
                        }
                        for (o in h)(a = s[o]) && (p && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, l = !0), a.pg && a.t._kill(h) && (l = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete s[o]), u && (n[o] = 1);
                        !this._firstPT && this._initted && this._enabled(!1, !1)
                    }
                }
                return l
            }, o.invalidate = function() {
                return this._notifyPluginsOfEnabled && P._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], S.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -u, this.render(-this._delay)), this
            }, o._enabled = function(e, t) {
                if (s || a.wake(), e && this._gc) {
                    var i, r = this._targets;
                    if (r)
                        for (i = r.length; --i > -1;) this._siblings[i] = X(r[i], this, !0);
                    else this._siblings = X(this.target, this, !0)
                }
                return S.prototype._enabled.call(this, e, t), this._notifyPluginsOfEnabled && this._firstPT ? P._onPluginEvent(e ? "_onEnable" : "_onDisable", this) : !1
            }, P.to = function(e, t, i) {
                return new P(e, t, i)
            }, P.from = function(e, t, i) {
                return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new P(e, t, i)
            }, P.fromTo = function(e, t, i, r) {
                return r.startAt = i, r.immediateRender = 0 != r.immediateRender && 0 != i.immediateRender, new P(e, t, r)
            }, P.delayedCall = function(e, t, i, r, n) {
                return new P(t, 0, {
                    delay: e,
                    onComplete: t,
                    onCompleteParams: i,
                    callbackScope: r,
                    onReverseComplete: t,
                    onReverseCompleteParams: i,
                    immediateRender: !1,
                    lazy: !1,
                    useFrames: n,
                    overwrite: 0
                })
            }, P.set = function(e, t) {
                return new P(e, 0, t)
            }, P.getTweensOf = function(e, t) {
                if (null == e) return [];
                e = "string" != typeof e ? e : P.selector(e) || e;
                var i, r, n, o;
                if ((d(e) || L(e)) && "number" != typeof e[0]) {
                    for (i = e.length, r = []; --i > -1;) r = r.concat(P.getTweensOf(e[i], t));
                    for (i = r.length; --i > -1;)
                        for (o = r[i], n = i; --n > -1;) o === r[n] && r.splice(i, 1)
                } else
                    for (r = X(e).concat(), i = r.length; --i > -1;)(r[i]._gc || t && !r[i].isActive()) && r.splice(i, 1);
                return r
            }, P.killTweensOf = P.killDelayedCallsTo = function(e, t, i) {
                "object" == typeof t && (i = t, t = !1);
                for (var r = P.getTweensOf(e, t), n = r.length; --n > -1;) r[n]._kill(i, e)
            };
            var $ = v("plugins.TweenPlugin", function(e, t) {
                this._overwriteProps = (e || "").split(","), this._propName = this._overwriteProps[0], this._priority = t || 0, this._super = $.prototype
            }, !0);
            if (o = $.prototype, $.version = "1.10.1", $.API = 2, o._firstPT = null, o._addTween = function(e, t, i, r, n, o) {
                    var a, s;
                    return null != r && (a = "number" == typeof r || "=" !== r.charAt(1) ? Number(r) - Number(i) : parseInt(r.charAt(0) + "1", 10) * Number(r.substr(2))) ? (this._firstPT = s = {
                        _next: this._firstPT,
                        t: e,
                        p: t,
                        s: i,
                        c: a,
                        f: "function" == typeof e[t],
                        n: n || t,
                        r: o
                    }, s._next && (s._next._prev = s), s) : void 0
                }, o.setRatio = function(e) {
                    for (var t, i = this._firstPT, r = 1e-6; i;) t = i.c * e + i.s, i.r ? t = Math.round(t) : r > t && t > -r && (t = 0), i.f ? i.t[i.p](t) : i.t[i.p] = t, i = i._next
                }, o._kill = function(e) {
                    var t, i = this._overwriteProps,
                        r = this._firstPT;
                    if (null != e[this._propName]) this._overwriteProps = [];
                    else
                        for (t = i.length; --t > -1;) null != e[i[t]] && i.splice(t, 1);
                    for (; r;) null != e[r.n] && (r._next && (r._next._prev = r._prev), r._prev ? (r._prev._next = r._next, r._prev = null) : this._firstPT === r && (this._firstPT = r._next)), r = r._next;
                    return !1
                }, o._roundProps = function(e, t) {
                    for (var i = this._firstPT; i;)(e[this._propName] || null != i.n && e[i.n.split(this._propName + "_").join("")]) && (i.r = t), i = i._next
                }, P._onPluginEvent = function(e, t) {
                    var i, r, n, o, a, s = t._firstPT;
                    if ("_onInitAllProps" === e) {
                        for (; s;) {
                            for (a = s._next, r = n; r && r.pr > s.pr;) r = r._next;
                            (s._prev = r ? r._prev : o) ? s._prev._next = s: n = s, (s._next = r) ? r._prev = s : o = s, s = a
                        }
                        s = t._firstPT = n
                    }
                    for (; s;) s.pg && "function" == typeof s.t[e] && s.t[e]() && (i = !0), s = s._next;
                    return i
                }, $.activate = function(e) {
                    for (var t = e.length; --t > -1;) e[t].API === $.API && (U[(new e[t])._propName] = e[t]);
                    return !0
                }, E.plugin = function(e) {
                    if (!(e && e.propName && e.init && e.API)) throw "illegal plugin definition.";
                    var t, i = e.propName,
                        r = e.priority || 0,
                        n = e.overwriteProps,
                        o = {
                            init: "_onInitTween",
                            set: "setRatio",
                            kill: "_kill",
                            round: "_roundProps",
                            initAll: "_onInitAllProps"
                        },
                        a = v("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                            $.call(this, i, r), this._overwriteProps = n || []
                        }, e.global === !0),
                        s = a.prototype = new $(i);
                    s.constructor = a, a.API = e.API;
                    for (t in o) "function" == typeof e[t] && (s[o[t]] = e[t]);
                    return a.version = e.version, $.activate([a]), a
                }, r = e._gsQueue) {
                for (n = 0; r.length > n; n++) r[n]();
                for (o in f) f[o].func || e.console.log("GSAP encountered missing dependency: com.greensock." + o)
            }
            s = !1
        }
    }("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window, "TweenMax"), ! function(e, t) {
        "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function(e) {
            if (!e.document) throw new Error("jQuery requires a window with a document");
            return t(e)
        } : t(e)
    }("undefined" != typeof window ? window : this, function(e, t) {
        function i(e) {
            var t = e.length,
                i = ot.type(e);
            return "function" === i || ot.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === i || 0 === t || "number" == typeof t && t > 0 && t - 1 in e
        }

        function r(e, t, i) {
            if (ot.isFunction(t)) return ot.grep(e, function(e, r) {
                return !!t.call(e, r, e) !== i
            });
            if (t.nodeType) return ot.grep(e, function(e) {
                return e === t !== i
            });
            if ("string" == typeof t) {
                if (dt.test(t)) return ot.filter(t, e, i);
                t = ot.filter(t, e)
            }
            return ot.grep(e, function(e) {
                return ot.inArray(e, t) >= 0 !== i
            })
        }

        function n(e, t) {
            do e = e[t]; while (e && 1 !== e.nodeType);
            return e
        }

        function o(e) {
            var t = xt[e] = {};
            return ot.each(e.match(Tt) || [], function(e, i) {
                t[i] = !0
            }), t
        }

        function a() {
            mt.addEventListener ? (mt.removeEventListener("DOMContentLoaded", s, !1), e.removeEventListener("load", s, !1)) : (mt.detachEvent("onreadystatechange", s), e.detachEvent("onload", s))
        }

        function s() {
            (mt.addEventListener || "load" === event.type || "complete" === mt.readyState) && (a(), ot.ready())
        }

        function l(e, t, i) {
            if (void 0 === i && 1 === e.nodeType) {
                var r = "data-" + t.replace(wt, "-$1").toLowerCase();
                if (i = e.getAttribute(r), "string" == typeof i) {
                    try {
                        i = "true" === i ? !0 : "false" === i ? !1 : "null" === i ? null : +i + "" === i ? +i : Ht.test(i) ? ot.parseJSON(i) : i
                    } catch (n) {}
                    ot.data(e, t, i)
                } else i = void 0
            }
            return i
        }

        function h(e) {
            var t;
            for (t in e)
                if (("data" !== t || !ot.isEmptyObject(e[t])) && "toJSON" !== t) return !1;
            return !0
        }

        function u(e, t, i, r) {
            if (ot.acceptData(e)) {
                var n, o, a = ot.expando,
                    s = e.nodeType,
                    l = s ? ot.cache : e,
                    h = s ? e[a] : e[a] && a;
                if (h && l[h] && (r || l[h].data) || void 0 !== i || "string" != typeof t) return h || (h = s ? e[a] = Y.pop() || ot.guid++ : a), l[h] || (l[h] = s ? {} : {
                    toJSON: ot.noop
                }), ("object" == typeof t || "function" == typeof t) && (r ? l[h] = ot.extend(l[h], t) : l[h].data = ot.extend(l[h].data, t)), o = l[h], r || (o.data || (o.data = {}), o = o.data), void 0 !== i && (o[ot.camelCase(t)] = i), "string" == typeof t ? (n = o[t], null == n && (n = o[ot.camelCase(t)])) : n = o, n
            }
        }

        function c(e, t, i) {
            if (ot.acceptData(e)) {
                var r, n, o = e.nodeType,
                    a = o ? ot.cache : e,
                    s = o ? e[ot.expando] : ot.expando;
                if (a[s]) {
                    if (t && (r = i ? a[s] : a[s].data)) {
                        ot.isArray(t) ? t = t.concat(ot.map(t, ot.camelCase)) : t in r ? t = [t] : (t = ot.camelCase(t), t = t in r ? [t] : t.split(" ")), n = t.length;
                        for (; n--;) delete r[t[n]];
                        if (i ? !h(r) : !ot.isEmptyObject(r)) return
                    }(i || (delete a[s].data, h(a[s]))) && (o ? ot.cleanData([e], !0) : rt.deleteExpando || a != a.window ? delete a[s] : a[s] = null)
                }
            }
        }

        function p() {
            return !0
        }

        function d() {
            return !1
        }

        function f() {
            try {
                return mt.activeElement
            } catch (e) {}
        }

        function m(e) {
            var t = kt.split("|"),
                i = e.createDocumentFragment();
            if (i.createElement)
                for (; t.length;) i.createElement(t.pop());
            return i
        }

        function E(e, t) {
            var i, r, n = 0,
                o = typeof e.getElementsByTagName !== Rt ? e.getElementsByTagName(t || "*") : typeof e.querySelectorAll !== Rt ? e.querySelectorAll(t || "*") : void 0;
            if (!o)
                for (o = [], i = e.childNodes || e; null != (r = i[n]); n++) !t || ot.nodeName(r, t) ? o.push(r) : ot.merge(o, E(r, t));
            return void 0 === t || t && ot.nodeName(e, t) ? ot.merge([e], o) : o
        }

        function v(e) {
            Pt.test(e.type) && (e.defaultChecked = e.checked)
        }

        function g(e, t) {
            return ot.nodeName(e, "table") && ot.nodeName(11 !== t.nodeType ? t : t.firstChild, "tr") ? e.getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e
        }

        function y(e) {
            return e.type = (null !== ot.find.attr(e, "type")) + "/" + e.type, e
        }

        function T(e) {
            var t = qt.exec(e.type);
            return t ? e.type = t[1] : e.removeAttribute("type"), e
        }

        function x(e, t) {
            for (var i, r = 0; null != (i = e[r]); r++) ot._data(i, "globalEval", !t || ot._data(t[r], "globalEval"))
        }

        function _(e, t) {
            if (1 === t.nodeType && ot.hasData(e)) {
                var i, r, n, o = ot._data(e),
                    a = ot._data(t, o),
                    s = o.events;
                if (s) {
                    delete a.handle, a.events = {};
                    for (i in s)
                        for (r = 0, n = s[i].length; n > r; r++) ot.event.add(t, i, s[i][r])
                }
                a.data && (a.data = ot.extend({}, a.data))
            }
        }

        function R(e, t) {
            var i, r, n;
            if (1 === t.nodeType) {
                if (i = t.nodeName.toLowerCase(), !rt.noCloneEvent && t[ot.expando]) {
                    n = ot._data(t);
                    for (r in n.events) ot.removeEvent(t, r, n.handle);
                    t.removeAttribute(ot.expando)
                }
                "script" === i && t.text !== e.text ? (y(t).text = e.text, T(t)) : "object" === i ? (t.parentNode && (t.outerHTML = e.outerHTML), rt.html5Clone && e.innerHTML && !ot.trim(t.innerHTML) && (t.innerHTML = e.innerHTML)) : "input" === i && Pt.test(e.type) ? (t.defaultChecked = t.checked = e.checked, t.value !== e.value && (t.value = e.value)) : "option" === i ? t.defaultSelected = t.selected = e.defaultSelected : ("input" === i || "textarea" === i) && (t.defaultValue = e.defaultValue)
            }
        }

        function b(t, i) {
            var r, n = ot(i.createElement(t)).appendTo(i.body),
                o = e.getDefaultComputedStyle && (r = e.getDefaultComputedStyle(n[0])) ? r.display : ot.css(n[0], "display");
            return n.detach(), o
        }

        function H(e) {
            var t = mt,
                i = Jt[e];
            return i || (i = b(e, t), "none" !== i && i || (Zt = (Zt || ot("<iframe frameborder='0' width='0' height='0'/>")).appendTo(t.documentElement), t = (Zt[0].contentWindow || Zt[0].contentDocument).document, t.write(), t.close(), i = b(e, t), Zt.detach()), Jt[e] = i), i
        }

        function w(e, t) {
            return {
                get: function() {
                    var i = e();
                    return null != i ? i ? void delete this.get : (this.get = t).apply(this, arguments) : void 0
                }
            }
        }

        function M(e, t) {
            if (t in e) return t;
            for (var i = t.charAt(0).toUpperCase() + t.slice(1), r = t, n = pi.length; n--;)
                if (t = pi[n] + i, t in e) return t;
            return r
        }

        function S(e, t) {
            for (var i, r, n, o = [], a = 0, s = e.length; s > a; a++) r = e[a], r.style && (o[a] = ot._data(r, "olddisplay"), i = r.style.display, t ? (o[a] || "none" !== i || (r.style.display = ""), "" === r.style.display && Ct(r) && (o[a] = ot._data(r, "olddisplay", H(r.nodeName)))) : (n = Ct(r), (i && "none" !== i || !n) && ot._data(r, "olddisplay", n ? i : ot.css(r, "display"))));
            for (a = 0; s > a; a++) r = e[a], r.style && (t && "none" !== r.style.display && "" !== r.style.display || (r.style.display = t ? o[a] || "" : "none"));
            return e
        }

        function C(e, t, i) {
            var r = li.exec(t);
            return r ? Math.max(0, r[1] - (i || 0)) + (r[2] || "px") : t
        }

        function A(e, t, i, r, n) {
            for (var o = i === (r ? "border" : "content") ? 4 : "width" === t ? 1 : 0, a = 0; 4 > o; o += 2) "margin" === i && (a += ot.css(e, i + St[o], !0, n)), r ? ("content" === i && (a -= ot.css(e, "padding" + St[o], !0, n)), "margin" !== i && (a -= ot.css(e, "border" + St[o] + "Width", !0, n))) : (a += ot.css(e, "padding" + St[o], !0, n), "padding" !== i && (a += ot.css(e, "border" + St[o] + "Width", !0, n)));
            return a
        }

        function P(e, t, i) {
            var r = !0,
                n = "width" === t ? e.offsetWidth : e.offsetHeight,
                o = ii(e),
                a = rt.boxSizing && "border-box" === ot.css(e, "boxSizing", !1, o);
            if (0 >= n || null == n) {
                if (n = ri(e, t, o), (0 > n || null == n) && (n = e.style[t]), ti.test(n)) return n;
                r = a && (rt.boxSizingReliable() || n === e.style[t]), n = parseFloat(n) || 0
            }
            return n + A(e, t, i || (a ? "border" : "content"), r, o) + "px"
        }

        function L(e, t, i, r, n) {
            return new L.prototype.init(e, t, i, r, n)
        }

        function D() {
            return setTimeout(function() {
                di = void 0
            }), di = ot.now()
        }

        function O(e, t) {
            var i, r = {
                    height: e
                },
                n = 0;
            for (t = t ? 1 : 0; 4 > n; n += 2 - t) i = St[n], r["margin" + i] = r["padding" + i] = e;
            return t && (r.opacity = r.width = e), r
        }

        function F(e, t, i) {
            for (var r, n = (yi[t] || []).concat(yi["*"]), o = 0, a = n.length; a > o; o++)
                if (r = n[o].call(i, t, e)) return r
        }

        function k(e, t, i) {
            var r, n, o, a, s, l, h, u, c = this,
                p = {},
                d = e.style,
                f = e.nodeType && Ct(e),
                m = ot._data(e, "fxshow");
            i.queue || (s = ot._queueHooks(e, "fx"), null == s.unqueued && (s.unqueued = 0, l = s.empty.fire, s.empty.fire = function() {
                s.unqueued || l()
            }), s.unqueued++, c.always(function() {
                c.always(function() {
                    s.unqueued--, ot.queue(e, "fx").length || s.empty.fire()
                })
            })), 1 === e.nodeType && ("height" in t || "width" in t) && (i.overflow = [d.overflow, d.overflowX, d.overflowY], h = ot.css(e, "display"), u = "none" === h ? ot._data(e, "olddisplay") || H(e.nodeName) : h, "inline" === u && "none" === ot.css(e, "float") && (rt.inlineBlockNeedsLayout && "inline" !== H(e.nodeName) ? d.zoom = 1 : d.display = "inline-block")), i.overflow && (d.overflow = "hidden", rt.shrinkWrapBlocks() || c.always(function() {
                d.overflow = i.overflow[0], d.overflowX = i.overflow[1], d.overflowY = i.overflow[2]
            }));
            for (r in t)
                if (n = t[r], mi.exec(n)) {
                    if (delete t[r], o = o || "toggle" === n, n === (f ? "hide" : "show")) {
                        if ("show" !== n || !m || void 0 === m[r]) continue;
                        f = !0
                    }
                    p[r] = m && m[r] || ot.style(e, r)
                } else h = void 0;
            if (ot.isEmptyObject(p)) "inline" === ("none" === h ? H(e.nodeName) : h) && (d.display = h);
            else {
                m ? "hidden" in m && (f = m.hidden) : m = ot._data(e, "fxshow", {}), o && (m.hidden = !f), f ? ot(e).show() : c.done(function() {
                    ot(e).hide()
                }), c.done(function() {
                    var t;
                    ot._removeData(e, "fxshow");
                    for (t in p) ot.style(e, t, p[t])
                });
                for (r in p) a = F(f ? m[r] : 0, r, c), r in m || (m[r] = a.start, f && (a.end = a.start, a.start = "width" === r || "height" === r ? 1 : 0))
            }
        }

        function U(e, t) {
            var i, r, n, o, a;
            for (i in e)
                if (r = ot.camelCase(i), n = t[r], o = e[i], ot.isArray(o) && (n = o[1], o = e[i] = o[0]), i !== r && (e[r] = o, delete e[i]), a = ot.cssHooks[r], a && "expand" in a) {
                    o = a.expand(o), delete e[r];
                    for (i in o) i in e || (e[i] = o[i], t[i] = n)
                } else t[r] = n
        }

        function N(e, t, i) {
            var r, n, o = 0,
                a = gi.length,
                s = ot.Deferred().always(function() {
                    delete l.elem
                }),
                l = function() {
                    if (n) return !1;
                    for (var t = di || D(), i = Math.max(0, h.startTime + h.duration - t), r = i / h.duration || 0, o = 1 - r, a = 0, l = h.tweens.length; l > a; a++) h.tweens[a].run(o);
                    return s.notifyWith(e, [h, o, i]), 1 > o && l ? i : (s.resolveWith(e, [h]), !1)
                },
                h = s.promise({
                    elem: e,
                    props: ot.extend({}, t),
                    opts: ot.extend(!0, {
                        specialEasing: {}
                    }, i),
                    originalProperties: t,
                    originalOptions: i,
                    startTime: di || D(),
                    duration: i.duration,
                    tweens: [],
                    createTween: function(t, i) {
                        var r = ot.Tween(e, h.opts, t, i, h.opts.specialEasing[t] || h.opts.easing);
                        return h.tweens.push(r), r
                    },
                    stop: function(t) {
                        var i = 0,
                            r = t ? h.tweens.length : 0;
                        if (n) return this;
                        for (n = !0; r > i; i++) h.tweens[i].run(1);
                        return t ? s.resolveWith(e, [h, t]) : s.rejectWith(e, [h, t]), this
                    }
                }),
                u = h.props;
            for (U(u, h.opts.specialEasing); a > o; o++)
                if (r = gi[o].call(h, e, u, h.opts)) return r;
            return ot.map(u, F, h), ot.isFunction(h.opts.start) && h.opts.start.call(e, h), ot.fx.timer(ot.extend(l, {
                elem: e,
                anim: h,
                queue: h.opts.queue
            })), h.progress(h.opts.progress).done(h.opts.done, h.opts.complete).fail(h.opts.fail).always(h.opts.always)
        }

        function B(e) {
            return function(t, i) {
                "string" != typeof t && (i = t, t = "*");
                var r, n = 0,
                    o = t.toLowerCase().match(Tt) || [];
                if (ot.isFunction(i))
                    for (; r = o[n++];) "+" === r.charAt(0) ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(i)) : (e[r] = e[r] || []).push(i)
            }
        }

        function z(e, t, i, r) {
            function n(s) {
                var l;
                return o[s] = !0, ot.each(e[s] || [], function(e, s) {
                    var h = s(t, i, r);
                    return "string" != typeof h || a || o[h] ? a ? !(l = h) : void 0 : (t.dataTypes.unshift(h), n(h), !1)
                }), l
            }
            var o = {},
                a = e === ji;
            return n(t.dataTypes[0]) || !o["*"] && n("*")
        }

        function V(e, t) {
            var i, r, n = ot.ajaxSettings.flatOptions || {};
            for (r in t) void 0 !== t[r] && ((n[r] ? e : i || (i = {}))[r] = t[r]);
            return i && ot.extend(!0, e, i), e
        }

        function I(e, t, i) {
            for (var r, n, o, a, s = e.contents, l = e.dataTypes;
                "*" === l[0];) l.shift(), void 0 === n && (n = e.mimeType || t.getResponseHeader("Content-Type"));
            if (n)
                for (a in s)
                    if (s[a] && s[a].test(n)) {
                        l.unshift(a);
                        break
                    }
            if (l[0] in i) o = l[0];
            else {
                for (a in i) {
                    if (!l[0] || e.converters[a + " " + l[0]]) {
                        o = a;
                        break
                    }
                    r || (r = a)
                }
                o = o || r
            }
            return o ? (o !== l[0] && l.unshift(o), i[o]) : void 0
        }

        function j(e, t, i, r) {
            var n, o, a, s, l, h = {},
                u = e.dataTypes.slice();
            if (u[1])
                for (a in e.converters) h[a.toLowerCase()] = e.converters[a];
            for (o = u.shift(); o;)
                if (e.responseFields[o] && (i[e.responseFields[o]] = t), !l && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = o, o = u.shift())
                    if ("*" === o) o = l;
                    else if ("*" !== l && l !== o) {
                if (a = h[l + " " + o] || h["* " + o], !a)
                    for (n in h)
                        if (s = n.split(" "), s[1] === o && (a = h[l + " " + s[0]] || h["* " + s[0]])) {
                            a === !0 ? a = h[n] : h[n] !== !0 && (o = s[0], u.unshift(s[1]));
                            break
                        }
                if (a !== !0)
                    if (a && e["throws"]) t = a(t);
                    else try {
                        t = a(t)
                    } catch (c) {
                        return {
                            state: "parsererror",
                            error: a ? c : "No conversion from " + l + " to " + o
                        }
                    }
            }
            return {
                state: "success",
                data: t
            }
        }

        function G(e, t, i, r) {
            var n;
            if (ot.isArray(t)) ot.each(t, function(t, n) {
                i || qi.test(e) ? r(e, n) : G(e + "[" + ("object" == typeof n ? t : "") + "]", n, i, r)
            });
            else if (i || "object" !== ot.type(t)) r(e, t);
            else
                for (n in t) G(e + "[" + n + "]", t[n], i, r)
        }

        function W() {
            try {
                return new e.XMLHttpRequest
            } catch (t) {}
        }

        function X() {
            try {
                return new e.ActiveXObject("Microsoft.XMLHTTP")
            } catch (t) {}
        }

        function q(e) {
            return ot.isWindow(e) ? e : 9 === e.nodeType ? e.defaultView || e.parentWindow : !1
        }
        var Y = [],
            Q = Y.slice,
            K = Y.concat,
            Z = Y.push,
            J = Y.indexOf,
            et = {},
            tt = et.toString,
            it = et.hasOwnProperty,
            rt = {},
            nt = "1.11.1",
            ot = function(e, t) {
                return new ot.fn.init(e, t)
            },
            at = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
            st = /^-ms-/,
            lt = /-([\da-z])/gi,
            ht = function(e, t) {
                return t.toUpperCase()
            };
        ot.fn = ot.prototype = {
            jquery: nt,
            constructor: ot,
            selector: "",
            length: 0,
            toArray: function() {
                return Q.call(this)
            },
            get: function(e) {
                return null != e ? 0 > e ? this[e + this.length] : this[e] : Q.call(this)
            },
            pushStack: function(e) {
                var t = ot.merge(this.constructor(), e);
                return t.prevObject = this, t.context = this.context, t
            },
            each: function(e, t) {
                return ot.each(this, e, t)
            },
            map: function(e) {
                return this.pushStack(ot.map(this, function(t, i) {
                    return e.call(t, i, t)
                }))
            },
            slice: function() {
                return this.pushStack(Q.apply(this, arguments))
            },
            first: function() {
                return this.eq(0)
            },
            last: function() {
                return this.eq(-1)
            },
            eq: function(e) {
                var t = this.length,
                    i = +e + (0 > e ? t : 0);
                return this.pushStack(i >= 0 && t > i ? [this[i]] : [])
            },
            end: function() {
                return this.prevObject || this.constructor(null)
            },
            push: Z,
            sort: Y.sort,
            splice: Y.splice
        }, ot.extend = ot.fn.extend = function() {
            var e, t, i, r, n, o, a = arguments[0] || {},
                s = 1,
                l = arguments.length,
                h = !1;
            for ("boolean" == typeof a && (h = a, a = arguments[s] || {}, s++), "object" == typeof a || ot.isFunction(a) || (a = {}), s === l && (a = this, s--); l > s; s++)
                if (null != (n = arguments[s]))
                    for (r in n) e = a[r], i = n[r], a !== i && (h && i && (ot.isPlainObject(i) || (t = ot.isArray(i))) ? (t ? (t = !1, o = e && ot.isArray(e) ? e : []) : o = e && ot.isPlainObject(e) ? e : {}, a[r] = ot.extend(h, o, i)) : void 0 !== i && (a[r] = i));
            return a
        }, ot.extend({
            expando: "jQuery" + (nt + Math.random()).replace(/\D/g, ""),
            isReady: !0,
            error: function(e) {
                throw new Error(e)
            },
            noop: function() {},
            isFunction: function(e) {
                return "function" === ot.type(e)
            },
            isArray: Array.isArray || function(e) {
                return "array" === ot.type(e)
            },
            isWindow: function(e) {
                return null != e && e == e.window
            },
            isNumeric: function(e) {
                return !ot.isArray(e) && e - parseFloat(e) >= 0
            },
            isEmptyObject: function(e) {
                var t;
                for (t in e) return !1;
                return !0
            },
            isPlainObject: function(e) {
                var t;
                if (!e || "object" !== ot.type(e) || e.nodeType || ot.isWindow(e)) return !1;
                try {
                    if (e.constructor && !it.call(e, "constructor") && !it.call(e.constructor.prototype, "isPrototypeOf")) return !1
                } catch (i) {
                    return !1
                }
                if (rt.ownLast)
                    for (t in e) return it.call(e, t);
                for (t in e);
                return void 0 === t || it.call(e, t)
            },
            type: function(e) {
                return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? et[tt.call(e)] || "object" : typeof e
            },
            globalEval: function(t) {
                t && ot.trim(t) && (e.execScript || function(t) {
                    e.eval.call(e, t)
                })(t)
            },
            camelCase: function(e) {
                return e.replace(st, "ms-").replace(lt, ht)
            },
            nodeName: function(e, t) {
                return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
            },
            each: function(e, t, r) {
                var n, o = 0,
                    a = e.length,
                    s = i(e);
                if (r) {
                    if (s)
                        for (; a > o && (n = t.apply(e[o], r), n !== !1); o++);
                    else
                        for (o in e)
                            if (n = t.apply(e[o], r), n === !1) break
                } else if (s)
                    for (; a > o && (n = t.call(e[o], o, e[o]), n !== !1); o++);
                else
                    for (o in e)
                        if (n = t.call(e[o], o, e[o]), n === !1) break;
                return e
            },
            trim: function(e) {
                return null == e ? "" : (e + "").replace(at, "")
            },
            makeArray: function(e, t) {
                var r = t || [];
                return null != e && (i(Object(e)) ? ot.merge(r, "string" == typeof e ? [e] : e) : Z.call(r, e)), r
            },
            inArray: function(e, t, i) {
                var r;
                if (t) {
                    if (J) return J.call(t, e, i);
                    for (r = t.length, i = i ? 0 > i ? Math.max(0, r + i) : i : 0; r > i; i++)
                        if (i in t && t[i] === e) return i
                }
                return -1
            },
            merge: function(e, t) {
                for (var i = +t.length, r = 0, n = e.length; i > r;) e[n++] = t[r++];
                if (i !== i)
                    for (; void 0 !== t[r];) e[n++] = t[r++];
                return e.length = n, e
            },
            grep: function(e, t, i) {
                for (var r, n = [], o = 0, a = e.length, s = !i; a > o; o++) r = !t(e[o], o), r !== s && n.push(e[o]);
                return n
            },
            map: function(e, t, r) {
                var n, o = 0,
                    a = e.length,
                    s = i(e),
                    l = [];
                if (s)
                    for (; a > o; o++) n = t(e[o], o, r), null != n && l.push(n);
                else
                    for (o in e) n = t(e[o], o, r), null != n && l.push(n);
                return K.apply([], l)
            },
            guid: 1,
            proxy: function(e, t) {
                var i, r, n;
                return "string" == typeof t && (n = e[t], t = e, e = n), ot.isFunction(e) ? (i = Q.call(arguments, 2), r = function() {
                    return e.apply(t || this, i.concat(Q.call(arguments)))
                }, r.guid = e.guid = e.guid || ot.guid++, r) : void 0
            },
            now: function() {
                return +new Date
            },
            support: rt
        }), ot.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(e, t) {
            et["[object " + t + "]"] = t.toLowerCase()
        });
        var ut = function(e) {
            function t(e, t, i, r) {
                var n, o, a, s, l, h, c, d, f, m;
                if ((t ? t.ownerDocument || t : z) !== L && P(t), t = t || L, i = i || [], !e || "string" != typeof e) return i;
                if (1 !== (s = t.nodeType) && 9 !== s) return [];
                if (O && !r) {
                    if (n = gt.exec(e))
                        if (a = n[1]) {
                            if (9 === s) {
                                if (o = t.getElementById(a), !o || !o.parentNode) return i;
                                if (o.id === a) return i.push(o), i
                            } else if (t.ownerDocument && (o = t.ownerDocument.getElementById(a)) && N(t, o) && o.id === a) return i.push(o), i
                        } else {
                            if (n[2]) return et.apply(i, t.getElementsByTagName(e)), i;
                            if ((a = n[3]) && x.getElementsByClassName && t.getElementsByClassName) return et.apply(i, t.getElementsByClassName(a)), i
                        }
                    if (x.qsa && (!F || !F.test(e))) {
                        if (d = c = B, f = t, m = 9 === s && e, 1 === s && "object" !== t.nodeName.toLowerCase()) {
                            for (h = H(e), (c = t.getAttribute("id")) ? d = c.replace(Tt, "\\$&") : t.setAttribute("id", d), d = "[id='" + d + "'] ", l = h.length; l--;) h[l] = d + p(h[l]);
                            f = yt.test(e) && u(t.parentNode) || t, m = h.join(",")
                        }
                        if (m) try {
                            return et.apply(i, f.querySelectorAll(m)), i
                        } catch (E) {} finally {
                            c || t.removeAttribute("id")
                        }
                    }
                }
                return M(e.replace(ht, "$1"), t, i, r)
            }

            function i() {
                function e(i, r) {
                    return t.push(i + " ") > _.cacheLength && delete e[t.shift()], e[i + " "] = r
                }
                var t = [];
                return e
            }

            function r(e) {
                return e[B] = !0, e
            }

            function n(e) {
                var t = L.createElement("div");
                try {
                    return !!e(t)
                } catch (i) {
                    return !1
                } finally {
                    t.parentNode && t.parentNode.removeChild(t), t = null
                }
            }

            function o(e, t) {
                for (var i = e.split("|"), r = e.length; r--;) _.attrHandle[i[r]] = t
            }

            function a(e, t) {
                var i = t && e,
                    r = i && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || Y) - (~e.sourceIndex || Y);
                if (r) return r;
                if (i)
                    for (; i = i.nextSibling;)
                        if (i === t) return -1;
                return e ? 1 : -1
            }

            function s(e) {
                return function(t) {
                    var i = t.nodeName.toLowerCase();
                    return "input" === i && t.type === e
                }
            }

            function l(e) {
                return function(t) {
                    var i = t.nodeName.toLowerCase();
                    return ("input" === i || "button" === i) && t.type === e
                }
            }

            function h(e) {
                return r(function(t) {
                    return t = +t, r(function(i, r) {
                        for (var n, o = e([], i.length, t), a = o.length; a--;) i[n = o[a]] && (i[n] = !(r[n] = i[n]))
                    })
                })
            }

            function u(e) {
                return e && typeof e.getElementsByTagName !== q && e
            }

            function c() {}

            function p(e) {
                for (var t = 0, i = e.length, r = ""; i > t; t++) r += e[t].value;
                return r
            }

            function d(e, t, i) {
                var r = t.dir,
                    n = i && "parentNode" === r,
                    o = I++;
                return t.first ? function(t, i, o) {
                    for (; t = t[r];)
                        if (1 === t.nodeType || n) return e(t, i, o)
                } : function(t, i, a) {
                    var s, l, h = [V, o];
                    if (a) {
                        for (; t = t[r];)
                            if ((1 === t.nodeType || n) && e(t, i, a)) return !0
                    } else
                        for (; t = t[r];)
                            if (1 === t.nodeType || n) {
                                if (l = t[B] || (t[B] = {}), (s = l[r]) && s[0] === V && s[1] === o) return h[2] = s[2];
                                if (l[r] = h, h[2] = e(t, i, a)) return !0
                            }
                }
            }

            function f(e) {
                return e.length > 1 ? function(t, i, r) {
                    for (var n = e.length; n--;)
                        if (!e[n](t, i, r)) return !1;
                    return !0
                } : e[0]
            }

            function m(e, i, r) {
                for (var n = 0, o = i.length; o > n; n++) t(e, i[n], r);
                return r
            }

            function E(e, t, i, r, n) {
                for (var o, a = [], s = 0, l = e.length, h = null != t; l > s; s++)(o = e[s]) && (!i || i(o, r, n)) && (a.push(o), h && t.push(s));
                return a
            }

            function v(e, t, i, n, o, a) {
                return n && !n[B] && (n = v(n)), o && !o[B] && (o = v(o, a)), r(function(r, a, s, l) {
                    var h, u, c, p = [],
                        d = [],
                        f = a.length,
                        v = r || m(t || "*", s.nodeType ? [s] : s, []),
                        g = !e || !r && t ? v : E(v, p, e, s, l),
                        y = i ? o || (r ? e : f || n) ? [] : a : g;
                    if (i && i(g, y, s, l), n)
                        for (h = E(y, d), n(h, [], s, l), u = h.length; u--;)(c = h[u]) && (y[d[u]] = !(g[d[u]] = c));
                    if (r) {
                        if (o || e) {
                            if (o) {
                                for (h = [], u = y.length; u--;)(c = y[u]) && h.push(g[u] = c);
                                o(null, y = [], h, l)
                            }
                            for (u = y.length; u--;)(c = y[u]) && (h = o ? it.call(r, c) : p[u]) > -1 && (r[h] = !(a[h] = c))
                        }
                    } else y = E(y === a ? y.splice(f, y.length) : y), o ? o(null, a, y, l) : et.apply(a, y)
                })
            }

            function g(e) {
                for (var t, i, r, n = e.length, o = _.relative[e[0].type], a = o || _.relative[" "], s = o ? 1 : 0, l = d(function(e) {
                        return e === t
                    }, a, !0), h = d(function(e) {
                        return it.call(t, e) > -1
                    }, a, !0), u = [function(e, i, r) {
                        return !o && (r || i !== S) || ((t = i).nodeType ? l(e, i, r) : h(e, i, r))
                    }]; n > s; s++)
                    if (i = _.relative[e[s].type]) u = [d(f(u), i)];
                    else {
                        if (i = _.filter[e[s].type].apply(null, e[s].matches), i[B]) {
                            for (r = ++s; n > r && !_.relative[e[r].type]; r++);
                            return v(s > 1 && f(u), s > 1 && p(e.slice(0, s - 1).concat({
                                value: " " === e[s - 2].type ? "*" : ""
                            })).replace(ht, "$1"), i, r > s && g(e.slice(s, r)), n > r && g(e = e.slice(r)), n > r && p(e))
                        }
                        u.push(i)
                    }
                return f(u)
            }

            function y(e, i) {
                var n = i.length > 0,
                    o = e.length > 0,
                    a = function(r, a, s, l, h) {
                        var u, c, p, d = 0,
                            f = "0",
                            m = r && [],
                            v = [],
                            g = S,
                            y = r || o && _.find.TAG("*", h),
                            T = V += null == g ? 1 : Math.random() || .1,
                            x = y.length;
                        for (h && (S = a !== L && a); f !== x && null != (u = y[f]); f++) {
                            if (o && u) {
                                for (c = 0; p = e[c++];)
                                    if (p(u, a, s)) {
                                        l.push(u);
                                        break
                                    }
                                h && (V = T)
                            }
                            n && ((u = !p && u) && d--, r && m.push(u))
                        }
                        if (d += f, n && f !== d) {
                            for (c = 0; p = i[c++];) p(m, v, a, s);
                            if (r) {
                                if (d > 0)
                                    for (; f--;) m[f] || v[f] || (v[f] = Z.call(l));
                                v = E(v)
                            }
                            et.apply(l, v), h && !r && v.length > 0 && d + i.length > 1 && t.uniqueSort(l)
                        }
                        return h && (V = T, S = g), m
                    };
                return n ? r(a) : a
            }
            var T, x, _, R, b, H, w, M, S, C, A, P, L, D, O, F, k, U, N, B = "sizzle" + -new Date,
                z = e.document,
                V = 0,
                I = 0,
                j = i(),
                G = i(),
                W = i(),
                X = function(e, t) {
                    return e === t && (A = !0), 0
                },
                q = "undefined",
                Y = 1 << 31,
                Q = {}.hasOwnProperty,
                K = [],
                Z = K.pop,
                J = K.push,
                et = K.push,
                tt = K.slice,
                it = K.indexOf || function(e) {
                    for (var t = 0, i = this.length; i > t; t++)
                        if (this[t] === e) return t;
                    return -1
                },
                rt = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                nt = "[\\x20\\t\\r\\n\\f]",
                ot = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
                at = ot.replace("w", "w#"),
                st = "\\[" + nt + "*(" + ot + ")(?:" + nt + "*([*^$|!~]?=)" + nt + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + at + "))|)" + nt + "*\\]",
                lt = ":(" + ot + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + st + ")*)|.*)\\)|)",
                ht = new RegExp("^" + nt + "+|((?:^|[^\\\\])(?:\\\\.)*)" + nt + "+$", "g"),
                ut = new RegExp("^" + nt + "*," + nt + "*"),
                ct = new RegExp("^" + nt + "*([>+~]|" + nt + ")" + nt + "*"),
                pt = new RegExp("=" + nt + "*([^\\]'\"]*?)" + nt + "*\\]", "g"),
                dt = new RegExp(lt),
                ft = new RegExp("^" + at + "$"),
                mt = {
                    ID: new RegExp("^#(" + ot + ")"),
                    CLASS: new RegExp("^\\.(" + ot + ")"),
                    TAG: new RegExp("^(" + ot.replace("w", "w*") + ")"),
                    ATTR: new RegExp("^" + st),
                    PSEUDO: new RegExp("^" + lt),
                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + nt + "*(even|odd|(([+-]|)(\\d*)n|)" + nt + "*(?:([+-]|)" + nt + "*(\\d+)|))" + nt + "*\\)|)", "i"),
                    bool: new RegExp("^(?:" + rt + ")$", "i"),
                    needsContext: new RegExp("^" + nt + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + nt + "*((?:-\\d)?\\d*)" + nt + "*\\)|)(?=[^-]|$)", "i")
                },
                Et = /^(?:input|select|textarea|button)$/i,
                vt = /^h\d$/i,
                $ = /^[^{]+\{\s*\[native \w/,
                gt = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                yt = /[+~]/,
                Tt = /'|\\/g,
                xt = new RegExp("\\\\([\\da-f]{1,6}" + nt + "?|(" + nt + ")|.)", "ig"),
                _t = function(e, t, i) {
                    var r = "0x" + t - 65536;
                    return r !== r || i ? t : 0 > r ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320)
                };
            try {
                et.apply(K = tt.call(z.childNodes), z.childNodes), K[z.childNodes.length].nodeType
            } catch (Rt) {
                et = {
                    apply: K.length ? function(e, t) {
                        J.apply(e, tt.call(t))
                    } : function(e, t) {
                        for (var i = e.length, r = 0; e[i++] = t[r++];);
                        e.length = i - 1
                    }
                }
            }
            x = t.support = {}, b = t.isXML = function(e) {
                var t = e && (e.ownerDocument || e).documentElement;
                return t ? "HTML" !== t.nodeName : !1
            }, P = t.setDocument = function(e) {
                var t, i = e ? e.ownerDocument || e : z,
                    r = i.defaultView;
                return i !== L && 9 === i.nodeType && i.documentElement ? (L = i, D = i.documentElement, O = !b(i), r && r !== r.top && (r.addEventListener ? r.addEventListener("unload", function() {
                    P()
                }, !1) : r.attachEvent && r.attachEvent("onunload", function() {
                    P()
                })), x.attributes = n(function(e) {
                    return e.className = "i", !e.getAttribute("className")
                }), x.getElementsByTagName = n(function(e) {
                    return e.appendChild(i.createComment("")), !e.getElementsByTagName("*").length
                }), x.getElementsByClassName = $.test(i.getElementsByClassName) && n(function(e) {
                    return e.innerHTML = "<div class='a'></div><div class='a i'></div>", e.firstChild.className = "i", 2 === e.getElementsByClassName("i").length
                }), x.getById = n(function(e) {
                    return D.appendChild(e).id = B, !i.getElementsByName || !i.getElementsByName(B).length
                }), x.getById ? (_.find.ID = function(e, t) {
                    if (typeof t.getElementById !== q && O) {
                        var i = t.getElementById(e);
                        return i && i.parentNode ? [i] : []
                    }
                }, _.filter.ID = function(e) {
                    var t = e.replace(xt, _t);
                    return function(e) {
                        return e.getAttribute("id") === t
                    }
                }) : (delete _.find.ID, _.filter.ID = function(e) {
                    var t = e.replace(xt, _t);
                    return function(e) {
                        var i = typeof e.getAttributeNode !== q && e.getAttributeNode("id");
                        return i && i.value === t
                    }
                }), _.find.TAG = x.getElementsByTagName ? function(e, t) {
                    return typeof t.getElementsByTagName !== q ? t.getElementsByTagName(e) : void 0
                } : function(e, t) {
                    var i, r = [],
                        n = 0,
                        o = t.getElementsByTagName(e);
                    if ("*" === e) {
                        for (; i = o[n++];) 1 === i.nodeType && r.push(i);
                        return r
                    }
                    return o
                }, _.find.CLASS = x.getElementsByClassName && function(e, t) {
                    return typeof t.getElementsByClassName !== q && O ? t.getElementsByClassName(e) : void 0
                }, k = [], F = [], (x.qsa = $.test(i.querySelectorAll)) && (n(function(e) {
                    e.innerHTML = "<select msallowclip=''><option selected=''></option></select>", e.querySelectorAll("[msallowclip^='']").length && F.push("[*^$]=" + nt + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || F.push("\\[" + nt + "*(?:value|" + rt + ")"), e.querySelectorAll(":checked").length || F.push(":checked")
                }), n(function(e) {
                    var t = i.createElement("input");
                    t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && F.push("name" + nt + "*[*^$|!~]?="), e.querySelectorAll(":enabled").length || F.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), F.push(",.*:")
                })), (x.matchesSelector = $.test(U = D.matches || D.webkitMatchesSelector || D.mozMatchesSelector || D.oMatchesSelector || D.msMatchesSelector)) && n(function(e) {
                    x.disconnectedMatch = U.call(e, "div"), U.call(e, "[s!='']:x"), k.push("!=", lt)
                }), F = F.length && new RegExp(F.join("|")), k = k.length && new RegExp(k.join("|")), t = $.test(D.compareDocumentPosition), N = t || $.test(D.contains) ? function(e, t) {
                    var i = 9 === e.nodeType ? e.documentElement : e,
                        r = t && t.parentNode;
                    return e === r || !(!r || 1 !== r.nodeType || !(i.contains ? i.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))
                } : function(e, t) {
                    if (t)
                        for (; t = t.parentNode;)
                            if (t === e) return !0;
                    return !1
                }, X = t ? function(e, t) {
                    if (e === t) return A = !0, 0;
                    var r = !e.compareDocumentPosition - !t.compareDocumentPosition;
                    return r ? r : (r = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1, 1 & r || !x.sortDetached && t.compareDocumentPosition(e) === r ? e === i || e.ownerDocument === z && N(z, e) ? -1 : t === i || t.ownerDocument === z && N(z, t) ? 1 : C ? it.call(C, e) - it.call(C, t) : 0 : 4 & r ? -1 : 1)
                } : function(e, t) {
                    if (e === t) return A = !0, 0;
                    var r, n = 0,
                        o = e.parentNode,
                        s = t.parentNode,
                        l = [e],
                        h = [t];
                    if (!o || !s) return e === i ? -1 : t === i ? 1 : o ? -1 : s ? 1 : C ? it.call(C, e) - it.call(C, t) : 0;
                    if (o === s) return a(e, t);
                    for (r = e; r = r.parentNode;) l.unshift(r);
                    for (r = t; r = r.parentNode;) h.unshift(r);
                    for (; l[n] === h[n];) n++;
                    return n ? a(l[n], h[n]) : l[n] === z ? -1 : h[n] === z ? 1 : 0
                }, i) : L
            }, t.matches = function(e, i) {
                return t(e, null, null, i)
            }, t.matchesSelector = function(e, i) {
                if ((e.ownerDocument || e) !== L && P(e), i = i.replace(pt, "='$1']"), !(!x.matchesSelector || !O || k && k.test(i) || F && F.test(i))) try {
                    var r = U.call(e, i);
                    if (r || x.disconnectedMatch || e.document && 11 !== e.document.nodeType) return r
                } catch (n) {}
                return t(i, L, null, [e]).length > 0
            }, t.contains = function(e, t) {
                return (e.ownerDocument || e) !== L && P(e), N(e, t)
            }, t.attr = function(e, t) {
                (e.ownerDocument || e) !== L && P(e);
                var i = _.attrHandle[t.toLowerCase()],
                    r = i && Q.call(_.attrHandle, t.toLowerCase()) ? i(e, t, !O) : void 0;
                return void 0 !== r ? r : x.attributes || !O ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
            }, t.error = function(e) {
                throw new Error("Syntax error, unrecognized expression: " + e)
            }, t.uniqueSort = function(e) {
                var t, i = [],
                    r = 0,
                    n = 0;
                if (A = !x.detectDuplicates, C = !x.sortStable && e.slice(0), e.sort(X), A) {
                    for (; t = e[n++];) t === e[n] && (r = i.push(n));
                    for (; r--;) e.splice(i[r], 1)
                }
                return C = null, e
            }, R = t.getText = function(e) {
                var t, i = "",
                    r = 0,
                    n = e.nodeType;
                if (n) {
                    if (1 === n || 9 === n || 11 === n) {
                        if ("string" == typeof e.textContent) return e.textContent;
                        for (e = e.firstChild; e; e = e.nextSibling) i += R(e)
                    } else if (3 === n || 4 === n) return e.nodeValue
                } else
                    for (; t = e[r++];) i += R(t);
                return i
            }, _ = t.selectors = {
                cacheLength: 50,
                createPseudo: r,
                match: mt,
                attrHandle: {},
                find: {},
                relative: {
                    ">": {
                        dir: "parentNode",
                        first: !0
                    },
                    " ": {
                        dir: "parentNode"
                    },
                    "+": {
                        dir: "previousSibling",
                        first: !0
                    },
                    "~": {
                        dir: "previousSibling"
                    }
                },
                preFilter: {
                    ATTR: function(e) {
                        return e[1] = e[1].replace(xt, _t), e[3] = (e[3] || e[4] || e[5] || "").replace(xt, _t), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
                    },
                    CHILD: function(e) {
                        return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || t.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && t.error(e[0]), e
                    },
                    PSEUDO: function(e) {
                        var t, i = !e[6] && e[2];
                        return mt.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : i && dt.test(i) && (t = H(i, !0)) && (t = i.indexOf(")", i.length - t) - i.length) && (e[0] = e[0].slice(0, t), e[2] = i.slice(0, t)), e.slice(0, 3))
                    }
                },
                filter: {
                    TAG: function(e) {
                        var t = e.replace(xt, _t).toLowerCase();
                        return "*" === e ? function() {
                            return !0
                        } : function(e) {
                            return e.nodeName && e.nodeName.toLowerCase() === t
                        }
                    },
                    CLASS: function(e) {
                        var t = j[e + " "];
                        return t || (t = new RegExp("(^|" + nt + ")" + e + "(" + nt + "|$)")) && j(e, function(e) {
                            return t.test("string" == typeof e.className && e.className || typeof e.getAttribute !== q && e.getAttribute("class") || "")
                        })
                    },
                    ATTR: function(e, i, r) {
                        return function(n) {
                            var o = t.attr(n, e);
                            return null == o ? "!=" === i : i ? (o += "", "=" === i ? o === r : "!=" === i ? o !== r : "^=" === i ? r && 0 === o.indexOf(r) : "*=" === i ? r && o.indexOf(r) > -1 : "$=" === i ? r && o.slice(-r.length) === r : "~=" === i ? (" " + o + " ").indexOf(r) > -1 : "|=" === i ? o === r || o.slice(0, r.length + 1) === r + "-" : !1) : !0
                        }
                    },
                    CHILD: function(e, t, i, r, n) {
                        var o = "nth" !== e.slice(0, 3),
                            a = "last" !== e.slice(-4),
                            s = "of-type" === t;
                        return 1 === r && 0 === n ? function(e) {
                            return !!e.parentNode
                        } : function(t, i, l) {
                            var h, u, c, p, d, f, m = o !== a ? "nextSibling" : "previousSibling",
                                E = t.parentNode,
                                v = s && t.nodeName.toLowerCase(),
                                g = !l && !s;
                            if (E) {
                                if (o) {
                                    for (; m;) {
                                        for (c = t; c = c[m];)
                                            if (s ? c.nodeName.toLowerCase() === v : 1 === c.nodeType) return !1;
                                        f = m = "only" === e && !f && "nextSibling"
                                    }
                                    return !0
                                }
                                if (f = [a ? E.firstChild : E.lastChild], a && g) {
                                    for (u = E[B] || (E[B] = {}), h = u[e] || [], d = h[0] === V && h[1], p = h[0] === V && h[2], c = d && E.childNodes[d]; c = ++d && c && c[m] || (p = d = 0) || f.pop();)
                                        if (1 === c.nodeType && ++p && c === t) {
                                            u[e] = [V, d, p];
                                            break
                                        }
                                } else if (g && (h = (t[B] || (t[B] = {}))[e]) && h[0] === V) p = h[1];
                                else
                                    for (;
                                        (c = ++d && c && c[m] || (p = d = 0) || f.pop()) && ((s ? c.nodeName.toLowerCase() !== v : 1 !== c.nodeType) || !++p || (g && ((c[B] || (c[B] = {}))[e] = [V, p]), c !== t)););
                                return p -= n, p === r || p % r === 0 && p / r >= 0
                            }
                        }
                    },
                    PSEUDO: function(e, i) {
                        var n, o = _.pseudos[e] || _.setFilters[e.toLowerCase()] || t.error("unsupported pseudo: " + e);
                        return o[B] ? o(i) : o.length > 1 ? (n = [e, e, "", i], _.setFilters.hasOwnProperty(e.toLowerCase()) ? r(function(e, t) {
                            for (var r, n = o(e, i), a = n.length; a--;) r = it.call(e, n[a]), e[r] = !(t[r] = n[a])
                        }) : function(e) {
                            return o(e, 0, n)
                        }) : o
                    }
                },
                pseudos: {
                    not: r(function(e) {
                        var t = [],
                            i = [],
                            n = w(e.replace(ht, "$1"));
                        return n[B] ? r(function(e, t, i, r) {
                            for (var o, a = n(e, null, r, []), s = e.length; s--;)(o = a[s]) && (e[s] = !(t[s] = o))
                        }) : function(e, r, o) {
                            return t[0] = e, n(t, null, o, i), !i.pop()
                        }
                    }),
                    has: r(function(e) {
                        return function(i) {
                            return t(e, i).length > 0
                        }
                    }),
                    contains: r(function(e) {
                        return function(t) {
                            return (t.textContent || t.innerText || R(t)).indexOf(e) > -1
                        }
                    }),
                    lang: r(function(e) {
                        return ft.test(e || "") || t.error("unsupported lang: " + e), e = e.replace(xt, _t).toLowerCase(),
                            function(t) {
                                var i;
                                do
                                    if (i = O ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return i = i.toLowerCase(), i === e || 0 === i.indexOf(e + "-"); while ((t = t.parentNode) && 1 === t.nodeType);
                                return !1
                            }
                    }),
                    target: function(t) {
                        var i = e.location && e.location.hash;
                        return i && i.slice(1) === t.id
                    },
                    root: function(e) {
                        return e === D
                    },
                    focus: function(e) {
                        return e === L.activeElement && (!L.hasFocus || L.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
                    },
                    enabled: function(e) {
                        return e.disabled === !1
                    },
                    disabled: function(e) {
                        return e.disabled === !0
                    },
                    checked: function(e) {
                        var t = e.nodeName.toLowerCase();
                        return "input" === t && !!e.checked || "option" === t && !!e.selected
                    },
                    selected: function(e) {
                        return e.parentNode && e.parentNode.selectedIndex, e.selected === !0
                    },
                    empty: function(e) {
                        for (e = e.firstChild; e; e = e.nextSibling)
                            if (e.nodeType < 6) return !1;
                        return !0
                    },
                    parent: function(e) {
                        return !_.pseudos.empty(e)
                    },
                    header: function(e) {
                        return vt.test(e.nodeName)
                    },
                    input: function(e) {
                        return Et.test(e.nodeName)
                    },
                    button: function(e) {
                        var t = e.nodeName.toLowerCase();
                        return "input" === t && "button" === e.type || "button" === t
                    },
                    text: function(e) {
                        var t;
                        return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
                    },
                    first: h(function() {
                        return [0]
                    }),
                    last: h(function(e, t) {
                        return [t - 1]
                    }),
                    eq: h(function(e, t, i) {
                        return [0 > i ? i + t : i]
                    }),
                    even: h(function(e, t) {
                        for (var i = 0; t > i; i += 2) e.push(i);
                        return e
                    }),
                    odd: h(function(e, t) {
                        for (var i = 1; t > i; i += 2) e.push(i);
                        return e
                    }),
                    lt: h(function(e, t, i) {
                        for (var r = 0 > i ? i + t : i; --r >= 0;) e.push(r);
                        return e
                    }),
                    gt: h(function(e, t, i) {
                        for (var r = 0 > i ? i + t : i; ++r < t;) e.push(r);
                        return e
                    })
                }
            }, _.pseudos.nth = _.pseudos.eq;
            for (T in {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                }) _.pseudos[T] = s(T);
            for (T in {
                    submit: !0,
                    reset: !0
                }) _.pseudos[T] = l(T);
            return c.prototype = _.filters = _.pseudos, _.setFilters = new c, H = t.tokenize = function(e, i) {
                var r, n, o, a, s, l, h, u = G[e + " "];
                if (u) return i ? 0 : u.slice(0);
                for (s = e, l = [], h = _.preFilter; s;) {
                    (!r || (n = ut.exec(s))) && (n && (s = s.slice(n[0].length) || s), l.push(o = [])), r = !1, (n = ct.exec(s)) && (r = n.shift(), o.push({
                        value: r,
                        type: n[0].replace(ht, " ")
                    }), s = s.slice(r.length));
                    for (a in _.filter) !(n = mt[a].exec(s)) || h[a] && !(n = h[a](n)) || (r = n.shift(), o.push({
                        value: r,
                        type: a,
                        matches: n
                    }), s = s.slice(r.length));
                    if (!r) break
                }
                return i ? s.length : s ? t.error(e) : G(e, l).slice(0)
            }, w = t.compile = function(e, t) {
                var i, r = [],
                    n = [],
                    o = W[e + " "];
                if (!o) {
                    for (t || (t = H(e)), i = t.length; i--;) o = g(t[i]), o[B] ? r.push(o) : n.push(o);
                    o = W(e, y(n, r)), o.selector = e
                }
                return o
            }, M = t.select = function(e, t, i, r) {
                var n, o, a, s, l, h = "function" == typeof e && e,
                    c = !r && H(e = h.selector || e);
                if (i = i || [], 1 === c.length) {
                    if (o = c[0] = c[0].slice(0), o.length > 2 && "ID" === (a = o[0]).type && x.getById && 9 === t.nodeType && O && _.relative[o[1].type]) {
                        if (t = (_.find.ID(a.matches[0].replace(xt, _t), t) || [])[0], !t) return i;
                        h && (t = t.parentNode), e = e.slice(o.shift().value.length)
                    }
                    for (n = mt.needsContext.test(e) ? 0 : o.length; n-- && (a = o[n], !_.relative[s = a.type]);)
                        if ((l = _.find[s]) && (r = l(a.matches[0].replace(xt, _t), yt.test(o[0].type) && u(t.parentNode) || t))) {
                            if (o.splice(n, 1), e = r.length && p(o), !e) return et.apply(i, r), i;
                            break
                        }
                }
                return (h || w(e, c))(r, t, !O, i, yt.test(e) && u(t.parentNode) || t), i
            }, x.sortStable = B.split("").sort(X).join("") === B, x.detectDuplicates = !!A, P(), x.sortDetached = n(function(e) {
                return 1 & e.compareDocumentPosition(L.createElement("div"))
            }), n(function(e) {
                return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
            }) || o("type|href|height|width", function(e, t, i) {
                return i ? void 0 : e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
            }), x.attributes && n(function(e) {
                return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
            }) || o("value", function(e, t, i) {
                return i || "input" !== e.nodeName.toLowerCase() ? void 0 : e.defaultValue
            }), n(function(e) {
                return null == e.getAttribute("disabled")
            }) || o(rt, function(e, t, i) {
                var r;
                return i ? void 0 : e[t] === !0 ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
            }), t
        }(e);
        ot.find = ut, ot.expr = ut.selectors, ot.expr[":"] = ot.expr.pseudos, ot.unique = ut.uniqueSort, ot.text = ut.getText, ot.isXMLDoc = ut.isXML, ot.contains = ut.contains;
        var ct = ot.expr.match.needsContext,
            pt = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
            dt = /^.[^:#\[\.,]*$/;
        ot.filter = function(e, t, i) {
            var r = t[0];
            return i && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? ot.find.matchesSelector(r, e) ? [r] : [] : ot.find.matches(e, ot.grep(t, function(e) {
                return 1 === e.nodeType
            }))
        }, ot.fn.extend({
            find: function(e) {
                var t, i = [],
                    r = this,
                    n = r.length;
                if ("string" != typeof e) return this.pushStack(ot(e).filter(function() {
                    for (t = 0; n > t; t++)
                        if (ot.contains(r[t], this)) return !0
                }));
                for (t = 0; n > t; t++) ot.find(e, r[t], i);
                return i = this.pushStack(n > 1 ? ot.unique(i) : i), i.selector = this.selector ? this.selector + " " + e : e, i
            },
            filter: function(e) {
                return this.pushStack(r(this, e || [], !1))
            },
            not: function(e) {
                return this.pushStack(r(this, e || [], !0))
            },
            is: function(e) {
                return !!r(this, "string" == typeof e && ct.test(e) ? ot(e) : e || [], !1).length
            }
        });
        var ft, mt = e.document,
            Et = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
            vt = ot.fn.init = function(e, t) {
                var i, r;
                if (!e) return this;
                if ("string" == typeof e) {
                    if (i = "<" === e.charAt(0) && ">" === e.charAt(e.length - 1) && e.length >= 3 ? [null, e, null] : Et.exec(e), !i || !i[1] && t) return !t || t.jquery ? (t || ft).find(e) : this.constructor(t).find(e);
                    if (i[1]) {
                        if (t = t instanceof ot ? t[0] : t, ot.merge(this, ot.parseHTML(i[1], t && t.nodeType ? t.ownerDocument || t : mt, !0)), pt.test(i[1]) && ot.isPlainObject(t))
                            for (i in t) ot.isFunction(this[i]) ? this[i](t[i]) : this.attr(i, t[i]);
                        return this
                    }
                    if (r = mt.getElementById(i[2]), r && r.parentNode) {
                        if (r.id !== i[2]) return ft.find(e);
                        this.length = 1, this[0] = r
                    }
                    return this.context = mt, this.selector = e, this
                }
                return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : ot.isFunction(e) ? "undefined" != typeof ft.ready ? ft.ready(e) : e(ot) : (void 0 !== e.selector && (this.selector = e.selector, this.context = e.context), ot.makeArray(e, this))
            };
        vt.prototype = ot.fn, ft = ot(mt);
        var gt = /^(?:parents|prev(?:Until|All))/,
            yt = {
                children: !0,
                contents: !0,
                next: !0,
                prev: !0
            };
        ot.extend({
            dir: function(e, t, i) {
                for (var r = [], n = e[t]; n && 9 !== n.nodeType && (void 0 === i || 1 !== n.nodeType || !ot(n).is(i));) 1 === n.nodeType && r.push(n), n = n[t];
                return r
            },
            sibling: function(e, t) {
                for (var i = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && i.push(e);
                return i
            }
        }), ot.fn.extend({
            has: function(e) {
                var t, i = ot(e, this),
                    r = i.length;
                return this.filter(function() {
                    for (t = 0; r > t; t++)
                        if (ot.contains(this, i[t])) return !0
                })
            },
            closest: function(e, t) {
                for (var i, r = 0, n = this.length, o = [], a = ct.test(e) || "string" != typeof e ? ot(e, t || this.context) : 0; n > r; r++)
                    for (i = this[r]; i && i !== t; i = i.parentNode)
                        if (i.nodeType < 11 && (a ? a.index(i) > -1 : 1 === i.nodeType && ot.find.matchesSelector(i, e))) {
                            o.push(i);
                            break
                        }
                return this.pushStack(o.length > 1 ? ot.unique(o) : o)
            },
            index: function(e) {
                return e ? "string" == typeof e ? ot.inArray(this[0], ot(e)) : ot.inArray(e.jquery ? e[0] : e, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            },
            add: function(e, t) {
                return this.pushStack(ot.unique(ot.merge(this.get(), ot(e, t))))
            },
            addBack: function(e) {
                return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
            }
        }), ot.each({
            parent: function(e) {
                var t = e.parentNode;
                return t && 11 !== t.nodeType ? t : null
            },
            parents: function(e) {
                return ot.dir(e, "parentNode")
            },
            parentsUntil: function(e, t, i) {
                return ot.dir(e, "parentNode", i)
            },
            next: function(e) {
                return n(e, "nextSibling")
            },
            prev: function(e) {
                return n(e, "previousSibling")
            },
            nextAll: function(e) {
                return ot.dir(e, "nextSibling")
            },
            prevAll: function(e) {
                return ot.dir(e, "previousSibling")
            },
            nextUntil: function(e, t, i) {
                return ot.dir(e, "nextSibling", i)
            },
            prevUntil: function(e, t, i) {
                return ot.dir(e, "previousSibling", i)
            },
            siblings: function(e) {
                return ot.sibling((e.parentNode || {}).firstChild, e)
            },
            children: function(e) {
                return ot.sibling(e.firstChild)
            },
            contents: function(e) {
                return ot.nodeName(e, "iframe") ? e.contentDocument || e.contentWindow.document : ot.merge([], e.childNodes)
            }
        }, function(e, t) {
            ot.fn[e] = function(i, r) {
                var n = ot.map(this, t, i);
                return "Until" !== e.slice(-5) && (r = i), r && "string" == typeof r && (n = ot.filter(r, n)), this.length > 1 && (yt[e] || (n = ot.unique(n)), gt.test(e) && (n = n.reverse())), this.pushStack(n)
            }
        });
        var Tt = /\S+/g,
            xt = {};
        ot.Callbacks = function(e) {
            e = "string" == typeof e ? xt[e] || o(e) : ot.extend({}, e);
            var t, i, r, n, a, s, l = [],
                h = !e.once && [],
                u = function(o) {
                    for (i = e.memory && o, r = !0, a = s || 0, s = 0, n = l.length, t = !0; l && n > a; a++)
                        if (l[a].apply(o[0], o[1]) === !1 && e.stopOnFalse) {
                            i = !1;
                            break
                        }
                    t = !1, l && (h ? h.length && u(h.shift()) : i ? l = [] : c.disable())
                },
                c = {
                    add: function() {
                        if (l) {
                            var r = l.length;
                            ! function o(t) {
                                ot.each(t, function(t, i) {
                                    var r = ot.type(i);
                                    "function" === r ? e.unique && c.has(i) || l.push(i) : i && i.length && "string" !== r && o(i)
                                })
                            }(arguments), t ? n = l.length : i && (s = r, u(i))
                        }
                        return this
                    },
                    remove: function() {
                        return l && ot.each(arguments, function(e, i) {
                            for (var r;
                                (r = ot.inArray(i, l, r)) > -1;) l.splice(r, 1), t && (n >= r && n--, a >= r && a--)
                        }), this
                    },
                    has: function(e) {
                        return e ? ot.inArray(e, l) > -1 : !(!l || !l.length)
                    },
                    empty: function() {
                        return l = [], n = 0, this
                    },
                    disable: function() {
                        return l = h = i = void 0, this
                    },
                    disabled: function() {
                        return !l
                    },
                    lock: function() {
                        return h = void 0, i || c.disable(), this
                    },
                    locked: function() {
                        return !h
                    },
                    fireWith: function(e, i) {
                        return !l || r && !h || (i = i || [], i = [e, i.slice ? i.slice() : i], t ? h.push(i) : u(i)), this
                    },
                    fire: function() {
                        return c.fireWith(this, arguments), this
                    },
                    fired: function() {
                        return !!r
                    }
                };
            return c
        }, ot.extend({
            Deferred: function(e) {
                var t = [
                        ["resolve", "done", ot.Callbacks("once memory"), "resolved"],
                        ["reject", "fail", ot.Callbacks("once memory"), "rejected"],
                        ["notify", "progress", ot.Callbacks("memory")]
                    ],
                    i = "pending",
                    r = {
                        state: function() {
                            return i
                        },
                        always: function() {
                            return n.done(arguments).fail(arguments), this
                        },
                        then: function() {
                            var e = arguments;
                            return ot.Deferred(function(i) {
                                ot.each(t, function(t, o) {
                                    var a = ot.isFunction(e[t]) && e[t];
                                    n[o[1]](function() {
                                        var e = a && a.apply(this, arguments);
                                        e && ot.isFunction(e.promise) ? e.promise().done(i.resolve).fail(i.reject).progress(i.notify) : i[o[0] + "With"](this === r ? i.promise() : this, a ? [e] : arguments)
                                    })
                                }), e = null
                            }).promise()
                        },
                        promise: function(e) {
                            return null != e ? ot.extend(e, r) : r
                        }
                    },
                    n = {};
                return r.pipe = r.then, ot.each(t, function(e, o) {
                    var a = o[2],
                        s = o[3];
                    r[o[1]] = a.add, s && a.add(function() {
                        i = s
                    }, t[1 ^ e][2].disable, t[2][2].lock), n[o[0]] = function() {
                        return n[o[0] + "With"](this === n ? r : this, arguments), this
                    }, n[o[0] + "With"] = a.fireWith
                }), r.promise(n), e && e.call(n, n), n
            },
            when: function(e) {
                var t = 0,
                    i = Q.call(arguments),
                    r = i.length,
                    n = 1 !== r || e && ot.isFunction(e.promise) ? r : 0,
                    o = 1 === n ? e : ot.Deferred(),
                    a = function(e, t, i) {
                        return function(r) {
                            t[e] = this, i[e] = arguments.length > 1 ? Q.call(arguments) : r, i === s ? o.notifyWith(t, i) : --n || o.resolveWith(t, i)
                        }
                    },
                    s, l, h;
                if (r > 1)
                    for (s = new Array(r), l = new Array(r), h = new Array(r); r > t; t++) i[t] && ot.isFunction(i[t].promise) ? i[t].promise().done(a(t, h, i)).fail(o.reject).progress(a(t, l, s)) : --n;
                return n || o.resolveWith(h, i), o.promise()
            }
        });
        var _t;
        ot.fn.ready = function(e) {
            return ot.ready.promise().done(e), this
        }, ot.extend({
            isReady: !1,
            readyWait: 1,
            holdReady: function(e) {
                e ? ot.readyWait++ : ot.ready(!0)
            },
            ready: function(e) {
                if (e === !0 ? !--ot.readyWait : !ot.isReady) {
                    if (!mt.body) return setTimeout(ot.ready);
                    ot.isReady = !0, e !== !0 && --ot.readyWait > 0 || (_t.resolveWith(mt, [ot]), ot.fn.triggerHandler && (ot(mt).triggerHandler("ready"), ot(mt).off("ready")))
                }
            }
        }), ot.ready.promise = function(t) {
            if (!_t)
                if (_t = ot.Deferred(), "complete" === mt.readyState) setTimeout(ot.ready);
                else if (mt.addEventListener) mt.addEventListener("DOMContentLoaded", s, !1), e.addEventListener("load", s, !1);
            else {
                mt.attachEvent("onreadystatechange", s), e.attachEvent("onload", s);
                var i = !1;
                try {
                    i = null == e.frameElement && mt.documentElement
                } catch (r) {}
                i && i.doScroll && ! function n() {
                    if (!ot.isReady) {
                        try {
                            i.doScroll("left")
                        } catch (e) {
                            return setTimeout(n, 50)
                        }
                        a(), ot.ready()
                    }
                }()
            }
            return _t.promise(t)
        };
        var Rt = "undefined",
            bt;
        for (bt in ot(rt)) break;
        rt.ownLast = "0" !== bt, rt.inlineBlockNeedsLayout = !1, ot(function() {
                var e, t, i, r;
                i = mt.getElementsByTagName("body")[0], i && i.style && (t = mt.createElement("div"), r = mt.createElement("div"), r.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", i.appendChild(r).appendChild(t), typeof t.style.zoom !== Rt && (t.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1", rt.inlineBlockNeedsLayout = e = 3 === t.offsetWidth, e && (i.style.zoom = 1)), i.removeChild(r))
            }),
            function() {
                var e = mt.createElement("div");
                if (null == rt.deleteExpando) {
                    rt.deleteExpando = !0;
                    try {
                        delete e.test
                    } catch (t) {
                        rt.deleteExpando = !1
                    }
                }
                e = null
            }(), ot.acceptData = function(e) {
                var t = ot.noData[(e.nodeName + " ").toLowerCase()],
                    i = +e.nodeType || 1;
                return 1 !== i && 9 !== i ? !1 : !t || t !== !0 && e.getAttribute("classid") === t
            };
        var Ht = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            wt = /([A-Z])/g;
        ot.extend({
            cache: {},
            noData: {
                "applet ": !0,
                "embed ": !0,
                "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
            },
            hasData: function(e) {
                return e = e.nodeType ? ot.cache[e[ot.expando]] : e[ot.expando], !!e && !h(e)
            },
            data: function(e, t, i) {
                return u(e, t, i)
            },
            removeData: function(e, t) {
                return c(e, t)
            },
            _data: function(e, t, i) {
                return u(e, t, i, !0)
            },
            _removeData: function(e, t) {
                return c(e, t, !0)
            }
        }), ot.fn.extend({
            data: function(e, t) {
                var i, r, n, o = this[0],
                    a = o && o.attributes;
                if (void 0 === e) {
                    if (this.length && (n = ot.data(o), 1 === o.nodeType && !ot._data(o, "parsedAttrs"))) {
                        for (i = a.length; i--;) a[i] && (r = a[i].name, 0 === r.indexOf("data-") && (r = ot.camelCase(r.slice(5)), l(o, r, n[r])));
                        ot._data(o, "parsedAttrs", !0)
                    }
                    return n
                }
                return "object" == typeof e ? this.each(function() {
                    ot.data(this, e)
                }) : arguments.length > 1 ? this.each(function() {
                    ot.data(this, e, t)
                }) : o ? l(o, e, ot.data(o, e)) : void 0
            },
            removeData: function(e) {
                return this.each(function() {
                    ot.removeData(this, e)
                })
            }
        }), ot.extend({
            queue: function(e, t, i) {
                var r;
                return e ? (t = (t || "fx") + "queue", r = ot._data(e, t), i && (!r || ot.isArray(i) ? r = ot._data(e, t, ot.makeArray(i)) : r.push(i)), r || []) : void 0
            },
            dequeue: function(e, t) {
                t = t || "fx";
                var i = ot.queue(e, t),
                    r = i.length,
                    n = i.shift(),
                    o = ot._queueHooks(e, t),
                    a = function() {
                        ot.dequeue(e, t)
                    };
                "inprogress" === n && (n = i.shift(), r--), n && ("fx" === t && i.unshift("inprogress"), delete o.stop, n.call(e, a, o)), !r && o && o.empty.fire()
            },
            _queueHooks: function(e, t) {
                var i = t + "queueHooks";
                return ot._data(e, i) || ot._data(e, i, {
                    empty: ot.Callbacks("once memory").add(function() {
                        ot._removeData(e, t + "queue"), ot._removeData(e, i)
                    })
                })
            }
        }), ot.fn.extend({
            queue: function(e, t) {
                var i = 2;
                return "string" != typeof e && (t = e, e = "fx", i--), arguments.length < i ? ot.queue(this[0], e) : void 0 === t ? this : this.each(function() {
                    var i = ot.queue(this, e, t);
                    ot._queueHooks(this, e), "fx" === e && "inprogress" !== i[0] && ot.dequeue(this, e)
                })
            },
            dequeue: function(e) {
                return this.each(function() {
                    ot.dequeue(this, e)
                })
            },
            clearQueue: function(e) {
                return this.queue(e || "fx", [])
            },
            promise: function(e, t) {
                var i, r = 1,
                    n = ot.Deferred(),
                    o = this,
                    a = this.length,
                    s = function() {
                        --r || n.resolveWith(o, [o])
                    };
                for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; a--;) i = ot._data(o[a], e + "queueHooks"), i && i.empty && (r++, i.empty.add(s));
                return s(), n.promise(t)
            }
        });
        var Mt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
            St = ["Top", "Right", "Bottom", "Left"],
            Ct = function(e, t) {
                return e = t || e, "none" === ot.css(e, "display") || !ot.contains(e.ownerDocument, e)
            },
            At = ot.access = function(e, t, i, r, n, o, a) {
                var s = 0,
                    l = e.length,
                    h = null == i;
                if ("object" === ot.type(i)) {
                    n = !0;
                    for (s in i) ot.access(e, t, s, i[s], !0, o, a)
                } else if (void 0 !== r && (n = !0, ot.isFunction(r) || (a = !0), h && (a ? (t.call(e, r), t = null) : (h = t, t = function(e, t, i) {
                        return h.call(ot(e), i)
                    })), t))
                    for (; l > s; s++) t(e[s], i, a ? r : r.call(e[s], s, t(e[s], i)));
                return n ? e : h ? t.call(e) : l ? t(e[0], i) : o
            },
            Pt = /^(?:checkbox|radio)$/i;
        ! function() {
            var e = mt.createElement("input"),
                t = mt.createElement("div"),
                i = mt.createDocumentFragment();
            if (t.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", rt.leadingWhitespace = 3 === t.firstChild.nodeType, rt.tbody = !t.getElementsByTagName("tbody").length, rt.htmlSerialize = !!t.getElementsByTagName("link").length, rt.html5Clone = "<:nav></:nav>" !== mt.createElement("nav").cloneNode(!0).outerHTML, e.type = "checkbox", e.checked = !0, i.appendChild(e), rt.appendChecked = e.checked, t.innerHTML = "<textarea>x</textarea>", rt.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue, i.appendChild(t), t.innerHTML = "<input type='radio' checked='checked' name='t'/>", rt.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked, rt.noCloneEvent = !0, t.attachEvent && (t.attachEvent("onclick", function() {
                    rt.noCloneEvent = !1
                }), t.cloneNode(!0).click()), null == rt.deleteExpando) {
                rt.deleteExpando = !0;
                try {
                    delete t.test
                } catch (r) {
                    rt.deleteExpando = !1
                }
            }
        }(),
        function() {
            var t, i, r = mt.createElement("div");
            for (t in {
                    submit: !0,
                    change: !0,
                    focusin: !0
                }) i = "on" + t, (rt[t + "Bubbles"] = i in e) || (r.setAttribute(i, "t"), rt[t + "Bubbles"] = r.attributes[i].expando === !1);
            r = null
        }();
        var Lt = /^(?:input|select|textarea)$/i,
            Dt = /^key/,
            Ot = /^(?:mouse|pointer|contextmenu)|click/,
            $ = /^(?:focusinfocus|focusoutblur)$/,
            Ft = /^([^.]*)(?:\.(.+)|)$/;
        ot.event = {
            global: {},
            add: function(e, t, i, r, n) {
                var o, a, s, l, h, u, c, p, d, f, m, E = ot._data(e);
                if (E) {
                    for (i.handler && (l = i, i = l.handler, n = l.selector), i.guid || (i.guid = ot.guid++), (a = E.events) || (a = E.events = {}), (u = E.handle) || (u = E.handle = function(e) {
                            return typeof ot === Rt || e && ot.event.triggered === e.type ? void 0 : ot.event.dispatch.apply(u.elem, arguments)
                        }, u.elem = e), t = (t || "").match(Tt) || [""], s = t.length; s--;) o = Ft.exec(t[s]) || [], d = m = o[1], f = (o[2] || "").split(".").sort(), d && (h = ot.event.special[d] || {}, d = (n ? h.delegateType : h.bindType) || d, h = ot.event.special[d] || {}, c = ot.extend({
                        type: d,
                        origType: m,
                        data: r,
                        handler: i,
                        guid: i.guid,
                        selector: n,
                        needsContext: n && ot.expr.match.needsContext.test(n),
                        namespace: f.join(".")
                    }, l), (p = a[d]) || (p = a[d] = [], p.delegateCount = 0, h.setup && h.setup.call(e, r, f, u) !== !1 || (e.addEventListener ? e.addEventListener(d, u, !1) : e.attachEvent && e.attachEvent("on" + d, u))), h.add && (h.add.call(e, c), c.handler.guid || (c.handler.guid = i.guid)), n ? p.splice(p.delegateCount++, 0, c) : p.push(c), ot.event.global[d] = !0);
                    e = null
                }
            },
            remove: function(e, t, i, r, n) {
                var o, a, s, l, h, u, c, p, d, f, m, E = ot.hasData(e) && ot._data(e);
                if (E && (u = E.events)) {
                    for (t = (t || "").match(Tt) || [""], h = t.length; h--;)
                        if (s = Ft.exec(t[h]) || [], d = m = s[1], f = (s[2] || "").split(".").sort(), d) {
                            for (c = ot.event.special[d] || {}, d = (r ? c.delegateType : c.bindType) || d, p = u[d] || [], s = s[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), l = o = p.length; o--;) a = p[o], !n && m !== a.origType || i && i.guid !== a.guid || s && !s.test(a.namespace) || r && r !== a.selector && ("**" !== r || !a.selector) || (p.splice(o, 1), a.selector && p.delegateCount--, c.remove && c.remove.call(e, a));
                            l && !p.length && (c.teardown && c.teardown.call(e, f, E.handle) !== !1 || ot.removeEvent(e, d, E.handle), delete u[d])
                        } else
                            for (d in u) ot.event.remove(e, d + t[h], i, r, !0);
                    ot.isEmptyObject(u) && (delete E.handle, ot._removeData(e, "events"))
                }
            },
            trigger: function(t, i, r, n) {
                var o, a, s, l, h, u, c, p = [r || mt],
                    d = it.call(t, "type") ? t.type : t,
                    f = it.call(t, "namespace") ? t.namespace.split(".") : [];
                if (s = u = r = r || mt, 3 !== r.nodeType && 8 !== r.nodeType && !$.test(d + ot.event.triggered) && (d.indexOf(".") >= 0 && (f = d.split("."), d = f.shift(), f.sort()), a = d.indexOf(":") < 0 && "on" + d, t = t[ot.expando] ? t : new ot.Event(d, "object" == typeof t && t), t.isTrigger = n ? 2 : 3, t.namespace = f.join("."), t.namespace_re = t.namespace ? new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = r), i = null == i ? [t] : ot.makeArray(i, [t]), h = ot.event.special[d] || {}, n || !h.trigger || h.trigger.apply(r, i) !== !1)) {
                    if (!n && !h.noBubble && !ot.isWindow(r)) {
                        for (l = h.delegateType || d, $.test(l + d) || (s = s.parentNode); s; s = s.parentNode) p.push(s), u = s;
                        u === (r.ownerDocument || mt) && p.push(u.defaultView || u.parentWindow || e)
                    }
                    for (c = 0;
                        (s = p[c++]) && !t.isPropagationStopped();) t.type = c > 1 ? l : h.bindType || d, o = (ot._data(s, "events") || {})[t.type] && ot._data(s, "handle"), o && o.apply(s, i), o = a && s[a], o && o.apply && ot.acceptData(s) && (t.result = o.apply(s, i), t.result === !1 && t.preventDefault());
                    if (t.type = d, !n && !t.isDefaultPrevented() && (!h._default || h._default.apply(p.pop(), i) === !1) && ot.acceptData(r) && a && r[d] && !ot.isWindow(r)) {
                        u = r[a], u && (r[a] = null), ot.event.triggered = d;
                        try {
                            r[d]()
                        } catch (m) {}
                        ot.event.triggered = void 0, u && (r[a] = u)
                    }
                    return t.result
                }
            },
            dispatch: function(e) {
                e = ot.event.fix(e);
                var t, i, r, n, o, a = [],
                    s = Q.call(arguments),
                    l = (ot._data(this, "events") || {})[e.type] || [],
                    h = ot.event.special[e.type] || {};
                if (s[0] = e, e.delegateTarget = this, !h.preDispatch || h.preDispatch.call(this, e) !== !1) {
                    for (a = ot.event.handlers.call(this, e, l), t = 0;
                        (n = a[t++]) && !e.isPropagationStopped();)
                        for (e.currentTarget = n.elem, o = 0;
                            (r = n.handlers[o++]) && !e.isImmediatePropagationStopped();)(!e.namespace_re || e.namespace_re.test(r.namespace)) && (e.handleObj = r, e.data = r.data, i = ((ot.event.special[r.origType] || {}).handle || r.handler).apply(n.elem, s), void 0 !== i && (e.result = i) === !1 && (e.preventDefault(), e.stopPropagation()));
                    return h.postDispatch && h.postDispatch.call(this, e), e.result
                }
            },
            handlers: function(e, t) {
                var i, r, n, o, a = [],
                    s = t.delegateCount,
                    l = e.target;
                if (s && l.nodeType && (!e.button || "click" !== e.type))
                    for (; l != this; l = l.parentNode || this)
                        if (1 === l.nodeType && (l.disabled !== !0 || "click" !== e.type)) {
                            for (n = [], o = 0; s > o; o++) r = t[o], i = r.selector + " ", void 0 === n[i] && (n[i] = r.needsContext ? ot(i, this).index(l) >= 0 : ot.find(i, this, null, [l]).length), n[i] && n.push(r);
                            n.length && a.push({
                                elem: l,
                                handlers: n
                            })
                        }
                return s < t.length && a.push({
                    elem: this,
                    handlers: t.slice(s)
                }), a
            },
            fix: function(e) {
                if (e[ot.expando]) return e;
                var t, i, r, n = e.type,
                    o = e,
                    a = this.fixHooks[n];
                for (a || (this.fixHooks[n] = a = Ot.test(n) ? this.mouseHooks : Dt.test(n) ? this.keyHooks : {}), r = a.props ? this.props.concat(a.props) : this.props, e = new ot.Event(o), t = r.length; t--;) i = r[t], e[i] = o[i];
                return e.target || (e.target = o.srcElement || mt), 3 === e.target.nodeType && (e.target = e.target.parentNode), e.metaKey = !!e.metaKey, a.filter ? a.filter(e, o) : e
            },
            props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
            fixHooks: {},
            keyHooks: {
                props: "char charCode key keyCode".split(" "),
                filter: function(e, t) {
                    return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), e
                }
            },
            mouseHooks: {
                props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                filter: function(e, t) {
                    var i, r, n, o = t.button,
                        a = t.fromElement;
                    return null == e.pageX && null != t.clientX && (r = e.target.ownerDocument || mt, n = r.documentElement, i = r.body, e.pageX = t.clientX + (n && n.scrollLeft || i && i.scrollLeft || 0) - (n && n.clientLeft || i && i.clientLeft || 0), e.pageY = t.clientY + (n && n.scrollTop || i && i.scrollTop || 0) - (n && n.clientTop || i && i.clientTop || 0)), !e.relatedTarget && a && (e.relatedTarget = a === e.target ? t.toElement : a), e.which || void 0 === o || (e.which = 1 & o ? 1 : 2 & o ? 3 : 4 & o ? 2 : 0), e
                }
            },
            special: {
                load: {
                    noBubble: !0
                },
                focus: {
                    trigger: function() {
                        if (this !== f() && this.focus) try {
                            return this.focus(), !1
                        } catch (e) {}
                    },
                    delegateType: "focusin"
                },
                blur: {
                    trigger: function() {
                        return this === f() && this.blur ? (this.blur(), !1) : void 0
                    },
                    delegateType: "focusout"
                },
                click: {
                    trigger: function() {
                        return ot.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), !1) : void 0
                    },
                    _default: function(e) {
                        return ot.nodeName(e.target, "a")
                    }
                },
                beforeunload: {
                    postDispatch: function(e) {
                        void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
                    }
                }
            },
            simulate: function(e, t, i, r) {
                var n = ot.extend(new ot.Event, i, {
                    type: e,
                    isSimulated: !0,
                    originalEvent: {}
                });
                r ? ot.event.trigger(n, null, t) : ot.event.dispatch.call(t, n), n.isDefaultPrevented() && i.preventDefault()
            }
        }, ot.removeEvent = mt.removeEventListener ? function(e, t, i) {
            e.removeEventListener && e.removeEventListener(t, i, !1)
        } : function(e, t, i) {
            var r = "on" + t;
            e.detachEvent && (typeof e[r] === Rt && (e[r] = null), e.detachEvent(r, i))
        }, ot.Event = function(e, t) {
            return this instanceof ot.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && e.returnValue === !1 ? p : d) : this.type = e, t && ot.extend(this, t), this.timeStamp = e && e.timeStamp || ot.now(), void(this[ot.expando] = !0)) : new ot.Event(e, t)
        }, ot.Event.prototype = {
            isDefaultPrevented: d,
            isPropagationStopped: d,
            isImmediatePropagationStopped: d,
            preventDefault: function() {
                var e = this.originalEvent;
                this.isDefaultPrevented = p, e && (e.preventDefault ? e.preventDefault() : e.returnValue = !1)
            },
            stopPropagation: function() {
                var e = this.originalEvent;
                this.isPropagationStopped = p, e && (e.stopPropagation && e.stopPropagation(), e.cancelBubble = !0)
            },
            stopImmediatePropagation: function() {
                var e = this.originalEvent;
                this.isImmediatePropagationStopped = p, e && e.stopImmediatePropagation && e.stopImmediatePropagation(), this.stopPropagation()
            }
        }, ot.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        }, function(e, t) {
            ot.event.special[e] = {
                delegateType: t,
                bindType: t,
                handle: function(e) {
                    var i, r = this,
                        n = e.relatedTarget,
                        o = e.handleObj;
                    return (!n || n !== r && !ot.contains(r, n)) && (e.type = o.origType, i = o.handler.apply(this, arguments), e.type = t), i
                }
            }
        }), rt.submitBubbles || (ot.event.special.submit = {
            setup: function() {
                return ot.nodeName(this, "form") ? !1 : void ot.event.add(this, "click._submit keypress._submit", function(e) {
                    var t = e.target,
                        i = ot.nodeName(t, "input") || ot.nodeName(t, "button") ? t.form : void 0;
                    i && !ot._data(i, "submitBubbles") && (ot.event.add(i, "submit._submit", function(e) {
                        e._submit_bubble = !0
                    }), ot._data(i, "submitBubbles", !0))
                })
            },
            postDispatch: function(e) {
                e._submit_bubble && (delete e._submit_bubble, this.parentNode && !e.isTrigger && ot.event.simulate("submit", this.parentNode, e, !0))
            },
            teardown: function() {
                return ot.nodeName(this, "form") ? !1 : void ot.event.remove(this, "._submit")
            }
        }), rt.changeBubbles || (ot.event.special.change = {
            setup: function() {
                return Lt.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (ot.event.add(this, "propertychange._change", function(e) {
                    "checked" === e.originalEvent.propertyName && (this._just_changed = !0)
                }), ot.event.add(this, "click._change", function(e) {
                    this._just_changed && !e.isTrigger && (this._just_changed = !1), ot.event.simulate("change", this, e, !0)
                })), !1) : void ot.event.add(this, "beforeactivate._change", function(e) {
                    var t = e.target;
                    Lt.test(t.nodeName) && !ot._data(t, "changeBubbles") && (ot.event.add(t, "change._change", function(e) {
                        !this.parentNode || e.isSimulated || e.isTrigger || ot.event.simulate("change", this.parentNode, e, !0)
                    }), ot._data(t, "changeBubbles", !0))
                })
            },
            handle: function(e) {
                var t = e.target;
                return this !== t || e.isSimulated || e.isTrigger || "radio" !== t.type && "checkbox" !== t.type ? e.handleObj.handler.apply(this, arguments) : void 0
            },
            teardown: function() {
                return ot.event.remove(this, "._change"), !Lt.test(this.nodeName)
            }
        }), rt.focusinBubbles || ot.each({
            focus: "focusin",
            blur: "focusout"
        }, function(e, t) {
            var i = function(e) {
                ot.event.simulate(t, e.target, ot.event.fix(e), !0)
            };
            ot.event.special[t] = {
                setup: function() {
                    var r = this.ownerDocument || this,
                        n = ot._data(r, t);
                    n || r.addEventListener(e, i, !0), ot._data(r, t, (n || 0) + 1)
                },
                teardown: function() {
                    var r = this.ownerDocument || this,
                        n = ot._data(r, t) - 1;
                    n ? ot._data(r, t, n) : (r.removeEventListener(e, i, !0), ot._removeData(r, t))
                }
            }
        }), ot.fn.extend({
            on: function(e, t, i, r, n) {
                var o, a;
                if ("object" == typeof e) {
                    "string" != typeof t && (i = i || t, t = void 0);
                    for (o in e) this.on(o, t, i, e[o], n);
                    return this
                }
                if (null == i && null == r ? (r = t, i = t = void 0) : null == r && ("string" == typeof t ? (r = i, i = void 0) : (r = i, i = t, t = void 0)), r === !1) r = d;
                else if (!r) return this;
                return 1 === n && (a = r, r = function(e) {
                    return ot().off(e), a.apply(this, arguments)
                }, r.guid = a.guid || (a.guid = ot.guid++)), this.each(function() {
                    ot.event.add(this, e, r, i, t)
                })
            },
            one: function(e, t, i, r) {
                return this.on(e, t, i, r, 1)
            },
            off: function(e, t, i) {
                var r, n;
                if (e && e.preventDefault && e.handleObj) return r = e.handleObj, ot(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
                if ("object" == typeof e) {
                    for (n in e) this.off(n, t, e[n]);
                    return this
                }
                return (t === !1 || "function" == typeof t) && (i = t, t = void 0), i === !1 && (i = d), this.each(function() {
                    ot.event.remove(this, e, i, t)
                })
            },
            trigger: function(e, t) {
                return this.each(function() {
                    ot.event.trigger(e, t, this)
                })
            },
            triggerHandler: function(e, t) {
                var i = this[0];
                return i ? ot.event.trigger(e, t, i, !0) : void 0
            }
        });
        var kt = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
            Ut = / jQuery\d+="(?:null|\d+)"/g,
            Nt = new RegExp("<(?:" + kt + ")[\\s/>]", "i"),
            Bt = /^\s+/,
            zt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
            Vt = /<([\w:]+)/,
            It = /<tbody/i,
            jt = /<|&#?\w+;/,
            Gt = /<(?:script|style|link)/i,
            Wt = /checked\s*(?:[^=]|=\s*.checked.)/i,
            Xt = /^$|\/(?:java|ecma)script/i,
            qt = /^true\/(.*)/,
            Yt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
            Qt = {
                option: [1, "<select multiple='multiple'>", "</select>"],
                legend: [1, "<fieldset>", "</fieldset>"],
                area: [1, "<map>", "</map>"],
                param: [1, "<object>", "</object>"],
                thead: [1, "<table>", "</table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                _default: rt.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
            },
            Kt = m(mt),
            $t = Kt.appendChild(mt.createElement("div"));
        Qt.optgroup = Qt.option, Qt.tbody = Qt.tfoot = Qt.colgroup = Qt.caption = Qt.thead, Qt.th = Qt.td, ot.extend({
            clone: function(e, t, i) {
                var r, n, o, a, s, l = ot.contains(e.ownerDocument, e);
                if (rt.html5Clone || ot.isXMLDoc(e) || !Nt.test("<" + e.nodeName + ">") ? o = e.cloneNode(!0) : ($t.innerHTML = e.outerHTML, $t.removeChild(o = $t.firstChild)), !(rt.noCloneEvent && rt.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || ot.isXMLDoc(e)))
                    for (r = E(o), s = E(e), a = 0; null != (n = s[a]); ++a) r[a] && R(n, r[a]);
                if (t)
                    if (i)
                        for (s = s || E(e), r = r || E(o), a = 0; null != (n = s[a]); a++) _(n, r[a]);
                    else _(e, o);
                return r = E(o, "script"), r.length > 0 && x(r, !l && E(e, "script")), r = s = n = null, o
            },
            buildFragment: function(e, t, i, r) {
                for (var n, o, a, s, l, h, u, c = e.length, p = m(t), d = [], f = 0; c > f; f++)
                    if (o = e[f], o || 0 === o)
                        if ("object" === ot.type(o)) ot.merge(d, o.nodeType ? [o] : o);
                        else if (jt.test(o)) {
                    for (s = s || p.appendChild(t.createElement("div")), l = (Vt.exec(o) || ["", ""])[1].toLowerCase(), u = Qt[l] || Qt._default, s.innerHTML = u[1] + o.replace(zt, "<$1></$2>") + u[2], n = u[0]; n--;) s = s.lastChild;
                    if (!rt.leadingWhitespace && Bt.test(o) && d.push(t.createTextNode(Bt.exec(o)[0])), !rt.tbody)
                        for (o = "table" !== l || It.test(o) ? "<table>" !== u[1] || It.test(o) ? 0 : s : s.firstChild, n = o && o.childNodes.length; n--;) ot.nodeName(h = o.childNodes[n], "tbody") && !h.childNodes.length && o.removeChild(h);
                    for (ot.merge(d, s.childNodes), s.textContent = ""; s.firstChild;) s.removeChild(s.firstChild);
                    s = p.lastChild
                } else d.push(t.createTextNode(o));
                for (s && p.removeChild(s), rt.appendChecked || ot.grep(E(d, "input"), v), f = 0; o = d[f++];)
                    if ((!r || -1 === ot.inArray(o, r)) && (a = ot.contains(o.ownerDocument, o), s = E(p.appendChild(o), "script"), a && x(s), i))
                        for (n = 0; o = s[n++];) Xt.test(o.type || "") && i.push(o);
                return s = null, p
            },
            cleanData: function(e, t) {
                for (var i, r, n, o, a = 0, s = ot.expando, l = ot.cache, h = rt.deleteExpando, u = ot.event.special; null != (i = e[a]); a++)
                    if ((t || ot.acceptData(i)) && (n = i[s], o = n && l[n])) {
                        if (o.events)
                            for (r in o.events) u[r] ? ot.event.remove(i, r) : ot.removeEvent(i, r, o.handle);
                        l[n] && (delete l[n], h ? delete i[s] : typeof i.removeAttribute !== Rt ? i.removeAttribute(s) : i[s] = null, Y.push(n))
                    }
            }
        }), ot.fn.extend({
            text: function(e) {
                return At(this, function(e) {
                    return void 0 === e ? ot.text(this) : this.empty().append((this[0] && this[0].ownerDocument || mt).createTextNode(e))
                }, null, e, arguments.length)
            },
            append: function() {
                return this.domManip(arguments, function(e) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var t = g(this, e);
                        t.appendChild(e)
                    }
                })
            },
            prepend: function() {
                return this.domManip(arguments, function(e) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var t = g(this, e);
                        t.insertBefore(e, t.firstChild)
                    }
                })
            },
            before: function() {
                return this.domManip(arguments, function(e) {
                    this.parentNode && this.parentNode.insertBefore(e, this)
                })
            },
            after: function() {
                return this.domManip(arguments, function(e) {
                    this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
                })
            },
            remove: function(e, t) {
                for (var i, r = e ? ot.filter(e, this) : this, n = 0; null != (i = r[n]); n++) t || 1 !== i.nodeType || ot.cleanData(E(i)), i.parentNode && (t && ot.contains(i.ownerDocument, i) && x(E(i, "script")), i.parentNode.removeChild(i));
                return this
            },
            empty: function() {
                for (var e, t = 0; null != (e = this[t]); t++) {
                    for (1 === e.nodeType && ot.cleanData(E(e, !1)); e.firstChild;) e.removeChild(e.firstChild);
                    e.options && ot.nodeName(e, "select") && (e.options.length = 0)
                }
                return this
            },
            clone: function(e, t) {
                return e = null == e ? !1 : e, t = null == t ? e : t, this.map(function() {
                    return ot.clone(this, e, t)
                })
            },
            html: function(e) {
                return At(this, function(e) {
                    var t = this[0] || {},
                        i = 0,
                        r = this.length;
                    if (void 0 === e) return 1 === t.nodeType ? t.innerHTML.replace(Ut, "") : void 0;
                    if (!("string" != typeof e || Gt.test(e) || !rt.htmlSerialize && Nt.test(e) || !rt.leadingWhitespace && Bt.test(e) || Qt[(Vt.exec(e) || ["", ""])[1].toLowerCase()])) {
                        e = e.replace(zt, "<$1></$2>");
                        try {
                            for (; r > i; i++) t = this[i] || {}, 1 === t.nodeType && (ot.cleanData(E(t, !1)), t.innerHTML = e);
                            t = 0
                        } catch (n) {}
                    }
                    t && this.empty().append(e)
                }, null, e, arguments.length)
            },
            replaceWith: function() {
                var e = arguments[0];
                return this.domManip(arguments, function(t) {
                    e = this.parentNode, ot.cleanData(E(this)), e && e.replaceChild(t, this)
                }), e && (e.length || e.nodeType) ? this : this.remove()
            },
            detach: function(e) {
                return this.remove(e, !0)
            },
            domManip: function(e, t) {
                e = K.apply([], e);
                var i, r, n, o, a, s, l = 0,
                    h = this.length,
                    u = this,
                    c = h - 1,
                    p = e[0],
                    d = ot.isFunction(p);
                if (d || h > 1 && "string" == typeof p && !rt.checkClone && Wt.test(p)) return this.each(function(i) {
                    var r = u.eq(i);
                    d && (e[0] = p.call(this, i, r.html())), r.domManip(e, t)
                });
                if (h && (s = ot.buildFragment(e, this[0].ownerDocument, !1, this), i = s.firstChild, 1 === s.childNodes.length && (s = i), i)) {
                    for (o = ot.map(E(s, "script"), y), n = o.length; h > l; l++) r = s, l !== c && (r = ot.clone(r, !0, !0), n && ot.merge(o, E(r, "script"))), t.call(this[l], r, l);
                    if (n)
                        for (a = o[o.length - 1].ownerDocument, ot.map(o, T), l = 0; n > l; l++) r = o[l], Xt.test(r.type || "") && !ot._data(r, "globalEval") && ot.contains(a, r) && (r.src ? ot._evalUrl && ot._evalUrl(r.src) : ot.globalEval((r.text || r.textContent || r.innerHTML || "").replace(Yt, "")));
                    s = i = null
                }
                return this
            }
        }), ot.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function(e, t) {
            ot.fn[e] = function(e) {
                for (var i, r = 0, n = [], o = ot(e), a = o.length - 1; a >= r; r++) i = r === a ? this : this.clone(!0), ot(o[r])[t](i), Z.apply(n, i.get());
                return this.pushStack(n)
            }
        });
        var Zt, Jt = {};
        ! function() {
            var e;
            rt.shrinkWrapBlocks = function() {
                if (null != e) return e;
                e = !1;
                var t, i, r;
                return i = mt.getElementsByTagName("body")[0], i && i.style ? (t = mt.createElement("div"), r = mt.createElement("div"), r.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", i.appendChild(r).appendChild(t), typeof t.style.zoom !== Rt && (t.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1", t.appendChild(mt.createElement("div")).style.width = "5px", e = 3 !== t.offsetWidth), i.removeChild(r), e) : void 0
            }
        }();
        var ei = /^margin/,
            ti = new RegExp("^(" + Mt + ")(?!px)[a-z%]+$", "i"),
            ii, ri, ni = /^(top|right|bottom|left)$/;
        e.getComputedStyle ? (ii = function(e) {
            return e.ownerDocument.defaultView.getComputedStyle(e, null)
        }, ri = function(e, t, i) {
            var r, n, o, a, s = e.style;
            return i = i || ii(e), a = i ? i.getPropertyValue(t) || i[t] : void 0, i && ("" !== a || ot.contains(e.ownerDocument, e) || (a = ot.style(e, t)), ti.test(a) && ei.test(t) && (r = s.width, n = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = i.width, s.width = r, s.minWidth = n, s.maxWidth = o)), void 0 === a ? a : a + ""
        }) : mt.documentElement.currentStyle && (ii = function(e) {
            return e.currentStyle
        }, ri = function(e, t, i) {
            var r, n, o, a, s = e.style;
            return i = i || ii(e), a = i ? i[t] : void 0, null == a && s && s[t] && (a = s[t]), ti.test(a) && !ni.test(t) && (r = s.left, n = e.runtimeStyle, o = n && n.left, o && (n.left = e.currentStyle.left), s.left = "fontSize" === t ? "1em" : a, a = s.pixelLeft + "px", s.left = r, o && (n.left = o)), void 0 === a ? a : a + "" || "auto"
        }), ! function() {
            function t() {
                var t, i, r, n;
                i = mt.getElementsByTagName("body")[0], i && i.style && (t = mt.createElement("div"), r = mt.createElement("div"), r.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", i.appendChild(r).appendChild(t), t.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", o = a = !1, l = !0, e.getComputedStyle && (o = "1%" !== (e.getComputedStyle(t, null) || {}).top, a = "4px" === (e.getComputedStyle(t, null) || {
                    width: "4px"
                }).width, n = t.appendChild(mt.createElement("div")), n.style.cssText = t.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", n.style.marginRight = n.style.width = "0", t.style.width = "1px", l = !parseFloat((e.getComputedStyle(n, null) || {}).marginRight)), t.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", n = t.getElementsByTagName("td"), n[0].style.cssText = "margin:0;border:0;padding:0;display:none", s = 0 === n[0].offsetHeight, s && (n[0].style.display = "", n[1].style.display = "none", s = 0 === n[0].offsetHeight), i.removeChild(r))
            }
            var i, r, n, o, a, s, l;
            i = mt.createElement("div"), i.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", n = i.getElementsByTagName("a")[0], (r = n && n.style) && (r.cssText = "float:left;opacity:.5", rt.opacity = "0.5" === r.opacity, rt.cssFloat = !!r.cssFloat, i.style.backgroundClip = "content-box", i.cloneNode(!0).style.backgroundClip = "", rt.clearCloneStyle = "content-box" === i.style.backgroundClip, rt.boxSizing = "" === r.boxSizing || "" === r.MozBoxSizing || "" === r.WebkitBoxSizing, ot.extend(rt, {
                reliableHiddenOffsets: function() {
                    return null == s && t(), s
                },
                boxSizingReliable: function() {
                    return null == a && t(), a
                },
                pixelPosition: function() {
                    return null == o && t(), o
                },
                reliableMarginRight: function() {
                    return null == l && t(), l
                }
            }))
        }(), ot.swap = function(e, t, i, r) {
            var n, o, a = {};
            for (o in t) a[o] = e.style[o], e.style[o] = t[o];
            n = i.apply(e, r || []);
            for (o in t) e.style[o] = a[o];
            return n
        };
        var oi = /alpha\([^)]*\)/i,
            ai = /opacity\s*=\s*([^)]*)/,
            si = /^(none|table(?!-c[ea]).+)/,
            li = new RegExp("^(" + Mt + ")(.*)$", "i"),
            hi = new RegExp("^([+-])=(" + Mt + ")", "i"),
            ui = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            },
            ci = {
                letterSpacing: "0",
                fontWeight: "400"
            },
            pi = ["Webkit", "O", "Moz", "ms"];
        ot.extend({
            cssHooks: {
                opacity: {
                    get: function(e, t) {
                        if (t) {
                            var i = ri(e, "opacity");
                            return "" === i ? "1" : i
                        }
                    }
                }
            },
            cssNumber: {
                columnCount: !0,
                fillOpacity: !0,
                flexGrow: !0,
                flexShrink: !0,
                fontWeight: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0
            },
            cssProps: {
                "float": rt.cssFloat ? "cssFloat" : "styleFloat"
            },
            style: function(e, t, i, r) {
                if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                    var n, o, a, s = ot.camelCase(t),
                        l = e.style;
                    if (t = ot.cssProps[s] || (ot.cssProps[s] = M(l, s)), a = ot.cssHooks[t] || ot.cssHooks[s], void 0 === i) return a && "get" in a && void 0 !== (n = a.get(e, !1, r)) ? n : l[t];
                    if (o = typeof i, "string" === o && (n = hi.exec(i)) && (i = (n[1] + 1) * n[2] + parseFloat(ot.css(e, t)), o = "number"), null != i && i === i && ("number" !== o || ot.cssNumber[s] || (i += "px"), rt.clearCloneStyle || "" !== i || 0 !== t.indexOf("background") || (l[t] = "inherit"), !(a && "set" in a && void 0 === (i = a.set(e, i, r))))) try {
                        l[t] = i
                    } catch (h) {}
                }
            },
            css: function(e, t, i, r) {
                var n, o, a, s = ot.camelCase(t);
                return t = ot.cssProps[s] || (ot.cssProps[s] = M(e.style, s)), a = ot.cssHooks[t] || ot.cssHooks[s], a && "get" in a && (o = a.get(e, !0, i)), void 0 === o && (o = ri(e, t, r)), "normal" === o && t in ci && (o = ci[t]), "" === i || i ? (n = parseFloat(o), i === !0 || ot.isNumeric(n) ? n || 0 : o) : o
            }
        }), ot.each(["height", "width"], function(e, t) {
            ot.cssHooks[t] = {
                get: function(e, i, r) {
                    return i ? si.test(ot.css(e, "display")) && 0 === e.offsetWidth ? ot.swap(e, ui, function() {
                        return P(e, t, r)
                    }) : P(e, t, r) : void 0
                },
                set: function(e, i, r) {
                    var n = r && ii(e);
                    return C(e, i, r ? A(e, t, r, rt.boxSizing && "border-box" === ot.css(e, "boxSizing", !1, n), n) : 0)
                }
            }
        }), rt.opacity || (ot.cssHooks.opacity = {
            get: function(e, t) {
                return ai.test((t && e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : t ? "1" : ""
            },
            set: function(e, t) {
                var i = e.style,
                    r = e.currentStyle,
                    n = ot.isNumeric(t) ? "alpha(opacity=" + 100 * t + ")" : "",
                    o = r && r.filter || i.filter || "";
                i.zoom = 1, (t >= 1 || "" === t) && "" === ot.trim(o.replace(oi, "")) && i.removeAttribute && (i.removeAttribute("filter"), "" === t || r && !r.filter) || (i.filter = oi.test(o) ? o.replace(oi, n) : o + " " + n)
            }
        }), ot.cssHooks.marginRight = w(rt.reliableMarginRight, function(e, t) {
            return t ? ot.swap(e, {
                display: "inline-block"
            }, ri, [e, "marginRight"]) : void 0
        }), ot.each({
            margin: "",
            padding: "",
            border: "Width"
        }, function(e, t) {
            ot.cssHooks[e + t] = {
                expand: function(i) {
                    for (var r = 0, n = {}, o = "string" == typeof i ? i.split(" ") : [i]; 4 > r; r++) n[e + St[r] + t] = o[r] || o[r - 2] || o[0];
                    return n
                }
            }, ei.test(e) || (ot.cssHooks[e + t].set = C)
        }), ot.fn.extend({
            css: function(e, t) {
                return At(this, function(e, t, i) {
                    var r, n, o = {},
                        a = 0;
                    if (ot.isArray(t)) {
                        for (r = ii(e), n = t.length; n > a; a++) o[t[a]] = ot.css(e, t[a], !1, r);
                        return o
                    }
                    return void 0 !== i ? ot.style(e, t, i) : ot.css(e, t)
                }, e, t, arguments.length > 1)
            },
            show: function() {
                return S(this, !0)
            },
            hide: function() {
                return S(this)
            },
            toggle: function(e) {
                return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
                    Ct(this) ? ot(this).show() : ot(this).hide()
                })
            }
        }), ot.Tween = L, L.prototype = {
            constructor: L,
            init: function(e, t, i, r, n, o) {
                this.elem = e, this.prop = i, this.easing = n || "swing", this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (ot.cssNumber[i] ? "" : "px")
            },
            cur: function() {
                var e = L.propHooks[this.prop];
                return e && e.get ? e.get(this) : L.propHooks._default.get(this)
            },
            run: function(e) {
                var t, i = L.propHooks[this.prop];
                return this.pos = t = this.options.duration ? ot.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), i && i.set ? i.set(this) : L.propHooks._default.set(this), this
            }
        }, L.prototype.init.prototype = L.prototype, L.propHooks = {
            _default: {
                get: function(e) {
                    var t;
                    return null == e.elem[e.prop] || e.elem.style && null != e.elem.style[e.prop] ? (t = ot.css(e.elem, e.prop, ""), t && "auto" !== t ? t : 0) : e.elem[e.prop]
                },
                set: function(e) {
                    ot.fx.step[e.prop] ? ot.fx.step[e.prop](e) : e.elem.style && (null != e.elem.style[ot.cssProps[e.prop]] || ot.cssHooks[e.prop]) ? ot.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now
                }
            }
        }, L.propHooks.scrollTop = L.propHooks.scrollLeft = {
            set: function(e) {
                e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
            }
        }, ot.easing = {
            linear: function(e) {
                return e
            },
            swing: function(e) {
                return .5 - Math.cos(e * Math.PI) / 2
            }
        }, ot.fx = L.prototype.init, ot.fx.step = {};
        var di, fi, mi = /^(?:toggle|show|hide)$/,
            Ei = new RegExp("^(?:([+-])=|)(" + Mt + ")([a-z%]*)$", "i"),
            vi = /queueHooks$/,
            gi = [k],
            yi = {
                "*": [function(e, t) {
                    var i = this.createTween(e, t),
                        r = i.cur(),
                        n = Ei.exec(t),
                        o = n && n[3] || (ot.cssNumber[e] ? "" : "px"),
                        a = (ot.cssNumber[e] || "px" !== o && +r) && Ei.exec(ot.css(i.elem, e)),
                        s = 1,
                        l = 20;
                    if (a && a[3] !== o) {
                        o = o || a[3], n = n || [], a = +r || 1;
                        do s = s || ".5", a /= s, ot.style(i.elem, e, a + o); while (s !== (s = i.cur() / r) && 1 !== s && --l)
                    }
                    return n && (a = i.start = +a || +r || 0, i.unit = o, i.end = n[1] ? a + (n[1] + 1) * n[2] : +n[2]), i
                }]
            };
        ot.Animation = ot.extend(N, {
                tweener: function(e, t) {
                    ot.isFunction(e) ? (t = e, e = ["*"]) : e = e.split(" ");
                    for (var i, r = 0, n = e.length; n > r; r++) i = e[r], yi[i] = yi[i] || [], yi[i].unshift(t)
                },
                prefilter: function(e, t) {
                    t ? gi.unshift(e) : gi.push(e)
                }
            }), ot.speed = function(e, t, i) {
                var r = e && "object" == typeof e ? ot.extend({}, e) : {
                    complete: i || !i && t || ot.isFunction(e) && e,
                    duration: e,
                    easing: i && t || t && !ot.isFunction(t) && t
                };
                return r.duration = ot.fx.off ? 0 : "number" == typeof r.duration ? r.duration : r.duration in ot.fx.speeds ? ot.fx.speeds[r.duration] : ot.fx.speeds._default, (null == r.queue || r.queue === !0) && (r.queue = "fx"), r.old = r.complete, r.complete = function() {
                    ot.isFunction(r.old) && r.old.call(this), r.queue && ot.dequeue(this, r.queue)
                }, r
            }, ot.fn.extend({
                fadeTo: function(e, t, i, r) {
                    return this.filter(Ct).css("opacity", 0).show().end().animate({
                        opacity: t
                    }, e, i, r)
                },
                animate: function(e, t, i, r) {
                    var n = ot.isEmptyObject(e),
                        o = ot.speed(t, i, r),
                        a = function() {
                            var t = N(this, ot.extend({}, e), o);
                            (n || ot._data(this, "finish")) && t.stop(!0)
                        };
                    return a.finish = a, n || o.queue === !1 ? this.each(a) : this.queue(o.queue, a)
                },
                stop: function(e, t, i) {
                    var r = function(e) {
                        var t = e.stop;
                        delete e.stop, t(i)
                    };
                    return "string" != typeof e && (i = t, t = e, e = void 0), t && e !== !1 && this.queue(e || "fx", []), this.each(function() {
                        var t = !0,
                            n = null != e && e + "queueHooks",
                            o = ot.timers,
                            a = ot._data(this);
                        if (n) a[n] && a[n].stop && r(a[n]);
                        else
                            for (n in a) a[n] && a[n].stop && vi.test(n) && r(a[n]);
                        for (n = o.length; n--;) o[n].elem !== this || null != e && o[n].queue !== e || (o[n].anim.stop(i), t = !1, o.splice(n, 1));
                        (t || !i) && ot.dequeue(this, e)
                    })
                },
                finish: function(e) {
                    return e !== !1 && (e = e || "fx"), this.each(function() {
                        var t, i = ot._data(this),
                            r = i[e + "queue"],
                            n = i[e + "queueHooks"],
                            o = ot.timers,
                            a = r ? r.length : 0;
                        for (i.finish = !0, ot.queue(this, e, []), n && n.stop && n.stop.call(this, !0), t = o.length; t--;) o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));
                        for (t = 0; a > t; t++) r[t] && r[t].finish && r[t].finish.call(this);
                        delete i.finish
                    })
                }
            }), ot.each(["toggle", "show", "hide"], function(e, t) {
                var i = ot.fn[t];
                ot.fn[t] = function(e, r, n) {
                    return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(O(t, !0), e, r, n)
                }
            }), ot.each({
                slideDown: O("show"),
                slideUp: O("hide"),
                slideToggle: O("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, function(e, t) {
                ot.fn[e] = function(e, i, r) {
                    return this.animate(t, e, i, r)
                }
            }), ot.timers = [], ot.fx.tick = function() {
                var e, t = ot.timers,
                    i = 0;
                for (di = ot.now(); i < t.length; i++) e = t[i], e() || t[i] !== e || t.splice(i--, 1);
                t.length || ot.fx.stop(), di = void 0
            }, ot.fx.timer = function(e) {
                ot.timers.push(e), e() ? ot.fx.start() : ot.timers.pop()
            }, ot.fx.interval = 13, ot.fx.start = function() {
                fi || (fi = setInterval(ot.fx.tick, ot.fx.interval))
            }, ot.fx.stop = function() {
                clearInterval(fi), fi = null
            }, ot.fx.speeds = {
                slow: 600,
                fast: 200,
                _default: 400
            }, ot.fn.delay = function(e, t) {
                return e = ot.fx ? ot.fx.speeds[e] || e : e, t = t || "fx", this.queue(t, function(t, i) {
                    var r = setTimeout(t, e);
                    i.stop = function() {
                        clearTimeout(r)
                    }
                })
            },
            function() {
                var e, t, i, r, n;
                t = mt.createElement("div"), t.setAttribute("className", "t"), t.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", r = t.getElementsByTagName("a")[0], i = mt.createElement("select"), n = i.appendChild(mt.createElement("option")), e = t.getElementsByTagName("input")[0], r.style.cssText = "top:1px", rt.getSetAttribute = "t" !== t.className, rt.style = /top/.test(r.getAttribute("style")), rt.hrefNormalized = "/a" === r.getAttribute("href"), rt.checkOn = !!e.value, rt.optSelected = n.selected, rt.enctype = !!mt.createElement("form").enctype, i.disabled = !0, rt.optDisabled = !n.disabled, e = mt.createElement("input"), e.setAttribute("value", ""), rt.input = "" === e.getAttribute("value"), e.value = "t", e.setAttribute("type", "radio"), rt.radioValue = "t" === e.value
            }();
        var Ti = /\r/g;
        ot.fn.extend({
            val: function(e) {
                var t, i, r, n = this[0];
                return arguments.length ? (r = ot.isFunction(e), this.each(function(i) {
                    var n;
                    1 === this.nodeType && (n = r ? e.call(this, i, ot(this).val()) : e, null == n ? n = "" : "number" == typeof n ? n += "" : ot.isArray(n) && (n = ot.map(n, function(e) {
                        return null == e ? "" : e + ""
                    })), t = ot.valHooks[this.type] || ot.valHooks[this.nodeName.toLowerCase()], t && "set" in t && void 0 !== t.set(this, n, "value") || (this.value = n))
                })) : n ? (t = ot.valHooks[n.type] || ot.valHooks[n.nodeName.toLowerCase()], t && "get" in t && void 0 !== (i = t.get(n, "value")) ? i : (i = n.value, "string" == typeof i ? i.replace(Ti, "") : null == i ? "" : i)) : void 0
            }
        }), ot.extend({
            valHooks: {
                option: {
                    get: function(e) {
                        var t = ot.find.attr(e, "value");
                        return null != t ? t : ot.trim(ot.text(e))
                    }
                },
                select: {
                    get: function(e) {
                        for (var t, i, r = e.options, n = e.selectedIndex, o = "select-one" === e.type || 0 > n, a = o ? null : [], s = o ? n + 1 : r.length, l = 0 > n ? s : o ? n : 0; s > l; l++)
                            if (i = r[l], !(!i.selected && l !== n || (rt.optDisabled ? i.disabled : null !== i.getAttribute("disabled")) || i.parentNode.disabled && ot.nodeName(i.parentNode, "optgroup"))) {
                                if (t = ot(i).val(), o) return t;
                                a.push(t)
                            }
                        return a
                    },
                    set: function(e, t) {
                        for (var i, r, n = e.options, o = ot.makeArray(t), a = n.length; a--;)
                            if (r = n[a], ot.inArray(ot.valHooks.option.get(r), o) >= 0) try {
                                r.selected = i = !0
                            } catch (s) {
                                r.scrollHeight
                            } else r.selected = !1;
                        return i || (e.selectedIndex = -1), n
                    }
                }
            }
        }), ot.each(["radio", "checkbox"], function() {
            ot.valHooks[this] = {
                set: function(e, t) {
                    return ot.isArray(t) ? e.checked = ot.inArray(ot(e).val(), t) >= 0 : void 0
                }
            }, rt.checkOn || (ot.valHooks[this].get = function(e) {
                return null === e.getAttribute("value") ? "on" : e.value
            })
        });
        var xi, _i, Ri = ot.expr.attrHandle,
            bi = /^(?:checked|selected)$/i,
            Hi = rt.getSetAttribute,
            wi = rt.input;
        ot.fn.extend({
            attr: function(e, t) {
                return At(this, ot.attr, e, t, arguments.length > 1)
            },
            removeAttr: function(e) {
                return this.each(function() {
                    ot.removeAttr(this, e)
                })
            }
        }), ot.extend({
            attr: function(e, t, i) {
                var r, n, o = e.nodeType;
                return e && 3 !== o && 8 !== o && 2 !== o ? typeof e.getAttribute === Rt ? ot.prop(e, t, i) : (1 === o && ot.isXMLDoc(e) || (t = t.toLowerCase(), r = ot.attrHooks[t] || (ot.expr.match.bool.test(t) ? _i : xi)), void 0 === i ? r && "get" in r && null !== (n = r.get(e, t)) ? n : (n = ot.find.attr(e, t), null == n ? void 0 : n) : null !== i ? r && "set" in r && void 0 !== (n = r.set(e, i, t)) ? n : (e.setAttribute(t, i + ""), i) : void ot.removeAttr(e, t)) : void 0
            },
            removeAttr: function(e, t) {
                var i, r, n = 0,
                    o = t && t.match(Tt);
                if (o && 1 === e.nodeType)
                    for (; i = o[n++];) r = ot.propFix[i] || i, ot.expr.match.bool.test(i) ? wi && Hi || !bi.test(i) ? e[r] = !1 : e[ot.camelCase("default-" + i)] = e[r] = !1 : ot.attr(e, i, ""), e.removeAttribute(Hi ? i : r)
            },
            attrHooks: {
                type: {
                    set: function(e, t) {
                        if (!rt.radioValue && "radio" === t && ot.nodeName(e, "input")) {
                            var i = e.value;
                            return e.setAttribute("type", t), i && (e.value = i), t
                        }
                    }
                }
            }
        }), _i = {
            set: function(e, t, i) {
                return t === !1 ? ot.removeAttr(e, i) : wi && Hi || !bi.test(i) ? e.setAttribute(!Hi && ot.propFix[i] || i, i) : e[ot.camelCase("default-" + i)] = e[i] = !0, i
            }
        }, ot.each(ot.expr.match.bool.source.match(/\w+/g), function(e, t) {
            var i = Ri[t] || ot.find.attr;
            Ri[t] = wi && Hi || !bi.test(t) ? function(e, t, r) {
                var n, o;
                return r || (o = Ri[t], Ri[t] = n, n = null != i(e, t, r) ? t.toLowerCase() : null, Ri[t] = o), n
            } : function(e, t, i) {
                return i ? void 0 : e[ot.camelCase("default-" + t)] ? t.toLowerCase() : null
            }
        }), wi && Hi || (ot.attrHooks.value = {
            set: function(e, t, i) {
                return ot.nodeName(e, "input") ? void(e.defaultValue = t) : xi && xi.set(e, t, i)
            }
        }), Hi || (xi = {
            set: function(e, t, i) {
                var r = e.getAttributeNode(i);
                return r || e.setAttributeNode(r = e.ownerDocument.createAttribute(i)), r.value = t += "", "value" === i || t === e.getAttribute(i) ? t : void 0
            }
        }, Ri.id = Ri.name = Ri.coords = function(e, t, i) {
            var r;
            return i ? void 0 : (r = e.getAttributeNode(t)) && "" !== r.value ? r.value : null
        }, ot.valHooks.button = {
            get: function(e, t) {
                var i = e.getAttributeNode(t);
                return i && i.specified ? i.value : void 0
            },
            set: xi.set
        }, ot.attrHooks.contenteditable = {
            set: function(e, t, i) {
                xi.set(e, "" === t ? !1 : t, i)
            }
        }, ot.each(["width", "height"], function(e, t) {
            ot.attrHooks[t] = {
                set: function(e, i) {
                    return "" === i ? (e.setAttribute(t, "auto"), i) : void 0
                }
            }
        })), rt.style || (ot.attrHooks.style = {
            get: function(e) {
                return e.style.cssText || void 0
            },
            set: function(e, t) {
                return e.style.cssText = t + ""
            }
        });
        var Mi = /^(?:input|select|textarea|button|object)$/i,
            Si = /^(?:a|area)$/i;
        ot.fn.extend({
            prop: function(e, t) {
                return At(this, ot.prop, e, t, arguments.length > 1)
            },
            removeProp: function(e) {
                return e = ot.propFix[e] || e, this.each(function() {
                    try {
                        this[e] = void 0, delete this[e]
                    } catch (t) {}
                })
            }
        }), ot.extend({
            propFix: {
                "for": "htmlFor",
                "class": "className"
            },
            prop: function(e, t, i) {
                var r, n, o, a = e.nodeType;
                return e && 3 !== a && 8 !== a && 2 !== a ? (o = 1 !== a || !ot.isXMLDoc(e), o && (t = ot.propFix[t] || t, n = ot.propHooks[t]), void 0 !== i ? n && "set" in n && void 0 !== (r = n.set(e, i, t)) ? r : e[t] = i : n && "get" in n && null !== (r = n.get(e, t)) ? r : e[t]) : void 0
            },
            propHooks: {
                tabIndex: {
                    get: function(e) {
                        var t = ot.find.attr(e, "tabindex");
                        return t ? parseInt(t, 10) : Mi.test(e.nodeName) || Si.test(e.nodeName) && e.href ? 0 : -1
                    }
                }
            }
        }), rt.hrefNormalized || ot.each(["href", "src"], function(e, t) {
            ot.propHooks[t] = {
                get: function(e) {
                    return e.getAttribute(t, 4)
                }
            }
        }), rt.optSelected || (ot.propHooks.selected = {
            get: function(e) {
                var t = e.parentNode;
                return t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null
            }
        }), ot.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
            ot.propFix[this.toLowerCase()] = this
        }), rt.enctype || (ot.propFix.enctype = "encoding");
        var Ci = /[\t\r\n\f]/g;
        ot.fn.extend({
            addClass: function(e) {
                var t, i, r, n, o, a, s = 0,
                    l = this.length,
                    h = "string" == typeof e && e;
                if (ot.isFunction(e)) return this.each(function(t) {
                    ot(this).addClass(e.call(this, t, this.className))
                });
                if (h)
                    for (t = (e || "").match(Tt) || []; l > s; s++)
                        if (i = this[s], r = 1 === i.nodeType && (i.className ? (" " + i.className + " ").replace(Ci, " ") : " ")) {
                            for (o = 0; n = t[o++];) r.indexOf(" " + n + " ") < 0 && (r += n + " ");
                            a = ot.trim(r), i.className !== a && (i.className = a)
                        }
                return this
            },
            removeClass: function(e) {
                var t, i, r, n, o, a, s = 0,
                    l = this.length,
                    h = 0 === arguments.length || "string" == typeof e && e;
                if (ot.isFunction(e)) return this.each(function(t) {
                    ot(this).removeClass(e.call(this, t, this.className))
                });
                if (h)
                    for (t = (e || "").match(Tt) || []; l > s; s++)
                        if (i = this[s], r = 1 === i.nodeType && (i.className ? (" " + i.className + " ").replace(Ci, " ") : "")) {
                            for (o = 0; n = t[o++];)
                                for (; r.indexOf(" " + n + " ") >= 0;) r = r.replace(" " + n + " ", " ");
                            a = e ? ot.trim(r) : "", i.className !== a && (i.className = a)
                        }
                return this
            },
            toggleClass: function(e, t) {
                var i = typeof e;
                return "boolean" == typeof t && "string" === i ? t ? this.addClass(e) : this.removeClass(e) : this.each(ot.isFunction(e) ? function(i) {
                    ot(this).toggleClass(e.call(this, i, this.className, t), t)
                } : function() {
                    if ("string" === i)
                        for (var t, r = 0, n = ot(this), o = e.match(Tt) || []; t = o[r++];) n.hasClass(t) ? n.removeClass(t) : n.addClass(t);
                    else(i === Rt || "boolean" === i) && (this.className && ot._data(this, "__className__", this.className), this.className = this.className || e === !1 ? "" : ot._data(this, "__className__") || "")
                })
            },
            hasClass: function(e) {
                for (var t = " " + e + " ", i = 0, r = this.length; r > i; i++)
                    if (1 === this[i].nodeType && (" " + this[i].className + " ").replace(Ci, " ").indexOf(t) >= 0) return !0;
                return !1
            }
        }), ot.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(e, t) {
            ot.fn[t] = function(e, i) {
                return arguments.length > 0 ? this.on(t, null, e, i) : this.trigger(t)
            }
        }), ot.fn.extend({
            hover: function(e, t) {
                return this.mouseenter(e).mouseleave(t || e)
            },
            bind: function(e, t, i) {
                return this.on(e, null, t, i)
            },
            unbind: function(e, t) {
                return this.off(e, null, t)
            },
            delegate: function(e, t, i, r) {
                return this.on(t, e, i, r)
            },
            undelegate: function(e, t, i) {
                return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", i)
            }
        });
        var Ai = ot.now(),
            Pi = /\?/,
            Li = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
        ot.parseJSON = function(t) {
            if (e.JSON && e.JSON.parse) return e.JSON.parse(t + "");
            var i, r = null,
                n = ot.trim(t + "");
            return n && !ot.trim(n.replace(Li, function(e, t, n, o) {
                return i && t && (r = 0), 0 === r ? e : (i = n || t, r += !o - !n, "")
            })) ? Function("return " + n)() : ot.error("Invalid JSON: " + t)
        }, ot.parseXML = function(t) {
            var i, r;
            if (!t || "string" != typeof t) return null;
            try {
                e.DOMParser ? (r = new DOMParser, i = r.parseFromString(t, "text/xml")) : (i = new ActiveXObject("Microsoft.XMLDOM"), i.async = "false", i.loadXML(t))
            } catch (n) {
                i = void 0
            }
            return i && i.documentElement && !i.getElementsByTagName("parsererror").length || ot.error("Invalid XML: " + t), i
        };
        var Di, Oi, Fi = /#.*$/,
            ki = /([?&])_=[^&]*/,
            Ui = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm,
            Ni = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
            Bi = /^(?:GET|HEAD)$/,
            zi = /^\/\//,
            Vi = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
            Ii = {},
            ji = {},
            Gi = "*/".concat("*");
        try {
            Oi = location.href
        } catch (Wi) {
            Oi = mt.createElement("a"), Oi.href = "", Oi = Oi.href
        }
        Di = Vi.exec(Oi.toLowerCase()) || [], ot.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: Oi,
                type: "GET",
                isLocal: Ni.test(Di[1]),
                global: !0,
                processData: !0,
                async: !0,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                    "*": Gi,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },
                contents: {
                    xml: /xml/,
                    html: /html/,
                    json: /json/
                },
                responseFields: {
                    xml: "responseXML",
                    text: "responseText",
                    json: "responseJSON"
                },
                converters: {
                    "* text": String,
                    "text html": !0,
                    "text json": ot.parseJSON,
                    "text xml": ot.parseXML
                },
                flatOptions: {
                    url: !0,
                    context: !0
                }
            },
            ajaxSetup: function(e, t) {
                return t ? V(V(e, ot.ajaxSettings), t) : V(ot.ajaxSettings, e)
            },
            ajaxPrefilter: B(Ii),
            ajaxTransport: B(ji),
            ajax: function(e, t) {
                function i(e, t, i, r) {
                    var n, u, v, g, T, _ = t;
                    2 !== y && (y = 2, s && clearTimeout(s), h = void 0, a = r || "", x.readyState = e > 0 ? 4 : 0, n = e >= 200 && 300 > e || 304 === e, i && (g = I(c, x, i)), g = j(c, g, x, n), n ? (c.ifModified && (T = x.getResponseHeader("Last-Modified"), T && (ot.lastModified[o] = T), T = x.getResponseHeader("etag"), T && (ot.etag[o] = T)), 204 === e || "HEAD" === c.type ? _ = "nocontent" : 304 === e ? _ = "notmodified" : (_ = g.state, u = g.data, v = g.error, n = !v)) : (v = _, (e || !_) && (_ = "error", 0 > e && (e = 0))), x.status = e, x.statusText = (t || _) + "", n ? f.resolveWith(p, [u, _, x]) : f.rejectWith(p, [x, _, v]), x.statusCode(E), E = void 0, l && d.trigger(n ? "ajaxSuccess" : "ajaxError", [x, c, n ? u : v]), m.fireWith(p, [x, _]), l && (d.trigger("ajaxComplete", [x, c]), --ot.active || ot.event.trigger("ajaxStop")))
                }
                "object" == typeof e && (t = e, e = void 0), t = t || {};
                var r, n, o, a, s, l, h, u, c = ot.ajaxSetup({}, t),
                    p = c.context || c,
                    d = c.context && (p.nodeType || p.jquery) ? ot(p) : ot.event,
                    f = ot.Deferred(),
                    m = ot.Callbacks("once memory"),
                    E = c.statusCode || {},
                    v = {},
                    g = {},
                    y = 0,
                    T = "canceled",
                    x = {
                        readyState: 0,
                        getResponseHeader: function(e) {
                            var t;
                            if (2 === y) {
                                if (!u)
                                    for (u = {}; t = Ui.exec(a);) u[t[1].toLowerCase()] = t[2];
                                t = u[e.toLowerCase()]
                            }
                            return null == t ? null : t
                        },
                        getAllResponseHeaders: function() {
                            return 2 === y ? a : null
                        },
                        setRequestHeader: function(e, t) {
                            var i = e.toLowerCase();
                            return y || (e = g[i] = g[i] || e, v[e] = t), this
                        },
                        overrideMimeType: function(e) {
                            return y || (c.mimeType = e), this
                        },
                        statusCode: function(e) {
                            var t;
                            if (e)
                                if (2 > y)
                                    for (t in e) E[t] = [E[t], e[t]];
                                else x.always(e[x.status]);
                            return this
                        },
                        abort: function(e) {
                            var t = e || T;
                            return h && h.abort(t), i(0, t), this
                        }
                    };
                if (f.promise(x).complete = m.add, x.success = x.done, x.error = x.fail, c.url = ((e || c.url || Oi) + "").replace(Fi, "").replace(zi, Di[1] + "//"), c.type = t.method || t.type || c.method || c.type, c.dataTypes = ot.trim(c.dataType || "*").toLowerCase().match(Tt) || [""], null == c.crossDomain && (r = Vi.exec(c.url.toLowerCase()), c.crossDomain = !(!r || r[1] === Di[1] && r[2] === Di[2] && (r[3] || ("http:" === r[1] ? "80" : "443")) === (Di[3] || ("http:" === Di[1] ? "80" : "443")))), c.data && c.processData && "string" != typeof c.data && (c.data = ot.param(c.data, c.traditional)), z(Ii, c, t, x), 2 === y) return x;
                l = c.global, l && 0 === ot.active++ && ot.event.trigger("ajaxStart"), c.type = c.type.toUpperCase(), c.hasContent = !Bi.test(c.type), o = c.url, c.hasContent || (c.data && (o = c.url += (Pi.test(o) ? "&" : "?") + c.data, delete c.data), c.cache === !1 && (c.url = ki.test(o) ? o.replace(ki, "$1_=" + Ai++) : o + (Pi.test(o) ? "&" : "?") + "_=" + Ai++)), c.ifModified && (ot.lastModified[o] && x.setRequestHeader("If-Modified-Since", ot.lastModified[o]), ot.etag[o] && x.setRequestHeader("If-None-Match", ot.etag[o])), (c.data && c.hasContent && c.contentType !== !1 || t.contentType) && x.setRequestHeader("Content-Type", c.contentType), x.setRequestHeader("Accept", c.dataTypes[0] && c.accepts[c.dataTypes[0]] ? c.accepts[c.dataTypes[0]] + ("*" !== c.dataTypes[0] ? ", " + Gi + "; q=0.01" : "") : c.accepts["*"]);
                for (n in c.headers) x.setRequestHeader(n, c.headers[n]);
                if (c.beforeSend && (c.beforeSend.call(p, x, c) === !1 || 2 === y)) return x.abort();
                T = "abort";
                for (n in {
                        success: 1,
                        error: 1,
                        complete: 1
                    }) x[n](c[n]);
                if (h = z(ji, c, t, x)) {
                    x.readyState = 1, l && d.trigger("ajaxSend", [x, c]), c.async && c.timeout > 0 && (s = setTimeout(function() {
                        x.abort("timeout")
                    }, c.timeout));
                    try {
                        y = 1, h.send(v, i)
                    } catch (_) {
                        if (!(2 > y)) throw _;
                        i(-1, _)
                    }
                } else i(-1, "No Transport");
                return x
            },
            getJSON: function(e, t, i) {
                return ot.get(e, t, i, "json")
            },
            getScript: function(e, t) {
                return ot.get(e, void 0, t, "script")
            }
        }), ot.each(["get", "post"], function(e, t) {
            ot[t] = function(e, i, r, n) {
                return ot.isFunction(i) && (n = n || r, r = i, i = void 0), ot.ajax({
                    url: e,
                    type: t,
                    dataType: n,
                    data: i,
                    success: r
                })
            }
        }), ot.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e, t) {
            ot.fn[t] = function(e) {
                return this.on(t, e)
            }
        }), ot._evalUrl = function(e) {
            return ot.ajax({
                url: e,
                type: "GET",
                dataType: "script",
                async: !1,
                global: !1,
                "throws": !0
            })
        }, ot.fn.extend({
            wrapAll: function(e) {
                if (ot.isFunction(e)) return this.each(function(t) {
                    ot(this).wrapAll(e.call(this, t))
                });
                if (this[0]) {
                    var t = ot(e, this[0].ownerDocument).eq(0).clone(!0);
                    this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
                        for (var e = this; e.firstChild && 1 === e.firstChild.nodeType;) e = e.firstChild;
                        return e
                    }).append(this)
                }
                return this
            },
            wrapInner: function(e) {
                return this.each(ot.isFunction(e) ? function(t) {
                    ot(this).wrapInner(e.call(this, t))
                } : function() {
                    var t = ot(this),
                        i = t.contents();
                    i.length ? i.wrapAll(e) : t.append(e)
                })
            },
            wrap: function(e) {
                var t = ot.isFunction(e);
                return this.each(function(i) {
                    ot(this).wrapAll(t ? e.call(this, i) : e)
                })
            },
            unwrap: function() {
                return this.parent().each(function() {
                    ot.nodeName(this, "body") || ot(this).replaceWith(this.childNodes)
                }).end()
            }
        }), ot.expr.filters.hidden = function(e) {
            return e.offsetWidth <= 0 && e.offsetHeight <= 0 || !rt.reliableHiddenOffsets() && "none" === (e.style && e.style.display || ot.css(e, "display"))
        }, ot.expr.filters.visible = function(e) {
            return !ot.expr.filters.hidden(e)
        };
        var Xi = /%20/g,
            qi = /\[\]$/,
            Yi = /\r?\n/g,
            Qi = /^(?:submit|button|image|reset|file)$/i,
            Ki = /^(?:input|select|textarea|keygen)/i;
        ot.param = function(e, t) {
            var i, r = [],
                n = function(e, t) {
                    t = ot.isFunction(t) ? t() : null == t ? "" : t, r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t)
                };
            if (void 0 === t && (t = ot.ajaxSettings && ot.ajaxSettings.traditional), ot.isArray(e) || e.jquery && !ot.isPlainObject(e)) ot.each(e, function() {
                n(this.name, this.value)
            });
            else
                for (i in e) G(i, e[i], t, n);
            return r.join("&").replace(Xi, "+")
        }, ot.fn.extend({
            serialize: function() {
                return ot.param(this.serializeArray())
            },
            serializeArray: function() {
                return this.map(function() {
                    var e = ot.prop(this, "elements");
                    return e ? ot.makeArray(e) : this
                }).filter(function() {
                    var e = this.type;
                    return this.name && !ot(this).is(":disabled") && Ki.test(this.nodeName) && !Qi.test(e) && (this.checked || !Pt.test(e))
                }).map(function(e, t) {
                    var i = ot(this).val();
                    return null == i ? null : ot.isArray(i) ? ot.map(i, function(e) {
                        return {
                            name: t.name,
                            value: e.replace(Yi, "\r\n")
                        }
                    }) : {
                        name: t.name,
                        value: i.replace(Yi, "\r\n")
                    }
                }).get()
            }
        }), ot.ajaxSettings.xhr = void 0 !== e.ActiveXObject ? function() {
            return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && W() || X()
        } : W;
        var $i = 0,
            Zi = {},
            Ji = ot.ajaxSettings.xhr();
        e.ActiveXObject && ot(e).on("unload", function() {
            for (var e in Zi) Zi[e](void 0, !0)
        }), rt.cors = !!Ji && "withCredentials" in Ji, Ji = rt.ajax = !!Ji, Ji && ot.ajaxTransport(function(e) {
            if (!e.crossDomain || rt.cors) {
                var t;
                return {
                    send: function(i, r) {
                        var n, o = e.xhr(),
                            a = ++$i;
                        if (o.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields)
                            for (n in e.xhrFields) o[n] = e.xhrFields[n];
                        e.mimeType && o.overrideMimeType && o.overrideMimeType(e.mimeType), e.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest");
                        for (n in i) void 0 !== i[n] && o.setRequestHeader(n, i[n] + "");
                        o.send(e.hasContent && e.data || null), t = function(i, n) {
                            var s, l, h;
                            if (t && (n || 4 === o.readyState))
                                if (delete Zi[a], t = void 0, o.onreadystatechange = ot.noop, n) 4 !== o.readyState && o.abort();
                                else {
                                    h = {}, s = o.status, "string" == typeof o.responseText && (h.text = o.responseText);
                                    try {
                                        l = o.statusText
                                    } catch (u) {
                                        l = ""
                                    }
                                    s || !e.isLocal || e.crossDomain ? 1223 === s && (s = 204) : s = h.text ? 200 : 404
                                }
                            h && r(s, l, h, o.getAllResponseHeaders())
                        }, e.async ? 4 === o.readyState ? setTimeout(t) : o.onreadystatechange = Zi[a] = t : t()
                    },
                    abort: function() {
                        t && t(void 0, !0)
                    }
                }
            }
        }), ot.ajaxSetup({
            accepts: {
                script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            },
            contents: {
                script: /(?:java|ecma)script/
            },
            converters: {
                "text script": function(e) {
                    return ot.globalEval(e), e
                }
            }
        }), ot.ajaxPrefilter("script", function(e) {
            void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET", e.global = !1)
        }), ot.ajaxTransport("script", function(e) {
            if (e.crossDomain) {
                var t, i = mt.head || ot("head")[0] || mt.documentElement;
                return {
                    send: function(r, n) {
                        t = mt.createElement("script"), t.async = !0, e.scriptCharset && (t.charset = e.scriptCharset), t.src = e.url, t.onload = t.onreadystatechange = function(e, i) {
                            (i || !t.readyState || /loaded|complete/.test(t.readyState)) && (t.onload = t.onreadystatechange = null, t.parentNode && t.parentNode.removeChild(t), t = null, i || n(200, "success"))
                        }, i.insertBefore(t, i.firstChild)
                    },
                    abort: function() {
                        t && t.onload(void 0, !0)
                    }
                }
            }
        });
        var er = [],
            tr = /(=)\?(?=&|$)|\?\?/;
        ot.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function() {
                var e = er.pop() || ot.expando + "_" + Ai++;
                return this[e] = !0, e
            }
        }), ot.ajaxPrefilter("json jsonp", function(t, i, r) {
            var n, o, a, s = t.jsonp !== !1 && (tr.test(t.url) ? "url" : "string" == typeof t.data && !(t.contentType || "").indexOf("application/x-www-form-urlencoded") && tr.test(t.data) && "data");
            return s || "jsonp" === t.dataTypes[0] ? (n = t.jsonpCallback = ot.isFunction(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, s ? t[s] = t[s].replace(tr, "$1" + n) : t.jsonp !== !1 && (t.url += (Pi.test(t.url) ? "&" : "?") + t.jsonp + "=" + n), t.converters["script json"] = function() {
                return a || ot.error(n + " was not called"), a[0]
            }, t.dataTypes[0] = "json", o = e[n], e[n] = function() {
                a = arguments
            }, r.always(function() {
                e[n] = o, t[n] && (t.jsonpCallback = i.jsonpCallback, er.push(n)), a && ot.isFunction(o) && o(a[0]), a = o = void 0
            }), "script") : void 0
        }), ot.parseHTML = function(e, t, i) {
            if (!e || "string" != typeof e) return null;
            "boolean" == typeof t && (i = t, t = !1), t = t || mt;
            var r = pt.exec(e),
                n = !i && [];
            return r ? [t.createElement(r[1])] : (r = ot.buildFragment([e], t, n), n && n.length && ot(n).remove(), ot.merge([], r.childNodes))
        };
        var ir = ot.fn.load;
        ot.fn.load = function(e, t, i) {
            if ("string" != typeof e && ir) return ir.apply(this, arguments);
            var r, n, o, a = this,
                s = e.indexOf(" ");
            return s >= 0 && (r = ot.trim(e.slice(s, e.length)), e = e.slice(0, s)), ot.isFunction(t) ? (i = t, t = void 0) : t && "object" == typeof t && (o = "POST"), a.length > 0 && ot.ajax({
                url: e,
                type: o,
                dataType: "html",
                data: t
            }).done(function(e) {
                n = arguments, a.html(r ? ot("<div>").append(ot.parseHTML(e)).find(r) : e)
            }).complete(i && function(e, t) {
                a.each(i, n || [e.responseText, t, e])
            }), this
        }, ot.expr.filters.animated = function(e) {
            return ot.grep(ot.timers, function(t) {
                return e === t.elem
            }).length
        };
        var rr = e.document.documentElement;
        ot.offset = {
            setOffset: function(e, t, i) {
                var r, n, o, a, s, l, h, u = ot.css(e, "position"),
                    c = ot(e),
                    p = {};
                "static" === u && (e.style.position = "relative"), s = c.offset(), o = ot.css(e, "top"), l = ot.css(e, "left"), h = ("absolute" === u || "fixed" === u) && ot.inArray("auto", [o, l]) > -1, h ? (r = c.position(), a = r.top, n = r.left) : (a = parseFloat(o) || 0, n = parseFloat(l) || 0), ot.isFunction(t) && (t = t.call(e, i, s)), null != t.top && (p.top = t.top - s.top + a), null != t.left && (p.left = t.left - s.left + n), "using" in t ? t.using.call(e, p) : c.css(p)
            }
        }, ot.fn.extend({
            offset: function(e) {
                if (arguments.length) return void 0 === e ? this : this.each(function(t) {
                    ot.offset.setOffset(this, e, t)
                });
                var t, i, r = {
                        top: 0,
                        left: 0
                    },
                    n = this[0],
                    o = n && n.ownerDocument;
                return o ? (t = o.documentElement, ot.contains(t, n) ? (typeof n.getBoundingClientRect !== Rt && (r = n.getBoundingClientRect()), i = q(o), {
                    top: r.top + (i.pageYOffset || t.scrollTop) - (t.clientTop || 0),
                    left: r.left + (i.pageXOffset || t.scrollLeft) - (t.clientLeft || 0)
                }) : r) : void 0
            },
            position: function() {
                if (this[0]) {
                    var e, t, i = {
                            top: 0,
                            left: 0
                        },
                        r = this[0];
                    return "fixed" === ot.css(r, "position") ? t = r.getBoundingClientRect() : (e = this.offsetParent(), t = this.offset(), ot.nodeName(e[0], "html") || (i = e.offset()), i.top += ot.css(e[0], "borderTopWidth", !0), i.left += ot.css(e[0], "borderLeftWidth", !0)), {
                        top: t.top - i.top - ot.css(r, "marginTop", !0),
                        left: t.left - i.left - ot.css(r, "marginLeft", !0)
                    }
                }
            },
            offsetParent: function() {
                return this.map(function() {
                    for (var e = this.offsetParent || rr; e && !ot.nodeName(e, "html") && "static" === ot.css(e, "position");) e = e.offsetParent;
                    return e || rr
                })
            }
        }), ot.each({
            scrollLeft: "pageXOffset",
            scrollTop: "pageYOffset"
        }, function(e, t) {
            var i = /Y/.test(t);
            ot.fn[e] = function(r) {
                return At(this, function(e, r, n) {
                    var o = q(e);
                    return void 0 === n ? o ? t in o ? o[t] : o.document.documentElement[r] : e[r] : void(o ? o.scrollTo(i ? ot(o).scrollLeft() : n, i ? n : ot(o).scrollTop()) : e[r] = n)
                }, e, r, arguments.length, null)
            }
        }), ot.each(["top", "left"], function(e, t) {
            ot.cssHooks[t] = w(rt.pixelPosition, function(e, i) {
                return i ? (i = ri(e, t), ti.test(i) ? ot(e).position()[t] + "px" : i) : void 0
            })
        }), ot.each({
            Height: "height",
            Width: "width"
        }, function(e, t) {
            ot.each({
                padding: "inner" + e,
                content: t,
                "": "outer" + e
            }, function(i, r) {
                ot.fn[r] = function(r, n) {
                    var o = arguments.length && (i || "boolean" != typeof r),
                        a = i || (r === !0 || n === !0 ? "margin" : "border");
                    return At(this, function(t, i, r) {
                        var n;
                        return ot.isWindow(t) ? t.document.documentElement["client" + e] : 9 === t.nodeType ? (n = t.documentElement, Math.max(t.body["scroll" + e], n["scroll" + e], t.body["offset" + e], n["offset" + e], n["client" + e])) : void 0 === r ? ot.css(t, i, a) : ot.style(t, i, r, a)
                    }, t, o ? r : void 0, o, null)
                }
            })
        }), ot.fn.size = function() {
            return this.length
        }, ot.fn.andSelf = ot.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
            return ot
        });
        var nr = e.jQuery,
            or = e.$;
        return ot.noConflict = function(t) {
            return e.$ === ot && (e.$ = or), t && e.jQuery === ot && (e.jQuery = nr), ot
        }, typeof t === Rt && (e.jQuery = e.$ = ot), ot
    }), void 0 === jQuery.migrateMute && (jQuery.migrateMute = !0),
    function(e, t, i) {
        function r(i) {
            var r = t.console;
            o[i] || (o[i] = !0, e.migrateWarnings.push(i), r && r.warn && !e.migrateMute && (r.warn("JQMIGRATE: " + i), e.migrateTrace && r.trace && r.trace()))
        }

        function n(t, n, o, a) {
            if (Object.defineProperty) try {
                return Object.defineProperty(t, n, {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        return r(a), o
                    },
                    set: function(e) {
                        r(a), o = e
                    }
                }), i
            } catch (s) {}
            e._definePropertyBroken = !0, t[n] = o
        }
        var o = {};
        e.migrateWarnings = [], !e.migrateMute && t.console && t.console.log && t.console.log("JQMIGRATE: Logging is active"), e.migrateTrace === i && (e.migrateTrace = !0), e.migrateReset = function() {
            o = {}, e.migrateWarnings.length = 0
        }, "BackCompat" === document.compatMode && r("jQuery is not compatible with Quirks Mode");
        var a = e("<input/>", {
                size: 1
            }).attr("size") && e.attrFn,
            s = e.attr,
            l = e.attrHooks.value && e.attrHooks.value.get || function() {
                return null
            },
            h = e.attrHooks.value && e.attrHooks.value.set || function() {
                return i
            },
            u = /^(?:input|button)$/i,
            c = /^[238]$/,
            p = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
            d = /^(?:checked|selected)$/i;
        n(e, "attrFn", a || {}, "jQuery.attrFn is deprecated"), e.attr = function(t, n, o, l) {
            var h = n.toLowerCase(),
                f = t && t.nodeType;
            return l && (4 > s.length && r("jQuery.fn.attr( props, pass ) is deprecated"), t && !c.test(f) && (a ? n in a : e.isFunction(e.fn[n]))) ? e(t)[n](o) : ("type" === n && o !== i && u.test(t.nodeName) && t.parentNode && r("Can't change the 'type' of an input or button in IE 6/7/8"), !e.attrHooks[h] && p.test(h) && (e.attrHooks[h] = {
                get: function(t, r) {
                    var n, o = e.prop(t, r);
                    return o === !0 || "boolean" != typeof o && (n = t.getAttributeNode(r)) && n.nodeValue !== !1 ? r.toLowerCase() : i
                },
                set: function(t, i, r) {
                    var n;
                    return i === !1 ? e.removeAttr(t, r) : (n = e.propFix[r] || r, n in t && (t[n] = !0), t.setAttribute(r, r.toLowerCase())), r
                }
            }, d.test(h) && r("jQuery.fn.attr('" + h + "') may use property instead of attribute")), s.call(e, t, n, o))
        }, e.attrHooks.value = {
            get: function(e, t) {
                var i = (e.nodeName || "").toLowerCase();
                return "button" === i ? l.apply(this, arguments) : ("input" !== i && "option" !== i && r("jQuery.fn.attr('value') no longer gets properties"), t in e ? e.value : null)
            },
            set: function(e, t) {
                var n = (e.nodeName || "").toLowerCase();
                return "button" === n ? h.apply(this, arguments) : ("input" !== n && "option" !== n && r("jQuery.fn.attr('value', val) no longer sets properties"), e.value = t, i)
            }
        };
        var f, m, E = e.fn.init,
            v = e.parseJSON,
            g = /^([^<]*)(<[\w\W]+>)([^>]*)$/;
        e.fn.init = function(t, i, n) {
            var o;
            return t && "string" == typeof t && !e.isPlainObject(i) && (o = g.exec(e.trim(t))) && o[0] && ("<" !== t.charAt(0) && r("$(html) HTML strings must start with '<' character"), o[3] && r("$(html) HTML text after last tag is ignored"), "#" === o[0].charAt(0) && (r("HTML string cannot start with a '#' character"), e.error("JQMIGRATE: Invalid selector string (XSS)")), i && i.context && (i = i.context), e.parseHTML) ? E.call(this, e.parseHTML(o[2], i, !0), i, n) : E.apply(this, arguments)
        }, e.fn.init.prototype = e.fn, e.parseJSON = function(e) {
            return e || null === e ? v.apply(this, arguments) : (r("jQuery.parseJSON requires a valid JSON string"), null)
        }, e.uaMatch = function(e) {
            e = e.toLowerCase();
            var t = /(chrome)[ \/]([\w.]+)/.exec(e) || /(webkit)[ \/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e) || /(msie) ([\w.]+)/.exec(e) || 0 > e.indexOf("compatible") && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e) || [];
            return {
                browser: t[1] || "",
                version: t[2] || "0"
            }
        }, e.browser || (f = e.uaMatch(navigator.userAgent), m = {}, f.browser && (m[f.browser] = !0, m.version = f.version), m.chrome ? m.webkit = !0 : m.webkit && (m.safari = !0), e.browser = m), n(e, "browser", e.browser, "jQuery.browser is deprecated"), e.sub = function() {
            function t(e, i) {
                return new t.fn.init(e, i)
            }
            e.extend(!0, t, this), t.superclass = this, t.fn = t.prototype = this(), t.fn.constructor = t, t.sub = this.sub, t.fn.init = function(r, n) {
                return n && n instanceof e && !(n instanceof t) && (n = t(n)), e.fn.init.call(this, r, n, i)
            }, t.fn.init.prototype = t.fn;
            var i = t(document);
            return r("jQuery.sub() is deprecated"), t
        }, e.ajaxSetup({
            converters: {
                "text json": e.parseJSON
            }
        });
        var y = e.fn.data;
        e.fn.data = function(t) {
            var n, o, a = this[0];
            return !a || "events" !== t || 1 !== arguments.length || (n = e.data(a, t), o = e._data(a, t), n !== i && n !== o || o === i) ? y.apply(this, arguments) : (r("Use of jQuery.fn.data('events') is deprecated"), o)
        };
        var T = /\/(java|ecma)script/i,
            x = e.fn.andSelf || e.fn.addBack;
        e.fn.andSelf = function() {
            return r("jQuery.fn.andSelf() replaced by jQuery.fn.addBack()"), x.apply(this, arguments)
        }, e.clean || (e.clean = function(t, n, o, a) {
            n = n || document, n = !n.nodeType && n[0] || n, n = n.ownerDocument || n, r("jQuery.clean() is deprecated");
            var s, l, h, u, c = [];
            if (e.merge(c, e.buildFragment(t, n).childNodes), o)
                for (h = function(e) {
                        return !e.type || T.test(e.type) ? a ? a.push(e.parentNode ? e.parentNode.removeChild(e) : e) : o.appendChild(e) : i
                    }, s = 0; null != (l = c[s]); s++) e.nodeName(l, "script") && h(l) || (o.appendChild(l), l.getElementsByTagName !== i && (u = e.grep(e.merge([], l.getElementsByTagName("script")), h), c.splice.apply(c, [s + 1, 0].concat(u)), s += u.length));
            return c
        });
        var _ = e.event.add,
            R = e.event.remove,
            b = e.event.trigger,
            H = e.fn.toggle,
            w = e.fn.live,
            M = e.fn.die,
            S = "ajaxStart|ajaxStop|ajaxSend|ajaxComplete|ajaxError|ajaxSuccess",
            C = RegExp("\\b(?:" + S + ")\\b"),
            A = /(?:^|\s)hover(\.\S+|)\b/,
            P = function(t) {
                return "string" != typeof t || e.event.special.hover ? t : (A.test(t) && r("'hover' pseudo-event is deprecated, use 'mouseenter mouseleave'"), t && t.replace(A, "mouseenter$1 mouseleave$1"))
            };
        e.event.props && "attrChange" !== e.event.props[0] && e.event.props.unshift("attrChange", "attrName", "relatedNode", "srcElement"), e.event.dispatch && n(e.event, "handle", e.event.dispatch, "jQuery.event.handle is undocumented and deprecated"), e.event.add = function(e, t, i, n, o) {
            e !== document && C.test(t) && r("AJAX events should be attached to document: " + t), _.call(this, e, P(t || ""), i, n, o)
        }, e.event.remove = function(e, t, i, r, n) {
            R.call(this, e, P(t) || "", i, r, n)
        }, e.fn.error = function() {
            var e = Array.prototype.slice.call(arguments, 0);
            return r("jQuery.fn.error() is deprecated"), e.splice(0, 0, "error"), arguments.length ? this.bind.apply(this, e) : (this.triggerHandler.apply(this, e), this)
        }, e.fn.toggle = function(t, i) {
            if (!e.isFunction(t) || !e.isFunction(i)) return H.apply(this, arguments);
            r("jQuery.fn.toggle(handler, handler...) is deprecated");
            var n = arguments,
                o = t.guid || e.guid++,
                a = 0,
                s = function(i) {
                    var r = (e._data(this, "lastToggle" + t.guid) || 0) % a;
                    return e._data(this, "lastToggle" + t.guid, r + 1), i.preventDefault(), n[r].apply(this, arguments) || !1
                };
            for (s.guid = o; n.length > a;) n[a++].guid = o;
            return this.click(s)
        }, e.fn.live = function(t, i, n) {
            return r("jQuery.fn.live() is deprecated"), w ? w.apply(this, arguments) : (e(this.context).on(t, this.selector, i, n), this)
        }, e.fn.die = function(t, i) {
            return r("jQuery.fn.die() is deprecated"), M ? M.apply(this, arguments) : (e(this.context).off(t, this.selector || "**", i), this)
        }, e.event.trigger = function(e, t, i, n) {
            return i || C.test(e) || r("Global events are undocumented and deprecated"), b.call(this, e, t, i || document, n)
        }, e.each(S.split("|"), function(t, i) {
            e.event.special[i] = {
                setup: function() {
                    var t = this;
                    return t !== document && (e.event.add(document, i + "." + e.guid, function() {
                        e.event.trigger(i, null, t, !0)
                    }), e._data(this, i, e.guid++)), !1
                },
                teardown: function() {
                    return this !== document && e.event.remove(document, i + "." + e._data(this, i)), !1
                }
            }
        })
    }(jQuery, window),
    function(e) {
        function t(e) {
            e = e || {}, this.settings = e, null == e.statusInterval && (e.statusInterval = 5e3), null == e.loggingDelay && (e.loggingDelay = 5e3), null == e.noProgressTimeout && (e.noProgressTimeout = 1e4);
            var t = [],
                r = [],
                n, o = Date.now(),
                a = {
                    QUEUED: 0,
                    WAITING: 1,
                    LOADED: 2,
                    ERROR: 3,
                    TIMEOUT: 4
                },
                s = function(e) {
                    return null == e ? [] : Array.isArray(e) ? e : [e]
                };
            this.add = function(e) {
                e.tags = new i(e.tags), null == e.priority && (e.priority = 1 / 0), t.push({
                    resource: e,
                    status: a.QUEUED
                })
            }, this.addProgressListener = function(e, t) {
                r.push({
                    callback: e,
                    tags: new i(t)
                })
            }, this.addCompletionListener = function(e, t) {
                r.push({
                    tags: new i(t),
                    callback: function(t) {
                        t.completedCount === t.totalCount && e(t)
                    }
                })
            };
            var l = function(e) {
                e = s(e);
                var t = function(t) {
                    for (var i = t.resource, r = 1 / 0, n = 0; n < i.tags.length; n++)
                        for (var o = 0; o < Math.min(e.length, r) && !(i.tags.all[n] === e[o] && r > o && (r = o, 0 === r)) && 0 !== r; o++);
                    return r
                };
                return function(e, i) {
                    var r = t(e),
                        n = t(i);
                    return n > r ? -1 : r > n ? 1 : e.priority < i.priority ? -1 : e.priority > i.priority ? 1 : 0
                }
            };
            this.start = function(e) {
                n = Date.now();
                var i = l(e);
                t.sort(i);
                for (var r = 0, o = t.length; o > r; r++) {
                    var s = t[r];
                    s.status = a.WAITING, s.resource.start(this)
                }
                setTimeout(h, 100)
            };
            var h = function() {
                for (var i = !1, r = Date.now() - o, n = r >= e.noProgressTimeout, s = r >= e.loggingDelay, l = 0, u = t.length; u > l; l++) {
                    var c = t[l];
                    c.status === a.WAITING && (c.resource.checkStatus && c.resource.checkStatus(), c.status === a.WAITING && (n ? c.resource.onTimeout() : i = !0))
                }
                s && i && p(), i && setTimeout(h, e.statusInterval)
            };
            this.isBusy = function() {
                for (var e = 0, i = t.length; i > e; e++)
                    if (t[e].status === a.QUEUED || t[e].status === a.WAITING) return !0;
                return !1
            };
            var u = function(e, i) {
                var n = null,
                    s, l, h, u, p;
                for (s = 0, l = t.length; l > s; s++)
                    if (t[s].resource === e) {
                        n = t[s];
                        break
                    }
                if (null != n && n.status === a.WAITING)
                    for (n.status = i, o = Date.now(), h = e.tags.length, s = 0, l = r.length; l > s; s++) u = r[s], p = 0 === u.tags.length ? !0 : e.tags.intersects(u.tags), p && c(n, u)
            };
            this.onLoad = function(e) {
                u(e, a.LOADED)
            }, this.onError = function(e) {
                u(e, a.ERROR)
            }, this.onTimeout = function(e) {
                u(e, a.TIMEOUT)
            };
            var c = function(e, i) {
                    var r = 0,
                        n = 0,
                        o, s, l, h;
                    for (o = 0, s = t.length; s > o; o++) l = t[o], h = !1, h = 0 === i.tags.length ? !0 : l.resource.tags.intersects(i.tags), h && (n++, (l.status === a.LOADED || l.status === a.ERROR || l.status === a.TIMEOUT) && r++);
                    i.callback({
                        resource: e.resource,
                        loaded: e.status === a.LOADED,
                        error: e.status === a.ERROR,
                        timeout: e.status === a.TIMEOUT,
                        completedCount: r,
                        totalCount: n
                    })
                },
                p = this.log = function(e) {
                    if (window.console) {
                        var i = Math.round((Date.now() - n) / 1e3);
                        window.console.log("PxLoader elapsed: " + i + " sec");
                        for (var r = 0, o = t.length; o > r; r++) {
                            var s = t[r];
                            if (e || s.status === a.WAITING) {
                                var l = "PxLoader: #" + r + " " + s.resource.getName();
                                switch (s.status) {
                                    case a.QUEUED:
                                        l += " (Not Started)";
                                        break;
                                    case a.WAITING:
                                        l += " (Waiting)";
                                        break;
                                    case a.LOADED:
                                        l += " (Loaded)";
                                        break;
                                    case a.ERROR:
                                        l += " (Error)";
                                        break;
                                    case a.TIMEOUT:
                                        l += " (Timeout)"
                                }
                                s.resource.tags.length > 0 && (l += " Tags: [" + s.resource.tags.all.join(",") + "]"), window.console.log(l)
                            }
                        }
                    }
                }
        }

        function i(e) {
            if (this.all = [], this.first = null, this.length = 0, this.lookup = {}, e) {
                if (Array.isArray(e)) this.all = e.slice(0);
                else if ("object" == typeof e)
                    for (var t in e) e.hasOwnProperty(t) && this.all.push(t);
                else this.all.push(e);
                this.length = this.all.length, this.length > 0 && (this.first = this.all[0]);
                for (var i = 0; i < this.length; i++) this.lookup[this.all[i]] = !0
            }
        }
        i.prototype.intersects = function(e) {
            if (0 === this.length || 0 === e.length) return !1;
            if (1 === this.length && 1 === e.length) return this.first === e.first;
            if (e.length < this.length) return e.intersects(this);
            for (var t in this.lookup)
                if (e.lookup[t]) return !0;
            return !1
        }, "function" == typeof define && define.amd && define("PxLoader", [], function() {
            return t
        }), e.PxLoader = t
    }(this), Date.now || (Date.now = function e() {
        return (new Date).getTime()
    }), Array.isArray || (Array.isArray = function(e) {
        return "[object Array]" === Object.prototype.toString.call(e)
    }), PxLoader.prototype.addTexture = function(e, t, i) {
        var r = new PxLoaderTexture(e, t, i);
        return this.add(r), r
    }, "function" == typeof define && define.amd && define("PxLoaderGeom", [], function() {
        return PxLoaderGeom
    });
var ImprovedNoise = function() {
    function e(e) {
        return e * e * e * (e * (6 * e - 15) + 10)
    }

    function t(e, t, i) {
        return t + e * (i - t)
    }

    function i(e, t, i, r) {
        var n = 15 & e,
            o = 8 > n ? t : i,
            a = 4 > n ? i : 12 == n || 14 == n ? t : r;
        return (0 == (1 & n) ? o : -o) + (0 == (2 & n) ? a : -a)
    }
    for (var r = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180], n = 0; 256 > n; n++) r[256 + n] = r[n];
    return {
        noise: function(n, o, a) {
            var s = ~~n,
                l = ~~o,
                h = ~~a,
                u = 255 & s,
                c = 255 & l,
                p = 255 & h;
            n -= s, o -= l, a -= h;
            var d = n - 1,
                f = o - 1,
                m = a - 1,
                E = e(n),
                v = e(o),
                g = e(a),
                y = r[u] + c,
                T = r[y] + p,
                x = r[y + 1] + p,
                _ = r[u + 1] + c,
                R = r[_] + p,
                b = r[_ + 1] + p;
            return t(g, t(v, t(E, i(r[T], n, o, a), i(r[R], d, o, a)), t(E, i(r[x], n, f, a), i(r[b], d, f, a))), t(v, t(E, i(r[T + 1], n, o, m), i(r[R + 1], d, o, a - 1)), t(E, i(r[x + 1], n, f, m), i(r[b + 1], d, f, m))))
        }
    }
};
THREE.ShaderExtras = {
        screen: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")
        },
        convolution: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                uImageIncrement: {
                    type: "v2",
                    value: new THREE.Vector2(.001953125, 0)
                },
                cKernel: {
                    type: "fv1",
                    value: []
                }
            },
            vertexShader: ["uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "vUv = uv - ( ( KERNEL_SIZE - 1.0 ) / 2.0 ) * uImageIncrement;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float cKernel[ KERNEL_SIZE ];", "uniform sampler2D tDiffuse;", "uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "vec2 imageCoord = vUv;", "vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );", "for( int i = 0; i < KERNEL_SIZE; i ++ ) {", "sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];", "imageCoord += uImageIncrement;", "}", "gl_FragColor = sum;", "}"].join("\n")
        },
        film: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                time: {
                    type: "f",
                    value: 0
                },
                nIntensity: {
                    type: "f",
                    value: .5
                },
                sIntensity: {
                    type: "f",
                    value: .05
                },
                sCount: {
                    type: "f",
                    value: 4096
                },
                grayscale: {
                    type: "i",
                    value: 1
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float time;", "uniform bool grayscale;", "uniform float nIntensity;", "uniform float sIntensity;", "uniform float sCount;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 cTextureScreen = texture2D( tDiffuse, vUv );", "float x = vUv.x * vUv.y * time *  1000.0;", "x = mod( x, 13.0 ) * mod( x, 123.0 );", "float dx = mod( x, 0.01 );", "vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx * 100.0, 0.0, 1.0 );", "vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );", "cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;", "cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );", "if( grayscale ) {", "cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );", "}", "gl_FragColor =  vec4( cResult, cTextureScreen.a );", "}"].join("\n")
        },
        bokeh: {
            uniforms: {
                tColor: {
                    type: "t",
                    value: null
                },
                tDepth: {
                    type: "t",
                    value: null
                },
                focus: {
                    type: "f",
                    value: 1
                },
                aspect: {
                    type: "f",
                    value: 1
                },
                aperture: {
                    type: "f",
                    value: .025
                },
                maxblur: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["varying vec2 vUv;", "uniform sampler2D tColor;", "uniform sampler2D tDepth;", "uniform float maxblur;", "uniform float aperture;", "uniform float focus;", "uniform float aspect;", "void main() {", "vec2 aspectcorrect = vec2( 1.0, aspect );", "vec4 depth1 = texture2D( tDepth, vUv );", "float factor = depth1.x - focus;", "vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );", "vec2 dofblur9 = dofblur * 0.9;", "vec2 dofblur7 = dofblur * 0.7;", "vec2 dofblur4 = dofblur * 0.4;", "vec4 col = vec4( 0.0 );", "col += texture2D( tColor, vUv.xy );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );", "gl_FragColor = col / 41.0;", "gl_FragColor.a = 1.0;", "}"].join("\n")
        },
        dofmipmap: {
            uniforms: {
                tColor: {
                    type: "t",
                    value: null
                },
                tDepth: {
                    type: "t",
                    value: null
                },
                focus: {
                    type: "f",
                    value: 1
                },
                maxblur: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float focus;", "uniform float maxblur;", "uniform sampler2D tColor;", "uniform sampler2D tDepth;", "varying vec2 vUv;", "void main() {", "vec4 depth = texture2D( tDepth, vUv );", "float factor = depth.x - focus;", "vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );", "gl_FragColor = col;", "gl_FragColor.a = 1.0;", "}"].join("\n")
        },
        sepia: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                amount: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float amount;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 color = texture2D( tDiffuse, vUv );", "vec3 c = color.rgb;", "color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );", "color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );", "color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );", "gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );", "}"].join("\n")
        },
        dotscreen: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                tSize: {
                    type: "v2",
                    value: new THREE.Vector2(256, 256)
                },
                center: {
                    type: "v2",
                    value: new THREE.Vector2(.5, .5)
                },
                angle: {
                    type: "f",
                    value: 1.57
                },
                scale: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform vec2 center;", "uniform float angle;", "uniform float scale;", "uniform vec2 tSize;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "float pattern() {", "float s = sin( angle ), c = cos( angle );", "vec2 tex = vUv * tSize - center;", "vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;", "return ( sin( point.x ) * sin( point.y ) ) * 4.0;", "}", "void main() {", "vec4 color = texture2D( tDiffuse, vUv );", "float average = ( color.r + color.g + color.b ) / 3.0;", "gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );", "}"].join("\n")
        },
        vignette: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                offset: {
                    type: "f",
                    value: 1
                },
                darkness: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float offset;", "uniform float darkness;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );", "gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );", "}"].join("\n")
        },
        bleachbypass: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 base = texture2D( tDiffuse, vUv );", "vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );", "float lum = dot( lumCoeff, base.rgb );", "vec3 blend = vec3( lum );", "float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );", "vec3 result1 = 2.0 * base.rgb * blend;", "vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );", "vec3 newColor = mix( result1, result2, L );", "float A2 = opacity * base.a;", "vec3 mixRGB = A2 * newColor.rgb;", "mixRGB += ( ( 1.0 - A2 ) * base.rgb );", "gl_FragColor = vec4( mixRGB, base.a );", "}"].join("\n")
        },
        focus: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                screenWidth: {
                    type: "f",
                    value: 1024
                },
                screenHeight: {
                    type: "f",
                    value: 1024
                },
                sampleDistance: {
                    type: "f",
                    value: .94
                },
                waveFactor: {
                    type: "f",
                    value: .00125
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float screenWidth;", "uniform float screenHeight;", "uniform float sampleDistance;", "uniform float waveFactor;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 color, org, tmp, add;", "float sample_dist, f;", "vec2 vin;", "vec2 uv = vUv;", "add = color = org = texture2D( tDiffuse, uv );", "vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );", "sample_dist = dot( vin, vin ) * 2.0;", "f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;", "vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );", "add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );", "color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );", "gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );", "}"].join("\n")
        },
        triangleBlur: {
            uniforms: {
                texture: {
                    type: "t",
                    value: null
                },
                delta: {
                    type: "v2",
                    value: new THREE.Vector2(1, 1)
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["#define ITERATIONS 10.0", "uniform sampler2D texture;", "uniform vec2 delta;", "varying vec2 vUv;", "float random( vec3 scale, float seed ) {", "return fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed );", "}", "void main() {", "vec4 color = vec4( 0.0 );", "float total = 0.0;", "float offset = random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );", "for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {", "float percent = ( t + offset - 0.5 ) / ITERATIONS;", "float weight = 1.0 - abs( percent );", "color += texture2D( texture, vUv + delta * percent ) * weight;", "total += weight;", "}", "gl_FragColor = color / total;", "}"].join("\n")
        },
        basic: {
            uniforms: {},
            vertexShader: ["void main() {", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["void main() {", "gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );", "}"].join("\n")
        },
        horizontalBlur: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                h: {
                    type: "f",
                    value: 1 / 512
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float h;", "varying vec2 vUv;", "void main() {", "vec4 sum = vec4( 0.0 );", "sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;", "sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, 		  	vUv.y ) ) * 0.1633;", "sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;", "gl_FragColor = sum;", "}"].join("\n")
        },
        verticalBlur: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                v: {
                    type: "f",
                    value: 1 / 512
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float v;", "varying vec2 vUv;", "void main() {", "vec4 sum = vec4( 0.0 );", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y			  ) ) * 0.1633;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;", "gl_FragColor = sum;", "}"].join("\n")
        },
        horizontalTiltShift: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                h: {
                    type: "f",
                    value: 1 / 512
                },
                r: {
                    type: "f",
                    value: .35
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float h;", "uniform float r;", "varying vec2 vUv;", "void main() {", "vec4 sum = vec4( 0.0 );", "float hh = h * abs( r - vUv.y );", "sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;", "sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, 		  	 vUv.y ) ) * 0.1633;", "sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;", "gl_FragColor = sum;", "}"].join("\n")
        },
        verticalTiltShift: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                v: {
                    type: "f",
                    value: 1 / 512
                },
                r: {
                    type: "f",
                    value: .35
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float v;", "uniform float r;", "varying vec2 vUv;", "void main() {", "vec4 sum = vec4( 0.0 );", "float vv = v * abs( r - vUv.y );", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y			   ) ) * 0.1633;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;", "gl_FragColor = sum;", "}"].join("\n")
        },
        blend: {
            uniforms: {
                tDiffuse1: {
                    type: "t",
                    value: null
                },
                tDiffuse2: {
                    type: "t",
                    value: null
                },
                mixRatio: {
                    type: "f",
                    value: .5
                },
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float opacity;", "uniform float mixRatio;", "uniform sampler2D tDiffuse1;", "uniform sampler2D tDiffuse2;", "varying vec2 vUv;", "void main() {", "vec4 texel1 = texture2D( tDiffuse1, vUv );", "vec4 texel2 = texture2D( tDiffuse2, vUv );", "gl_FragColor = opacity * mix( texel1, texel2, mixRatio );", "}"].join("\n")
        },
        fxaa: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                resolution: {
                    type: "v2",
                    value: new THREE.Vector2(1 / 1024, 1 / 512)
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "varying vec2 vUv;", "#define FXAA_REDUCE_MIN   (1.0/128.0)", "#define FXAA_REDUCE_MUL   (1.0/8.0)", "#define FXAA_SPAN_MAX     8.0", "void main() {", "vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;", "vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;", "vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;", "vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;", "vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );", "vec3 rgbM  = rgbaM.xyz;", "float opacity  = rgbaM.w;", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float lumaNW = dot( rgbNW, luma );", "float lumaNE = dot( rgbNE, luma );", "float lumaSW = dot( rgbSW, luma );", "float lumaSE = dot( rgbSE, luma );", "float lumaM  = dot( rgbM,  luma );", "float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );", "float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );", "vec2 dir;", "dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));", "dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));", "float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );", "float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );", "dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),", "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),", "dir * rcpDirMin)) * resolution;", "vec3 rgbA = 0.5 * (", "texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz +", "texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz );", "vec3 rgbB = rgbA * 0.5 + 0.25 * (", "texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz +", "texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz );", "float lumaB = dot( rgbB, luma );", "if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {", "gl_FragColor = vec4( rgbA, opacity );", "} else {", "gl_FragColor = vec4( rgbB, opacity );", "}", "}"].join("\n")
        },
        luminosity: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float v = dot( texel.xyz, luma );", "gl_FragColor = vec4( v, v, v, texel.w );", "}"].join("\n")
        },
        colorCorrection: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                powRGB: {
                    type: "v3",
                    value: new THREE.Vector3(2, 2, 2)
                },
                mulRGB: {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec3 powRGB;", "uniform vec3 mulRGB;", "varying vec2 vUv;", "void main() {", "gl_FragColor = texture2D( tDiffuse, vUv );", "gl_FragColor.rgb = mulRGB * pow( gl_FragColor.rgb, powRGB );", "}"].join("\n")
        },
        normalmap: {
            uniforms: {
                heightMap: {
                    type: "t",
                    value: null
                },
                resolution: {
                    type: "v2",
                    value: new THREE.Vector2(512, 512)
                },
                scale: {
                    type: "v2",
                    value: new THREE.Vector2(1, 1)
                },
                height: {
                    type: "f",
                    value: .05
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float height;", "uniform vec2 resolution;", "uniform sampler2D heightMap;", "varying vec2 vUv;", "void main() {", "float val = texture2D( heightMap, vUv ).x;", "float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;", "float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;", "gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );", "}"].join("\n")
        },
        ssao: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                tDepth: {
                    type: "t",
                    value: null
                },
                size: {
                    type: "v2",
                    value: new THREE.Vector2(512, 512)
                },
                cameraNear: {
                    type: "f",
                    value: 1
                },
                cameraFar: {
                    type: "f",
                    value: 100
                },
                fogNear: {
                    type: "f",
                    value: 5
                },
                fogFar: {
                    type: "f",
                    value: 100
                },
                fogEnabled: {
                    type: "i",
                    value: 0
                },
                onlyAO: {
                    type: "i",
                    value: 0
                },
                aoClamp: {
                    type: "f",
                    value: .3
                },
                lumInfluence: {
                    type: "f",
                    value: .9
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float cameraNear;", "uniform float cameraFar;", "uniform float fogNear;", "uniform float fogFar;", "uniform bool fogEnabled;", "uniform bool onlyAO;", "uniform vec2 size;", "uniform float aoClamp;", "uniform float lumInfluence;", "uniform sampler2D tDiffuse;", "uniform sampler2D tDepth;", "varying vec2 vUv;", "#define DL 2.399963229728653", "#define EULER 2.718281828459045", "float width = size.x;", "float height = size.y;", "float cameraFarPlusNear = cameraFar + cameraNear;", "float cameraFarMinusNear = cameraFar - cameraNear;", "float cameraCoef = 2.0 * cameraNear;", "const int samples = 8;", "const float radius = 5.0;", "const bool useNoise = false;", "const float noiseAmount = 0.0003;", "const float diffArea = 0.4;", "const float gDisplace = 0.4;", "const vec3 onlyAOColor = vec3( 1.0, 0.7, 0.5 );", "float unpackDepth( const in vec4 rgba_depth ) {", "const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );", "float depth = dot( rgba_depth, bit_shift );", "return depth;", "}", "vec2 rand( const vec2 coord ) {", "vec2 noise;", "if ( useNoise ) {", "float nx = dot ( coord, vec2( 12.9898, 78.233 ) );", "float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );", "noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );", "} else {", "float ff = fract( 1.0 - coord.s * ( width / 2.0 ) );", "float gg = fract( coord.t * ( height / 2.0 ) );", "noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;", "}", "return ( noise * 2.0  - 1.0 ) * noiseAmount;", "}", "float doFog() {", "float zdepth = unpackDepth( texture2D( tDepth, vUv ) );", "float depth = -cameraFar * cameraNear / ( zdepth * cameraFarMinusNear - cameraFar );", "return smoothstep( fogNear, fogFar, depth );", "}", "float readDepth( const in vec2 coord ) {", "return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );", "}", "float compareDepths( const in float depth1, const in float depth2, inout int far ) {", "float garea = 2.0;", "float diff = ( depth1 - depth2 ) * 100.0;", "if ( diff < gDisplace ) {", "garea = diffArea;", "} else {", "far = 1;", "}", "float dd = diff - gDisplace;", "float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );", "return gauss;", "}", "float calcAO( float depth, float dw, float dh ) {", "float dd = radius - depth * radius;", "vec2 vv = vec2( dw, dh );", "vec2 coord1 = vUv + dd * vv;", "vec2 coord2 = vUv - dd * vv;", "float temp1 = 0.0;", "float temp2 = 0.0;", "int far = 0;", "temp1 = compareDepths( depth, readDepth( coord1 ), far );", "if ( far > 0 ) {", "temp2 = compareDepths( readDepth( coord2 ), depth, far );", "temp1 += ( 1.0 - temp1 ) * temp2;", "}", "return temp1;", "}", "void main() {", "vec2 noise = rand( vUv );", "float depth = readDepth( vUv );", "float tt = clamp( depth, aoClamp, 1.0 );", "float w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );", "float h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );", "float pw;", "float ph;", "float ao;", "float dz = 1.0 / float( samples );", "float z = 1.0 - dz / 2.0;", "float l = 0.0;", "for ( int i = 0; i <= samples; i ++ ) {", "float r = sqrt( 1.0 - z );", "pw = cos( l ) * r;", "ph = sin( l ) * r;", "ao += calcAO( depth, pw * w, ph * h );", "z = z - dz;", "l = l + DL;", "}", "ao /= float( samples );", "ao = 1.0 - ao;", "if ( fogEnabled ) {", "ao = mix( ao, 1.0, doFog() );", "}", "vec3 color = texture2D( tDiffuse, vUv ).rgb;", "vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );", "float lum = dot( color.rgb, lumcoeff );", "vec3 luminance = vec3( lum );", "vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );", "if ( onlyAO ) {", "final = onlyAOColor * vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );", "}", "gl_FragColor = vec4( final, 1.0 );", "}"].join("\n")
        },
        colorify: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                color: {
                    type: "c",
                    value: new THREE.Color(16777215)
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform vec3 color;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float v = dot( texel.xyz, luma );", "gl_FragColor = vec4( v * color, texel.w );", "}"].join("\n")
        },
        unpackDepthRGBA: {
            uniforms: {
                tDiffuse: {
                    type: "t",
                    value: null
                },
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "float unpackDepth( const in vec4 rgba_depth ) {", "const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );", "float depth = dot( rgba_depth, bit_shift );", "return depth;", "}", "void main() {", "float depth = 1.0 - unpackDepth( texture2D( tDiffuse, vUv ) );", "gl_FragColor = opacity * vec4( vec3( depth ), 1.0 );", "}"].join("\n")
        },
        buildKernel: function(e) {
            function t(e, t) {
                return Math.exp(-(e * e) / (2 * t * t))
            }
            var i, r, n, o, a = 25,
                s = 2 * Math.ceil(3 * e) + 1;
            for (s > a && (s = a), o = .5 * (s - 1), r = new Array(s), n = 0, i = 0; s > i; ++i) r[i] = t(i - o, e), n += r[i];
            for (i = 0; s > i; ++i) r[i] /= n;
            return r
        }
    }, THREE.SphereGeometry = function(e, t, i, r, n, o, a) {
        THREE.Geometry.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: r,
            phiLength: n,
            thetaStart: o,
            thetaLength: a
        }, e = e || 50, t = Math.max(3, Math.floor(t) || 8), i = Math.max(2, Math.floor(i) || 6), r = void 0 !== r ? r : 0, n = void 0 !== n ? n : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
        var s, l, h = [],
            u = [];
        for (l = 0; i >= l; l++) {
            var c = [],
                p = [];
            for (s = 0; t >= s; s++) {
                var d = s / t,
                    f = l / i,
                    m = new THREE.Vector3;
                m.x = -e * Math.cos(r + d * n) * Math.sin(o + f * a), m.y = e * Math.cos(o + f * a), m.z = e * Math.sin(r + d * n) * Math.sin(o + f * a), this.vertices.push(m), c.push(1 === d ? this.vertices.length - 1 - t : this.vertices.length - 1), p.push(new THREE.Vector2(d, 1 - f))
            }
            h.push(c), u.push(p)
        }
        for (l = 0; i > l; l++)
            for (s = 0; t > s; s++) {
                var E = h[l][s + 1],
                    v = h[l][s],
                    g = h[l + 1][s],
                    y = h[l + 1][s + 1],
                    T = this.vertices[E].clone().normalize(),
                    x = this.vertices[v].clone().normalize(),
                    _ = this.vertices[g].clone().normalize(),
                    R = this.vertices[y].clone().normalize(),
                    b = u[l][s + 1].clone(),
                    H = u[l][s].clone(),
                    w = u[l + 1][s].clone(),
                    M = u[l + 1][s + 1].clone();
                Math.abs(this.vertices[E].y) === e ? (b.x = (b.x + H.x) / 2, this.faces.push(new THREE.Face3(E, g, y, [T, _, R])), this.faceVertexUvs[0].push([b, w, M])) : Math.abs(this.vertices[g].y) === e ? (w.x = (w.x + M.x) / 2, this.faces.push(new THREE.Face3(E, v, g, [T, x, _])), this.faceVertexUvs[0].push([b, H, w])) : (this.faces.push(new THREE.Face3(E, v, y, [T, x, R])), this.faceVertexUvs[0].push([b, H, M]), this.faces.push(new THREE.Face3(v, g, y, [x.clone(), _, R.clone()])), this.faceVertexUvs[0].push([H.clone(), w, M.clone()]))
            }
        this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, e)
    }, THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry,
    function(e, t) {
        function i(i, r) {
            function n(e) {
                return s.preferFlash && wt && !s.ignoreFlash && s.flash[e] !== t && s.flash[e]
            }

            function o(e) {
                return function(t) {
                    var i = this._s;
                    return i && i._a ? e.call(this, t) : null
                }
            }
            this.setupOptions = {
                url: i || null,
                flashVersion: 8,
                debugMode: !0,
                debugFlash: !1,
                useConsole: !0,
                consoleOnly: !0,
                waitForWindowLoad: !1,
                bgColor: "#ffffff",
                useHighPerformance: !1,
                flashPollingInterval: null,
                html5PollingInterval: null,
                flashLoadTimeout: 1e3,
                wmode: null,
                allowScriptAccess: "always",
                useFlashBlock: !1,
                useHTML5Audio: !0,
                html5Test: /^(probably|maybe)$/i,
                preferFlash: !1,
                noSWFCache: !1,
                idPrefix: "sound"
            }, this.defaultOptions = {
                autoLoad: !1,
                autoPlay: !1,
                from: null,
                loops: 1,
                onid3: null,
                onload: null,
                whileloading: null,
                onplay: null,
                onpause: null,
                onresume: null,
                whileplaying: null,
                onposition: null,
                onstop: null,
                onfailure: null,
                onfinish: null,
                multiShot: !0,
                multiShotEvents: !1,
                position: null,
                pan: 0,
                stream: !0,
                to: null,
                type: null,
                usePolicyFile: !1,
                volume: 100
            }, this.flash9Options = {
                isMovieStar: null,
                usePeakData: !1,
                useWaveformData: !1,
                useEQData: !1,
                onbufferchange: null,
                ondataerror: null
            }, this.movieStarOptions = {
                bufferTime: 3,
                serverURL: null,
                onconnect: null,
                duration: null
            }, this.audioFormats = {
                mp3: {
                    type: ['audio/mpeg; codecs="mp3"', "audio/mpeg", "audio/mp3", "audio/MPA", "audio/mpa-robust"],
                    required: !0
                },
                mp4: {
                    related: ["aac", "m4a", "m4b"],
                    type: ['audio/mp4; codecs="mp4a.40.2"', "audio/aac", "audio/x-m4a", "audio/MP4A-LATM", "audio/mpeg4-generic"],
                    required: !1
                },
                ogg: {
                    type: ["audio/ogg; codecs=vorbis"],
                    required: !1
                },
                opus: {
                    type: ["audio/ogg; codecs=opus", "audio/opus"],
                    required: !1
                },
                wav: {
                    type: ['audio/wav; codecs="1"', "audio/wav", "audio/wave", "audio/x-wav"],
                    required: !1
                }
            }, this.movieID = "sm2-container", this.id = r || "sm2movie", this.debugID = "soundmanager-debug", this.debugURLParam = /([#?&])debug=1/i, this.versionNumber = "V2.97a.20131201", this.altURL = this.movieURL = this.version = null, this.enabled = this.swfLoaded = !1, this.oMC = null, this.sounds = {}, this.soundIDs = [], this.didFlashBlock = this.muted = !1, this.filePattern = null, this.filePatterns = {
                flash8: /\.mp3(\?.*)?$/i,
                flash9: /\.mp3(\?.*)?$/i
            }, this.features = {
                buffering: !1,
                peakData: !1,
                waveformData: !1,
                eqData: !1,
                movieStar: !1
            }, this.sandbox = {}, this.html5 = {
                usingFlash: null
            }, this.flash = {}, this.ignoreFlash = this.html5Only = !1;
            var a, s = this,
                l = null,
                h = null,
                u, c = navigator.userAgent,
                p = e.location.href.toString(),
                d = document,
                f, m, E, v, g = [],
                y = !1,
                T = !1,
                x = !1,
                _ = !1,
                R = !1,
                b, H, w, M, S, C, A, P, L, D, O, F, k, U, N, B, z, V, I, $, j, G, W, X, q, Y, Q = null,
                K = null,
                Z, J, et, tt, it, rt, nt = !1,
                ot = !1,
                at, st, lt, ht = 0,
                ut = null,
                ct, pt = [],
                dt, ft = null,
                mt, Et, vt, gt, yt, Tt, xt, _t, Rt = Array.prototype.slice,
                bt = !1,
                Ht, wt, Mt, St, Ct, At, Pt = 0,
                Lt = c.match(/(ipad|iphone|ipod)/i),
                Dt = c.match(/android/i),
                Ot = c.match(/msie/i),
                Ft = c.match(/webkit/i),
                kt = c.match(/safari/i) && !c.match(/chrome/i),
                Ut = c.match(/opera/i),
                Nt = c.match(/(mobile|pre\/|xoom)/i) || Lt || Dt,
                Bt = !p.match(/usehtml5audio/i) && !p.match(/sm2\-ignorebadua/i) && kt && !c.match(/silk/i) && c.match(/OS X 10_6_([3-7])/i),
                zt = d.hasFocus !== t ? d.hasFocus() : null,
                Vt = kt && (d.hasFocus === t || !d.hasFocus()),
                It = !Vt,
                jt = /(mp3|mp4|mpa|m4a|m4b)/i,
                Gt = d.location ? d.location.protocol.match(/http/i) : null,
                Wt = Gt ? "" : "http://",
                Xt = /^\s*audio\/(?:x-)?(?:mpeg4|aac|flv|mov|mp4||m4v|m4a|m4b|mp4v|3gp|3g2)\s*(?:$|;)/i,
                qt = "mpeg4 aac flv mov mp4 m4v f4v m4a m4b mp4v 3gp 3g2".split(" "),
                Yt = RegExp("\\.(" + qt.join("|") + ")(\\?.*)?$", "i");
            this.mimePattern = /^\s*audio\/(?:x-)?(?:mp(?:eg|3))\s*(?:$|;)/i, this.useAltURL = !Gt;
            var Qt;
            try {
                Qt = Audio !== t && (Ut && opera !== t && 10 > opera.version() ? new Audio(null) : new Audio).canPlayType !== t
            } catch (Kt) {
                Qt = !1
            }
            this.hasHTML5 = Qt, this.setup = function(e) {
                var i = !s.url;
                return e !== t && x && ft && s.ok(), w(e), e && (i && V && e.url !== t && s.beginDelayedInit(), !V && e.url !== t && "complete" === d.readyState && setTimeout(B, 1)), s
            }, this.supported = this.ok = function() {
                return ft ? x && !_ : s.useHTML5Audio && s.hasHTML5
            }, this.getMovie = function(t) {
                return u(t) || d[t] || e[t]
            }, this.createSound = function(e, i) {
                function r() {
                    return n = tt(n), s.sounds[n.id] = new a(n), s.soundIDs.push(n.id), s.sounds[n.id]
                }
                var n, o = null;
                if (!x || !s.ok()) return !1;
                if (i !== t && (e = {
                        id: e,
                        url: i
                    }), n = H(e), n.url = ct(n.url), void 0 === n.id && (n.id = s.setupOptions.idPrefix + Pt++), rt(n.id, !0)) return s.sounds[n.id];
                if (Et(n)) o = r(), o._setup_html5(n);
                else {
                    if (s.html5Only || s.html5.usingFlash && n.url && n.url.match(/data\:/i)) return r();
                    v > 8 && null === n.isMovieStar && (n.isMovieStar = !(!n.serverURL && !(n.type && n.type.match(Xt) || n.url && n.url.match(Yt)))), n = it(n, void 0), o = r(), 8 === v ? h._createSound(n.id, n.loops || 1, n.usePolicyFile) : (h._createSound(n.id, n.url, n.usePeakData, n.useWaveformData, n.useEQData, n.isMovieStar, n.isMovieStar ? n.bufferTime : !1, n.loops || 1, n.serverURL, n.duration || null, n.autoPlay, !0, n.autoLoad, n.usePolicyFile), n.serverURL || (o.connected = !0, n.onconnect && n.onconnect.apply(o))), !n.serverURL && (n.autoLoad || n.autoPlay) && o.load(n)
                }
                return !n.serverURL && n.autoPlay && o.play(), o
            }, this.destroySound = function(e, t) {
                if (!rt(e)) return !1;
                var i = s.sounds[e],
                    r;
                for (i._iO = {}, i.stop(), i.unload(), r = 0; r < s.soundIDs.length; r++)
                    if (s.soundIDs[r] === e) {
                        s.soundIDs.splice(r, 1);
                        break
                    }
                return t || i.destruct(!0), delete s.sounds[e], !0
            }, this.load = function(e, t) {
                return rt(e) ? s.sounds[e].load(t) : !1
            }, this.unload = function(e) {
                return rt(e) ? s.sounds[e].unload() : !1
            }, this.onposition = this.onPosition = function(e, t, i, r) {
                return rt(e) ? s.sounds[e].onposition(t, i, r) : !1
            }, this.clearOnPosition = function(e, t, i) {
                return rt(e) ? s.sounds[e].clearOnPosition(t, i) : !1
            }, this.start = this.play = function(e, t) {
                var i = null,
                    r = t && !(t instanceof Object);
                if (!x || !s.ok()) return !1;
                if (rt(e, r)) r && (t = {
                    url: t
                });
                else {
                    if (!r) return !1;
                    r && (t = {
                        url: t
                    }), t && t.url && (t.id = e, i = s.createSound(t).play())
                }
                return null === i && (i = s.sounds[e].play(t)), i
            }, this.setPosition = function(e, t) {
                return rt(e) ? s.sounds[e].setPosition(t) : !1
            }, this.stop = function(e) {
                return rt(e) ? s.sounds[e].stop() : !1
            }, this.stopAll = function() {
                for (var e in s.sounds) s.sounds.hasOwnProperty(e) && s.sounds[e].stop()
            }, this.pause = function(e) {
                return rt(e) ? s.sounds[e].pause() : !1
            }, this.pauseAll = function() {
                var e;
                for (e = s.soundIDs.length - 1; e >= 0; e--) s.sounds[s.soundIDs[e]].pause()
            }, this.resume = function(e) {
                return rt(e) ? s.sounds[e].resume() : !1
            }, this.resumeAll = function() {
                var e;
                for (e = s.soundIDs.length - 1; e >= 0; e--) s.sounds[s.soundIDs[e]].resume()
            }, this.togglePause = function(e) {
                return rt(e) ? s.sounds[e].togglePause() : !1
            }, this.setPan = function(e, t) {
                return rt(e) ? s.sounds[e].setPan(t) : !1
            }, this.setVolume = function(e, t) {
                return rt(e) ? s.sounds[e].setVolume(t) : !1
            }, this.mute = function(e) {
                var t = 0;
                if (e instanceof String && (e = null), e) return rt(e) ? s.sounds[e].mute() : !1;
                for (t = s.soundIDs.length - 1; t >= 0; t--) s.sounds[s.soundIDs[t]].mute();
                return s.muted = !0
            }, this.muteAll = function() {
                s.mute()
            }, this.unmute = function(e) {
                if (e instanceof String && (e = null), e) return rt(e) ? s.sounds[e].unmute() : !1;
                for (e = s.soundIDs.length - 1; e >= 0; e--) s.sounds[s.soundIDs[e]].unmute();
                return s.muted = !1, !0
            }, this.unmuteAll = function() {
                s.unmute()
            }, this.toggleMute = function(e) {
                return rt(e) ? s.sounds[e].toggleMute() : !1
            }, this.getMemoryUse = function() {
                var e = 0;
                return h && 8 !== v && (e = parseInt(h._getMemoryUse(), 10)), e
            }, this.disable = function(i) {
                var r;
                if (i === t && (i = !1), _) return !1;
                for (_ = !0, r = s.soundIDs.length - 1; r >= 0; r--) X(s.sounds[s.soundIDs[r]]);
                return b(i), _t.remove(e, "load", A), !0
            }, this.canPlayMIME = function(e) {
                var t;
                return s.hasHTML5 && (t = vt({
                    type: e
                })), !t && ft && (t = e && s.ok() ? !!(v > 8 && e.match(Xt) || e.match(s.mimePattern)) : null), t
            }, this.canPlayURL = function(e) {
                var t;
                return s.hasHTML5 && (t = vt({
                    url: e
                })), !t && ft && (t = e && s.ok() ? !!e.match(s.filePattern) : null), t
            }, this.canPlayLink = function(e) {
                return e.type !== t && e.type && s.canPlayMIME(e.type) ? !0 : s.canPlayURL(e.href)
            }, this.getSoundById = function(e, t) {
                return e ? s.sounds[e] : null
            }, this.onready = function(t, i) {
                if ("function" != typeof t) throw Z("needFunction", "onready");
                return i || (i = e), S("onready", t, i), C(), !0
            }, this.ontimeout = function(t, i) {
                if ("function" != typeof t) throw Z("needFunction", "ontimeout");
                return i || (i = e), S("ontimeout", t, i), C({
                    type: "ontimeout"
                }), !0
            }, this._wD = this._writeDebug = function(e, t) {
                return !0
            }, this._debug = function() {}, this.reboot = function(t, i) {
                var r, n, o;
                for (r = s.soundIDs.length - 1; r >= 0; r--) s.sounds[s.soundIDs[r]].destruct();
                if (h) try {
                    Ot && (K = h.innerHTML), Q = h.parentNode.removeChild(h)
                } catch (a) {}
                if (K = Q = ft = h = null, s.enabled = V = x = nt = ot = y = T = _ = bt = s.swfLoaded = !1, s.soundIDs = [], s.sounds = {}, Pt = 0, t) g = [];
                else
                    for (r in g)
                        if (g.hasOwnProperty(r))
                            for (n = 0, o = g[r].length; o > n; n++) g[r][n].fired = !1;
                return s.html5 = {
                    usingFlash: null
                }, s.flash = {}, s.html5Only = !1, s.ignoreFlash = !1, e.setTimeout(function() {
                    N(), i || s.beginDelayedInit()
                }, 20), s
            }, this.reset = function() {
                return s.reboot(!0, !0)
            }, this.getMoviePercent = function() {
                return h && "PercentLoaded" in h ? h.PercentLoaded() : null
            }, this.beginDelayedInit = function() {
                R = !0, B(), setTimeout(function() {
                    return ot ? !1 : ($(), U(), ot = !0)
                }, 20), P()
            }, this.destruct = function() {
                s.disable(!0)
            }, a = function(e) {
                var i, r, n = this,
                    o, a, u, c, p, d, f = !1,
                    m = [],
                    E = 0,
                    g, y, T = null,
                    x;
                r = i = null, this.sID = this.id = e.id, this.url = e.url, this._iO = this.instanceOptions = this.options = H(e), this.pan = this.options.pan, this.volume = this.options.volume, this.isHTML5 = !1, this._a = null, x = this.url ? !1 : !0, this.id3 = {}, this._debug = function() {}, this.load = function(e) {
                    var i = null,
                        r;
                    if (e !== t ? n._iO = H(e, n.options) : (e = n.options, n._iO = e, T && T !== n.url && (n._iO.url = n.url, n.url = null)), n._iO.url || (n._iO.url = n.url), n._iO.url = ct(n._iO.url), r = n.instanceOptions = n._iO, !r.url && !n.url) return n;
                    if (r.url === n.url && 0 !== n.readyState && 2 !== n.readyState) return 3 === n.readyState && r.onload && At(n, function() {
                        r.onload.apply(n, [!!n.duration])
                    }), n;
                    if (n.loaded = !1, n.readyState = 1, n.playState = 0, n.id3 = {}, Et(r)) i = n._setup_html5(r), i._called_load || (n._html5_canplay = !1, n.url !== r.url && (n._a.src = r.url, n.setPosition(0)), n._a.autobuffer = "auto", n._a.preload = "auto", n._a._called_load = !0);
                    else {
                        if (s.html5Only || n._iO.url && n._iO.url.match(/data\:/i)) return n;
                        try {
                            n.isHTML5 = !1, n._iO = it(tt(r)), r = n._iO, 8 === v ? h._load(n.id, r.url, r.stream, r.autoPlay, r.usePolicyFile) : h._load(n.id, r.url, !!r.stream, !!r.autoPlay, r.loops || 1, !!r.autoLoad, r.usePolicyFile)
                        } catch (o) {
                            j({
                                type: "SMSOUND_LOAD_JS_EXCEPTION",
                                fatal: !0
                            })
                        }
                    }
                    return n.url = r.url, n
                }, this.unload = function() {
                    return 0 !== n.readyState && (n.isHTML5 ? (c(), n._a && (n._a.pause(), T = yt(n._a))) : 8 === v ? h._unload(n.id, "about:blank") : h._unload(n.id), o()), n
                }, this.destruct = function(e) {
                    n.isHTML5 ? (c(), n._a && (n._a.pause(), yt(n._a), bt || u(), n._a._s = null, n._a = null)) : (n._iO.onfailure = null, h._destroySound(n.id)), e || s.destroySound(n.id, !0)
                }, this.start = this.play = function(e, i) {
                    var r, o, a, l, u;
                    if (o = !0, o = null, i = i === t ? !0 : i, e || (e = {}), n.url && (n._iO.url = n.url), n._iO = H(n._iO, n.options), n._iO = H(e, n._iO), n._iO.url = ct(n._iO.url), n.instanceOptions = n._iO, !n.isHTML5 && n._iO.serverURL && !n.connected) return n.getAutoPlay() || n.setAutoPlay(!0), n;
                    if (Et(n._iO) && (n._setup_html5(n._iO), p()), 1 === n.playState && !n.paused && (r = n._iO.multiShot, r || (n.isHTML5 && n.setPosition(n._iO.position), o = n)), null !== o) return o;
                    if (e.url && e.url !== n.url && (n.readyState || n.isHTML5 || 8 !== v || !x ? n.load(n._iO) : x = !1), n.loaded || (0 === n.readyState ? (n.isHTML5 || s.html5Only ? n.isHTML5 ? n.load(n._iO) : o = n : (n._iO.autoPlay = !0, n.load(n._iO)), n.instanceOptions = n._iO) : 2 === n.readyState && (o = n)), null !== o) return o;
                    if (!n.isHTML5 && 9 === v && 0 < n.position && n.position === n.duration && (e.position = 0), n.paused && 0 <= n.position && (!n._iO.serverURL || 0 < n.position)) n.resume();
                    else {
                        if (n._iO = H(e, n._iO), null !== n._iO.from && null !== n._iO.to && 0 === n.instanceCount && 0 === n.playState && !n._iO.serverURL) {
                            if (r = function() {
                                    n._iO = H(e, n._iO), n.play(n._iO)
                                }, n.isHTML5 && !n._html5_canplay ? (n.load({
                                    _oncanplay: r
                                }), o = !1) : n.isHTML5 || n.loaded || n.readyState && 2 === n.readyState || (n.load({
                                    onload: r
                                }), o = !1), null !== o) return o;
                            n._iO = y()
                        }(!n.instanceCount || n._iO.multiShotEvents || n.isHTML5 && n._iO.multiShot && !bt || !n.isHTML5 && v > 8 && !n.getAutoPlay()) && n.instanceCount++, n._iO.onposition && 0 === n.playState && d(n), n.playState = 1, n.paused = !1, n.position = n._iO.position === t || isNaN(n._iO.position) ? 0 : n._iO.position, n.isHTML5 || (n._iO = it(tt(n._iO))), n._iO.onplay && i && (n._iO.onplay.apply(n), f = !0), n.setVolume(n._iO.volume, !0), n.setPan(n._iO.pan, !0), n.isHTML5 ? 2 > n.instanceCount ? (p(), o = n._setup_html5(), n.setPosition(n._iO.position), o.play()) : (a = new Audio(n._iO.url), l = function() {
                            _t.remove(a, "ended", l), n._onfinish(n), yt(a), a = null
                        }, u = function() {
                            _t.remove(a, "canplay", u);
                            try {
                                a.currentTime = n._iO.position / 1e3
                            } catch (e) {}
                            a.play()
                        }, _t.add(a, "ended", l), void 0 !== n._iO.volume && (a.volume = Math.max(0, Math.min(1, n._iO.volume / 100))), n.muted && (a.muted = !0), n._iO.position ? _t.add(a, "canplay", u) : a.play()) : (o = h._start(n.id, n._iO.loops || 1, 9 === v ? n.position : n.position / 1e3, n._iO.multiShot || !1), 9 === v && !o && n._iO.onplayerror && n._iO.onplayerror.apply(n))
                    }
                    return n
                }, this.stop = function(e) {
                    var t = n._iO;
                    return 1 === n.playState && (n._onbufferchange(0), n._resetOnPosition(0), n.paused = !1, n.isHTML5 || (n.playState = 0), g(), t.to && n.clearOnPosition(t.to), n.isHTML5 ? n._a && (e = n.position, n.setPosition(0), n.position = e, n._a.pause(), n.playState = 0, n._onTimer(), c()) : (h._stop(n.id, e), t.serverURL && n.unload()), n.instanceCount = 0, n._iO = {}, t.onstop && t.onstop.apply(n)), n
                }, this.setAutoPlay = function(e) {
                    n._iO.autoPlay = e, n.isHTML5 || (h._setAutoPlay(n.id, e), e && !n.instanceCount && 1 === n.readyState && n.instanceCount++)
                }, this.getAutoPlay = function() {
                    return n._iO.autoPlay
                }, this.setPosition = function(e) {
                    e === t && (e = 0);
                    var i = n.isHTML5 ? Math.max(e, 0) : Math.min(n.duration || n._iO.duration, Math.max(e, 0));
                    if (n.position = i, e = n.position / 1e3, n._resetOnPosition(n.position), n._iO.position = i, n.isHTML5) {
                        if (n._a) {
                            if (n._html5_canplay) {
                                if (n._a.currentTime !== e) try {
                                    n._a.currentTime = e, (0 === n.playState || n.paused) && n._a.pause()
                                } catch (r) {}
                            } else if (e) return n;
                            n.paused && n._onTimer(!0)
                        }
                    } else e = 9 === v ? n.position : e, n.readyState && 2 !== n.readyState && h._setPosition(n.id, e, n.paused || !n.playState, n._iO.multiShot);
                    return n
                }, this.pause = function(e) {
                    return n.paused || 0 === n.playState && 1 !== n.readyState ? n : (n.paused = !0, n.isHTML5 ? (n._setup_html5().pause(), c()) : (e || e === t) && h._pause(n.id, n._iO.multiShot), n._iO.onpause && n._iO.onpause.apply(n), n)
                }, this.resume = function() {
                    var e = n._iO;
                    return n.paused ? (n.paused = !1, n.playState = 1, n.isHTML5 ? (n._setup_html5().play(), p()) : (e.isMovieStar && !e.serverURL && n.setPosition(n.position), h._pause(n.id, e.multiShot)), !f && e.onplay ? (e.onplay.apply(n), f = !0) : e.onresume && e.onresume.apply(n), n) : n
                }, this.togglePause = function() {
                    return 0 === n.playState ? (n.play({
                        position: 9 !== v || n.isHTML5 ? n.position / 1e3 : n.position
                    }), n) : (n.paused ? n.resume() : n.pause(), n)
                }, this.setPan = function(e, i) {
                    return e === t && (e = 0), i === t && (i = !1), n.isHTML5 || h._setPan(n.id, e), n._iO.pan = e, i || (n.pan = e, n.options.pan = e), n
                }, this.setVolume = function(e, i) {
                    return e === t && (e = 100), i === t && (i = !1), n.isHTML5 ? n._a && (s.muted && !n.muted && (n.muted = !0, n._a.muted = !0), n._a.volume = Math.max(0, Math.min(1, e / 100))) : h._setVolume(n.id, s.muted && !n.muted || n.muted ? 0 : e), n._iO.volume = e, i || (n.volume = e, n.options.volume = e), n
                }, this.mute = function() {
                    return n.muted = !0, n.isHTML5 ? n._a && (n._a.muted = !0) : h._setVolume(n.id, 0), n
                }, this.unmute = function() {
                    n.muted = !1;
                    var e = n._iO.volume !== t;
                    return n.isHTML5 ? n._a && (n._a.muted = !1) : h._setVolume(n.id, e ? n._iO.volume : n.options.volume), n
                }, this.toggleMute = function() {
                    return n.muted ? n.unmute() : n.mute()
                }, this.onposition = this.onPosition = function(e, i, r) {
                    return m.push({
                        position: parseInt(e, 10),
                        method: i,
                        scope: r !== t ? r : n,
                        fired: !1
                    }), n
                }, this.clearOnPosition = function(e, t) {
                    var i;
                    if (e = parseInt(e, 10), isNaN(e)) return !1;
                    for (i = 0; i < m.length; i++) e !== m[i].position || t && t !== m[i].method || (m[i].fired && E--, m.splice(i, 1))
                }, this._processOnPosition = function() {
                    var e, t;
                    if (e = m.length, !e || !n.playState || E >= e) return !1;
                    for (e -= 1; e >= 0; e--) t = m[e], !t.fired && n.position >= t.position && (t.fired = !0, E++, t.method.apply(t.scope, [t.position]));
                    return !0
                }, this._resetOnPosition = function(e) {
                    var t, i;
                    if (t = m.length, !t) return !1;
                    for (t -= 1; t >= 0; t--) i = m[t], i.fired && e <= i.position && (i.fired = !1, E--);
                    return !0
                }, y = function() {
                    var e = n._iO,
                        t = e.from,
                        i = e.to,
                        r, o;
                    return o = function() {
                        n.clearOnPosition(i, o), n.stop()
                    }, r = function() {
                        null === i || isNaN(i) || n.onPosition(i, o)
                    }, null !== t && !isNaN(t) && (e.position = t, e.multiShot = !1, r()), e
                }, d = function() {
                    var e, t = n._iO.onposition;
                    if (t)
                        for (e in t) t.hasOwnProperty(e) && n.onPosition(parseInt(e, 10), t[e])
                }, g = function() {
                    var e, t = n._iO.onposition;
                    if (t)
                        for (e in t) t.hasOwnProperty(e) && n.clearOnPosition(parseInt(e, 10))
                }, p = function() {
                    n.isHTML5 && at(n)
                }, c = function() {
                    n.isHTML5 && st(n)
                }, o = function(e) {
                    e || (m = [], E = 0), f = !1, n._hasTimer = null, n._a = null, n._html5_canplay = !1, n.bytesLoaded = null, n.bytesTotal = null, n.duration = n._iO && n._iO.duration ? n._iO.duration : null, n.durationEstimate = null, n.buffered = [], n.eqData = [], n.eqData.left = [], n.eqData.right = [], n.failures = 0, n.isBuffering = !1, n.instanceOptions = {}, n.instanceCount = 0, n.loaded = !1, n.metadata = {}, n.readyState = 0, n.muted = !1, n.paused = !1, n.peakData = {
                        left: 0,
                        right: 0
                    }, n.waveformData = {
                        left: [],
                        right: []
                    }, n.playState = 0, n.position = null, n.id3 = {}
                }, o(), this._onTimer = function(e) {
                    var t, o = !1,
                        a = {};
                    return n._hasTimer || e ? (n._a && (e || (0 < n.playState || 1 === n.readyState) && !n.paused) && (t = n._get_html5_duration(), t !== i && (i = t, n.duration = t, o = !0), n.durationEstimate = n.duration, t = 1e3 * n._a.currentTime || 0, t !== r && (r = t, o = !0), (o || e) && n._whileplaying(t, a, a, a, a)), o) : void 0
                }, this._get_html5_duration = function() {
                    var e = n._iO;
                    return (e = n._a && n._a.duration ? 1e3 * n._a.duration : e && e.duration ? e.duration : null) && !isNaN(e) && 1 / 0 !== e ? e : null
                }, this._apply_loop = function(e, t) {
                    e.loop = t > 1 ? "loop" : ""
                }, this._setup_html5 = function(e) {
                    e = H(n._iO, e);
                    var t = bt ? l : n._a,
                        i = decodeURI(e.url),
                        r;
                    if (bt ? i === decodeURI(Ht) && (r = !0) : i === decodeURI(T) && (r = !0), t) {
                        if (t._s)
                            if (bt) t._s && t._s.playState && !r && t._s.stop();
                            else if (!bt && i === decodeURI(T)) return n._apply_loop(t, e.loops), t;
                        r || (T && o(!1), t.src = e.url, Ht = T = n.url = e.url, t._called_load = !1)
                    } else e.autoLoad || e.autoPlay ? (n._a = new Audio(e.url), n._a.load()) : n._a = Ut && 10 > opera.version() ? new Audio(null) : new Audio, t = n._a, t._called_load = !1, bt && (l = t);
                    return n.isHTML5 = !0, n._a = t, t._s = n, a(), n._apply_loop(t, e.loops), e.autoLoad || e.autoPlay ? n.load() : (t.autobuffer = !1, t.preload = "auto"), t
                }, a = function() {
                    if (n._a._added_events) return !1;
                    var e;
                    n._a._added_events = !0;
                    for (e in Ct) Ct.hasOwnProperty(e) && n._a && n._a.addEventListener(e, Ct[e], !1);
                    return !0
                }, u = function() {
                    var e;
                    n._a._added_events = !1;
                    for (e in Ct) Ct.hasOwnProperty(e) && n._a && n._a.removeEventListener(e, Ct[e], !1)
                }, this._onload = function(e) {
                    var t = !!e || !n.isHTML5 && 8 === v && n.duration;
                    return n.loaded = t, n.readyState = t ? 3 : 2, n._onbufferchange(0), n._iO.onload && At(n, function() {
                        n._iO.onload.apply(n, [t])
                    }), !0
                }, this._onbufferchange = function(e) {
                    return 0 === n.playState || e && n.isBuffering || !e && !n.isBuffering ? !1 : (n.isBuffering = 1 === e, n._iO.onbufferchange && n._iO.onbufferchange.apply(n), !0)
                }, this._onsuspend = function() {
                    return n._iO.onsuspend && n._iO.onsuspend.apply(n), !0
                }, this._onfailure = function(e, t, i) {
                    n.failures++, n._iO.onfailure && 1 === n.failures && n._iO.onfailure(n, e, t, i)
                }, this._onfinish = function() {
                    var e = n._iO.onfinish;
                    n._onbufferchange(0), n._resetOnPosition(0), n.instanceCount && (n.instanceCount--, n.instanceCount || (g(), n.playState = 0, n.paused = !1, n.instanceCount = 0, n.instanceOptions = {}, n._iO = {}, c(), n.isHTML5 && (n.position = 0)), (!n.instanceCount || n._iO.multiShotEvents) && e && At(n, function() {
                        e.apply(n)
                    }))
                }, this._whileloading = function(e, t, i, r) {
                    var o = n._iO;
                    n.bytesLoaded = e, n.bytesTotal = t, n.duration = Math.floor(i), n.bufferLength = r, n.durationEstimate = n.isHTML5 || o.isMovieStar ? n.duration : o.duration ? n.duration > o.duration ? n.duration : o.duration : parseInt(n.bytesTotal / n.bytesLoaded * n.duration, 10), n.isHTML5 || (n.buffered = [{
                        start: 0,
                        end: n.duration
                    }]), (3 !== n.readyState || n.isHTML5) && o.whileloading && o.whileloading.apply(n)
                }, this._whileplaying = function(e, i, r, o, a) {
                    var s = n._iO;
                    return isNaN(e) || null === e ? !1 : (n.position = Math.max(0, e), n._processOnPosition(), !n.isHTML5 && v > 8 && (s.usePeakData && i !== t && i && (n.peakData = {
                        left: i.leftPeak,
                        right: i.rightPeak
                    }), s.useWaveformData && r !== t && r && (n.waveformData = {
                        left: r.split(","),
                        right: o.split(",")
                    }), s.useEQData && a !== t && a && a.leftEQ && (e = a.leftEQ.split(","), n.eqData = e, n.eqData.left = e, a.rightEQ !== t && a.rightEQ && (n.eqData.right = a.rightEQ.split(",")))), 1 === n.playState && (!n.isHTML5 && 8 === v && !n.position && n.isBuffering && n._onbufferchange(0), s.whileplaying && s.whileplaying.apply(n)), !0)
                }, this._oncaptiondata = function(e) {
                    n.captiondata = e, n._iO.oncaptiondata && n._iO.oncaptiondata.apply(n, [e])
                }, this._onmetadata = function(e, t) {
                    var i = {},
                        r, o;
                    for (r = 0, o = e.length; o > r; r++) i[e[r]] = t[r];
                    n.metadata = i, n._iO.onmetadata && n._iO.onmetadata.apply(n)
                }, this._onid3 = function(e, t) {
                    var i = [],
                        r, o;
                    for (r = 0, o = e.length; o > r; r++) i[e[r]] = t[r];
                    n.id3 = H(n.id3, i), n._iO.onid3 && n._iO.onid3.apply(n)
                }, this._onconnect = function(e) {
                    e = 1 === e, (n.connected = e) && (n.failures = 0, rt(n.id) && (n.getAutoPlay() ? n.play(t, n.getAutoPlay()) : n._iO.autoLoad && n.load()), n._iO.onconnect && n._iO.onconnect.apply(n, [e]))
                }, this._ondataerror = function(e) {
                    0 < n.playState && n._iO.ondataerror && n._iO.ondataerror.apply(n)
                }
            }, I = function() {
                return d.body || d.getElementsByTagName("div")[0]
            }, u = function(e) {
                return d.getElementById(e)
            }, H = function(e, i) {
                var r = e || {},
                    n, o;
                n = i === t ? s.defaultOptions : i;
                for (o in n) n.hasOwnProperty(o) && r[o] === t && (r[o] = "object" != typeof n[o] || null === n[o] ? n[o] : H(r[o], n[o]));
                return r
            }, At = function(t, i) {
                t.isHTML5 || 8 !== v ? i() : e.setTimeout(i, 0)
            }, M = {
                onready: 1,
                ontimeout: 1,
                defaultOptions: 1,
                flash9Options: 1,
                movieStarOptions: 1
            }, w = function(e, i) {
                var r, n = !0,
                    o = i !== t,
                    a = s.setupOptions;
                for (r in e)
                    if (e.hasOwnProperty(r))
                        if ("object" != typeof e[r] || null === e[r] || e[r] instanceof Array || e[r] instanceof RegExp) o && M[i] !== t ? s[i][r] = e[r] : a[r] !== t ? (s.setupOptions[r] = e[r], s[r] = e[r]) : M[r] === t ? n = !1 : s[r] instanceof Function ? s[r].apply(s, e[r] instanceof Array ? e[r] : [e[r]]) : s[r] = e[r];
                        else {
                            if (M[r] !== t) return w(e[r], r);
                            n = !1
                        }
                return n
            }, _t = function() {
                function t(e) {
                    e = Rt.call(e);
                    var t = e.length;
                    return r ? (e[1] = "on" + e[1], t > 3 && e.pop()) : 3 === t && e.push(!1), e
                }

                function i(e, t) {
                    var i = e.shift(),
                        o = [n[t]];
                    r ? i[o](e[0], e[1]) : i[o].apply(i, e)
                }
                var r = e.attachEvent,
                    n = {
                        add: r ? "attachEvent" : "addEventListener",
                        remove: r ? "detachEvent" : "removeEventListener"
                    };
                return {
                    add: function() {
                        i(t(arguments), "add")
                    },
                    remove: function() {
                        i(t(arguments), "remove")
                    }
                }
            }(), Ct = {
                abort: o(function() {}),
                canplay: o(function() {
                    var e = this._s,
                        i;
                    if (e._html5_canplay) return !0;
                    if (e._html5_canplay = !0, e._onbufferchange(0), i = e._iO.position === t || isNaN(e._iO.position) ? null : e._iO.position / 1e3, e.position && this.currentTime !== i) try {
                        this.currentTime = i
                    } catch (r) {}
                    e._iO._oncanplay && e._iO._oncanplay()
                }),
                canplaythrough: o(function() {
                    var e = this._s;
                    e.loaded || (e._onbufferchange(0), e._whileloading(e.bytesLoaded, e.bytesTotal, e._get_html5_duration()), e._onload(!0))
                }),
                ended: o(function() {
                    this._s._onfinish()
                }),
                error: o(function() {
                    this._s._onload(!1)
                }),
                loadeddata: o(function() {
                    var e = this._s;
                    !e._loaded && !kt && (e.duration = e._get_html5_duration())
                }),
                loadedmetadata: o(function() {}),
                loadstart: o(function() {
                    this._s._onbufferchange(1)
                }),
                play: o(function() {
                    this._s._onbufferchange(0)
                }),
                playing: o(function() {
                    this._s._onbufferchange(0)
                }),
                progress: o(function(e) {
                    var t = this._s,
                        i, r, n = 0,
                        n = e.target.buffered;
                    i = e.loaded || 0;
                    var o = e.total || 1;
                    if (t.buffered = [], n && n.length) {
                        for (i = 0, r = n.length; r > i; i++) t.buffered.push({
                            start: 1e3 * n.start(i),
                            end: 1e3 * n.end(i)
                        });
                        n = 1e3 * (n.end(0) - n.start(0)), i = Math.min(1, n / (1e3 * e.target.duration))
                    }
                    isNaN(i) || (t._onbufferchange(0), t._whileloading(i, o, t._get_html5_duration()), i && o && i === o && Ct.canplaythrough.call(this, e))
                }),
                ratechange: o(function() {}),
                suspend: o(function(e) {
                    var t = this._s;
                    Ct.progress.call(this, e), t._onsuspend()
                }),
                stalled: o(function() {}),
                timeupdate: o(function() {
                    this._s._onTimer()
                }),
                waiting: o(function() {
                    this._s._onbufferchange(1)
                })
            }, Et = function(e) {
                return e && (e.type || e.url || e.serverURL) ? e.serverURL || e.type && n(e.type) ? !1 : e.type ? vt({
                    type: e.type
                }) : vt({
                    url: e.url
                }) || s.html5Only || e.url.match(/data\:/i) : !1
            }, yt = function(e) {
                var t;
                return e && (t = kt ? "about:blank" : s.html5.canPlayType("audio/wav") ? "data:audio/wave;base64,/UklGRiYAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQIAAAD//w==" : "about:blank", e.src = t, void 0 !== e._called_unload && (e._called_load = !1)), bt && (Ht = null), t
            }, vt = function(e) {
                if (!s.useHTML5Audio || !s.hasHTML5) return !1;
                var i = e.url || null;
                e = e.type || null;
                var r = s.audioFormats,
                    o;
                if (e && s.html5[e] !== t) return s.html5[e] && !n(e);
                if (!gt) {
                    gt = [];
                    for (o in r) r.hasOwnProperty(o) && (gt.push(o), r[o].related && (gt = gt.concat(r[o].related)));
                    gt = RegExp("\\.(" + gt.join("|") + ")(\\?.*)?$", "i")
                }
                return o = i ? i.toLowerCase().match(gt) : null, o && o.length ? o = o[1] : e && (i = e.indexOf(";"), o = (-1 !== i ? e.substr(0, i) : e).substr(6)), o && s.html5[o] !== t ? i = s.html5[o] && !n(o) : (e = "audio/" + o, i = s.html5.canPlayType({
                    type: e
                }), i = (s.html5[o] = i) && s.html5[e] && !n(e)), i
            }, xt = function() {
                function e(e) {
                    var t, r = t = !1;
                    if (!i || "function" != typeof i.canPlayType) return t;
                    if (e instanceof Array) {
                        for (l = 0, t = e.length; t > l; l++)(s.html5[e[l]] || i.canPlayType(e[l]).match(s.html5Test)) && (r = !0, s.html5[e[l]] = !0, s.flash[e[l]] = !!e[l].match(jt));
                        t = r
                    } else e = i && "function" == typeof i.canPlayType ? i.canPlayType(e) : !1, t = !(!e || !e.match(s.html5Test));
                    return t
                }
                if (!s.useHTML5Audio || !s.hasHTML5) return ft = s.html5.usingFlash = !0, !1;
                var i = Audio !== t ? Ut && 10 > opera.version() ? new Audio(null) : new Audio : null,
                    r, n, o = {},
                    a, l;
                a = s.audioFormats;
                for (r in a)
                    if (a.hasOwnProperty(r) && (n = "audio/" + r, o[r] = e(a[r].type), o[n] = o[r], r.match(jt) ? (s.flash[r] = !0, s.flash[n] = !0) : (s.flash[r] = !1, s.flash[n] = !1), a[r] && a[r].related))
                        for (l = a[r].related.length - 1; l >= 0; l--) o["audio/" + a[r].related[l]] = o[r], s.html5[a[r].related[l]] = o[r], s.flash[a[r].related[l]] = o[r];
                return o.canPlayType = i ? e : null, s.html5 = H(s.html5, o), s.html5.usingFlash = mt(), ft = s.html5.usingFlash, !0
            }, k = {}, Z = function() {}, tt = function(e) {
                return 8 === v && 1 < e.loops && e.stream && (e.stream = !1), e
            }, it = function(e, t) {
                return e && !e.usePolicyFile && (e.onid3 || e.usePeakData || e.useWaveformData || e.useEQData) && (e.usePolicyFile = !0), e
            }, f = function() {
                return !1
            }, X = function(e) {
                for (var t in e) e.hasOwnProperty(t) && "function" == typeof e[t] && (e[t] = f)
            }, q = function(e) {
                e === t && (e = !1), (_ || e) && s.disable(e)
            }, Y = function(e) {
                var t = null;
                if (e)
                    if (e.match(/\.swf(\?.*)?$/i)) {
                        if (t = e.substr(e.toLowerCase().lastIndexOf(".swf?") + 4)) return e
                    } else e.lastIndexOf("/") !== e.length - 1 && (e += "/");
                return e = (e && -1 !== e.lastIndexOf("/") ? e.substr(0, e.lastIndexOf("/") + 1) : "./") + s.movieURL, s.noSWFCache && (e += "?ts=" + (new Date).getTime()), e
            }, O = function() {
                v = parseInt(s.flashVersion, 10), 8 !== v && 9 !== v && (s.flashVersion = v = 8);
                var e = s.debugMode || s.debugFlash ? "_debug.swf" : ".swf";
                s.useHTML5Audio && !s.html5Only && s.audioFormats.mp4.required && 9 > v && (s.flashVersion = v = 9), s.version = s.versionNumber + (s.html5Only ? " (HTML5-only mode)" : 9 === v ? " (AS3/Flash 9)" : " (AS2/Flash 8)"), v > 8 ? (s.defaultOptions = H(s.defaultOptions, s.flash9Options), s.features.buffering = !0, s.defaultOptions = H(s.defaultOptions, s.movieStarOptions), s.filePatterns.flash9 = RegExp("\\.(mp3|" + qt.join("|") + ")(\\?.*)?$", "i"), s.features.movieStar = !0) : s.features.movieStar = !1, s.filePattern = s.filePatterns[8 !== v ? "flash9" : "flash8"], s.movieURL = (8 === v ? "soundmanager2.swf" : "soundmanager2_flash9.swf").replace(".swf", e), s.features.peakData = s.features.waveformData = s.features.eqData = v > 8
            }, G = function(e, t) {
                return h ? void h._setPolling(e, t) : !1
            }, W = function() {}, rt = this.getSoundById, et = function() {
                var e = [];
                return s.debugMode && e.push("sm2_debug"), s.debugFlash && e.push("flash_debug"), s.useHighPerformance && e.push("high_performance"), e.join(" ")
            }, J = function() {
                Z("fbHandler");
                var e = s.getMoviePercent(),
                    t = {
                        type: "FLASHBLOCK"
                    };
                return s.html5Only ? !1 : void(s.ok() ? s.oMC && (s.oMC.className = [et(), "movieContainer", "swf_loaded" + (s.didFlashBlock ? " swf_unblocked" : "")].join(" ")) : (ft && (s.oMC.className = et() + " movieContainer " + (null === e ? "swf_timedout" : "swf_error")), s.didFlashBlock = !0, C({
                    type: "ontimeout",
                    ignoreInit: !0,
                    error: t
                }), j(t)))
            }, S = function(e, i, r) {
                g[e] === t && (g[e] = []), g[e].push({
                    method: i,
                    scope: r || null,
                    fired: !1
                })
            }, C = function(e) {
                if (e || (e = {
                        type: s.ok() ? "onready" : "ontimeout"
                    }), !x && e && !e.ignoreInit || "ontimeout" === e.type && (s.ok() || _ && !e.ignoreInit)) return !1;
                var t = {
                        success: e && e.ignoreInit ? s.ok() : !_
                    },
                    i = e && e.type ? g[e.type] || [] : [],
                    r = [],
                    n, t = [t],
                    o = ft && !s.ok();
                for (e.error && (t[0].error = e.error), e = 0, n = i.length; n > e; e++) !0 !== i[e].fired && r.push(i[e]);
                if (r.length)
                    for (e = 0, n = r.length; n > e; e++) r[e].scope ? r[e].method.apply(r[e].scope, t) : r[e].method.apply(this, t), o || (r[e].fired = !0);
                return !0
            }, A = function() {
                e.setTimeout(function() {
                    s.useFlashBlock && J(), C(), "function" == typeof s.onload && s.onload.apply(e), s.waitForWindowLoad && _t.add(e, "load", A)
                }, 1)
            }, Mt = function() {
                if (wt !== t) return wt;
                var i = !1,
                    r = navigator,
                    n = r.plugins,
                    o, a = e.ActiveXObject;
                if (n && n.length)(r = r.mimeTypes) && r["application/x-shockwave-flash"] && r["application/x-shockwave-flash"].enabledPlugin && r["application/x-shockwave-flash"].enabledPlugin.description && (i = !0);
                else if (a !== t && !c.match(/MSAppHost/i)) {
                    try {
                        o = new a("ShockwaveFlash.ShockwaveFlash")
                    } catch (s) {
                        o = null
                    }
                    i = !!o
                }
                return wt = i
            }, mt = function() {
                var e, t, i = s.audioFormats;
                if (Lt && c.match(/os (1|2|3_0|3_1)/i) ? (s.hasHTML5 = !1, s.html5Only = !0, s.oMC && (s.oMC.style.display = "none")) : !s.useHTML5Audio || s.html5 && s.html5.canPlayType || (s.hasHTML5 = !1), s.useHTML5Audio && s.hasHTML5)
                    for (t in dt = !0, i) i.hasOwnProperty(t) && i[t].required && (s.html5.canPlayType(i[t].type) ? s.preferFlash && (s.flash[t] || s.flash[i[t].type]) && (e = !0) : (dt = !1, e = !0));
                return s.ignoreFlash && (e = !1, dt = !0), s.html5Only = s.hasHTML5 && s.useHTML5Audio && !e, !s.html5Only
            }, ct = function(e) {
                var t, i, r = 0;
                if (e instanceof Array) {
                    for (t = 0, i = e.length; i > t; t++)
                        if (e[t] instanceof Object) {
                            if (s.canPlayMIME(e[t].type)) {
                                r = t;
                                break
                            }
                        } else if (s.canPlayURL(e[t])) {
                        r = t;
                        break
                    }
                    e[r].url && (e[r] = e[r].url), e = e[r]
                }
                return e
            }, at = function(e) {
                e._hasTimer || (e._hasTimer = !0, !Nt && s.html5PollingInterval && (null === ut && 0 === ht && (ut = setInterval(lt, s.html5PollingInterval)), ht++))
            }, st = function(e) {
                e._hasTimer && (e._hasTimer = !1, !Nt && s.html5PollingInterval && ht--)
            }, lt = function() {
                var e;
                if (null !== ut && !ht) return clearInterval(ut), ut = null, !1;
                for (e = s.soundIDs.length - 1; e >= 0; e--) s.sounds[s.soundIDs[e]].isHTML5 && s.sounds[s.soundIDs[e]]._hasTimer && s.sounds[s.soundIDs[e]]._onTimer()
            }, j = function(i) {
                i = i !== t ? i : {}, "function" == typeof s.onerror && s.onerror.apply(e, [{
                    type: i.type !== t ? i.type : null
                }]), i.fatal !== t && i.fatal && s.disable()
            }, St = function() {
                if (!Bt || !Mt()) return !1;
                var e = s.audioFormats,
                    t, i;
                for (i in e)
                    if (e.hasOwnProperty(i) && ("mp3" === i || "mp4" === i) && (s.html5[i] = !1, e[i] && e[i].related))
                        for (t = e[i].related.length - 1; t >= 0; t--) s.html5[e[i].related[t]] = !1
            }, this._setSandboxType = function(e) {}, this._externalInterfaceOK = function(e) {
                return s.swfLoaded ? !1 : (s.swfLoaded = !0, Vt = !1, Bt && St(), void setTimeout(E, Ot ? 100 : 1))
            }, $ = function(e, i) {
                function r(e, t) {
                    return '<param name="' + e + '" value="' + t + '" />'
                }
                if (y && T) return !1;
                if (s.html5Only) return O(), s.oMC = u(s.movieID), E(), T = y = !0, !1;
                var n = i || s.url,
                    o = s.altURL || n,
                    a = I(),
                    l = et(),
                    h = null,
                    h = d.getElementsByTagName("html")[0],
                    p, f, m, h = h && h.dir && h.dir.match(/rtl/i);
                if (e = e === t ? s.id : e, O(), s.url = Y(Gt ? n : o), i = s.url, s.wmode = !s.wmode && s.useHighPerformance ? "transparent" : s.wmode, null !== s.wmode && (c.match(/msie 8/i) || !Ot && !s.useHighPerformance) && navigator.platform.match(/win32|win64/i) && (pt.push(k.spcWmode), s.wmode = null), a = {
                        name: e,
                        id: e,
                        src: i,
                        quality: "high",
                        allowScriptAccess: s.allowScriptAccess,
                        bgcolor: s.bgColor,
                        pluginspage: Wt + "www.macromedia.com/go/getflashplayer",
                        title: "JS/Flash audio component (SoundManager 2)",
                        type: "application/x-shockwave-flash",
                        wmode: s.wmode,
                        hasPriority: "true"
                    }, s.debugFlash && (a.FlashVars = "debug=1"), s.wmode || delete a.wmode, Ot) n = d.createElement("div"), f = ['<object id="' + e + '" data="' + i + '" type="' + a.type + '" title="' + a.title + '" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="' + Wt + 'download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0">', r("movie", i), r("AllowScriptAccess", s.allowScriptAccess), r("quality", a.quality), s.wmode ? r("wmode", s.wmode) : "", r("bgcolor", s.bgColor), r("hasPriority", "true"), s.debugFlash ? r("FlashVars", a.FlashVars) : "", "</object>"].join("");
                else
                    for (p in n = d.createElement("embed"), a) a.hasOwnProperty(p) && n.setAttribute(p, a[p]);
                if (W(), l = et(), a = I())
                    if (s.oMC = u(s.movieID) || d.createElement("div"), s.oMC.id) m = s.oMC.className, s.oMC.className = (m ? m + " " : "movieContainer") + (l ? " " + l : ""), s.oMC.appendChild(n), Ot && (p = s.oMC.appendChild(d.createElement("div")), p.className = "sm2-object-box", p.innerHTML = f), T = !0;
                    else {
                        if (s.oMC.id = s.movieID, s.oMC.className = "movieContainer " + l, p = l = null, s.useFlashBlock || (s.useHighPerformance ? l = {
                                position: "fixed",
                                width: "8px",
                                height: "8px",
                                bottom: "0px",
                                left: "0px",
                                overflow: "hidden"
                            } : (l = {
                                position: "absolute",
                                width: "6px",
                                height: "6px",
                                top: "-9999px",
                                left: "-9999px"
                            }, h && (l.left = Math.abs(parseInt(l.left, 10)) + "px"))), Ft && (s.oMC.style.zIndex = 1e4), !s.debugFlash)
                            for (m in l) l.hasOwnProperty(m) && (s.oMC.style[m] = l[m]);
                        try {
                            Ot || s.oMC.appendChild(n), a.appendChild(s.oMC), Ot && (p = s.oMC.appendChild(d.createElement("div")), p.className = "sm2-object-box", p.innerHTML = f), T = !0
                        } catch (v) {
                            throw Error(Z("domError") + " \n" + v.toString())
                        }
                    }
                return y = !0
            }, U = function() {
                return s.html5Only ? ($(), !1) : h || !s.url ? !1 : (h = s.getMovie(s.id), h || (Q ? (Ot ? s.oMC.innerHTML = K : s.oMC.appendChild(Q), Q = null, y = !0) : $(s.id, s.url), h = s.getMovie(s.id)), "function" == typeof s.oninitmovie && setTimeout(s.oninitmovie, 1), !0)
            }, P = function() {
                setTimeout(L, 1e3)
            }, D = function() {
                e.setTimeout(function() {
                    s.setup({
                        preferFlash: !1
                    }).reboot(), s.didFlashBlock = !0, s.beginDelayedInit()
                }, 1)
            }, L = function() {
                var t, i = !1;
                return !s.url || nt ? !1 : (nt = !0, _t.remove(e, "load", P), wt && Vt && !zt ? !1 : (x || (t = s.getMoviePercent(), t > 0 && 100 > t && (i = !0)), void setTimeout(function() {
                    return t = s.getMoviePercent(), i ? (nt = !1, e.setTimeout(P, 1), !1) : void(!x && It && (null === t ? s.useFlashBlock || 0 === s.flashLoadTimeout ? s.useFlashBlock && J() : !s.useFlashBlock && dt ? D() : C({
                        type: "ontimeout",
                        ignoreInit: !0,
                        error: {
                            type: "INIT_FLASHBLOCK"
                        }
                    }) : 0 !== s.flashLoadTimeout && (!s.useFlashBlock && dt ? D() : q(!0))))
                }, s.flashLoadTimeout)))
            }, F = function() {
                return zt || !Vt ? (_t.remove(e, "focus", F), !0) : (zt = It = !0, nt = !1, P(), _t.remove(e, "focus", F), !0)
            }, b = function(t) {
                if (x) return !1;
                if (s.html5Only) return x = !0, A(), !0;
                var i = !0,
                    r;
                return s.useFlashBlock && s.flashLoadTimeout && !s.getMoviePercent() || (x = !0), r = {
                    type: !wt && ft ? "NO_FLASH" : "INIT_TIMEOUT"
                }, (_ || t) && (s.useFlashBlock && s.oMC && (s.oMC.className = et() + " " + (null === s.getMoviePercent() ? "swf_timedout" : "swf_error")), C({
                    type: "ontimeout",
                    error: r,
                    ignoreInit: !0
                }), j(r), i = !1), _ || (s.waitForWindowLoad && !R ? _t.add(e, "load", A) : A()), i
            }, m = function() {
                var e, i = s.setupOptions;
                for (e in i) i.hasOwnProperty(e) && (s[e] === t ? s[e] = i[e] : s[e] !== i[e] && (s.setupOptions[e] = s[e]))
            }, E = function() {
                if (x) return !1;
                if (s.html5Only) return x || (_t.remove(e, "load", s.beginDelayedInit), s.enabled = !0, b()), !0;
                U();
                try {
                    h._externalInterfaceTest(!1), G(!0, s.flashPollingInterval || (s.useHighPerformance ? 10 : 50)), s.debugMode || h._disableDebug(), s.enabled = !0, s.html5Only || _t.add(e, "unload", f)
                } catch (t) {
                    return j({
                        type: "JS_TO_FLASH_EXCEPTION",
                        fatal: !0
                    }), q(!0), b(), !1
                }
                return b(), _t.remove(e, "load", s.beginDelayedInit), !0
            }, B = function() {
                return V ? !1 : (V = !0, m(), W(), !wt && s.hasHTML5 && s.setup({
                    useHTML5Audio: !0,
                    preferFlash: !1
                }), xt(), !wt && ft && (pt.push(k.needFlash), s.setup({
                    flashLoadTimeout: 1
                })), d.removeEventListener && d.removeEventListener("DOMContentLoaded", B, !1), U(), !0)
            }, Tt = function() {
                return "complete" === d.readyState && (B(), d.detachEvent("onreadystatechange", Tt)), !0
            }, z = function() {
                R = !0, _t.remove(e, "load", z)
            }, N = function() {
                Nt && (s.setupOptions.useHTML5Audio = !0, s.setupOptions.preferFlash = !1, Lt || Dt && !c.match(/android\s2\.3/i)) && (Lt && (s.ignoreFlash = !0), bt = !0)
            }, N(), Mt(), _t.add(e, "focus", F), _t.add(e, "load", P), _t.add(e, "load", z), d.addEventListener ? d.addEventListener("DOMContentLoaded", B, !1) : d.attachEvent ? d.attachEvent("onreadystatechange", Tt) : j({
                type: "NO_DOM2_EVENTS",
                fatal: !0
            })
        }
        var r = null;
        void 0 !== e.SM2_DEFER && SM2_DEFER || (r = new i), e.SoundManager = i, e.soundManager = r
    }(window);
var Boid = function() {
    var e = new THREE.Vector3,
        t, i = 500,
        r = 500,
        n = 200,
        o, a = 300,
        s = 15,
        l = .1,
        h = !1;
    this.position = new THREE.Vector3, this.velocity = new THREE.Vector3, t = new THREE.Vector3, this.setGoal = function(e) {
        o = e
    }, this.setAvoidWalls = function(e) {
        h = e
    }, this.setWorldSize = function(e, t, o) {
        i = e, r = t, n = o
    }, this.run = function(o) {
        h && (e.set(-i, this.position.y, this.position.z), e = this.avoid(e), e.multiplyScalar(50), t.add(e), e.set(i, this.position.y, this.position.z), e = this.avoid(e), e.multiplyScalar(50), t.add(e), e.set(this.position.x, -r, this.position.z), e = this.avoid(e), e.multiplyScalar(50), t.add(e), e.set(this.position.x, r, this.position.z), e = this.avoid(e), e.multiplyScalar(50), t.add(e), e.set(this.position.x, this.position.y, -n), e = this.avoid(e), e.multiplyScalar(50), t.add(e), e.set(this.position.x, this.position.y, n), e = this.avoid(e), e.multiplyScalar(50), t.add(e)), Math.random() > .5 && this.flock(o), this.move()
    }, this.flock = function(e) {
        o && t.add(this.reach(o, .005)), t.add(this.alignment(e)), t.add(this.cohesion(e)), t.add(this.separation(e))
    }, this.move = function() {
        this.velocity.add(t);
        var e = this.velocity.length();
        e > s && this.velocity.divideScalar(e / s), this.position.add(this.velocity), t.set(0, 0, 0)
    }, this.checkBounds = function() {
        this.position.x > i && (this.position.x = -i), this.position.x < -i && (this.position.x = i), this.position.y > r && (this.position.y = -r), this.position.y < -r && (this.position.y = r), this.position.z > n && (this.position.z = -n), this.position.z < -n && (this.position.z = n)
    }, this.avoid = function(e) {
        var t = new THREE.Vector3;
        return t.copy(this.position), t.sub(e), t.multiplyScalar(1 / this.position.distanceToSquared(e)), t
    }, this.repulse = function(e) {
        var i = this.position.distanceTo(e);
        if (150 > i) {
            var r = new THREE.Vector3;
            r.subVectors(this.position, e), r.multiplyScalar(.5 / i), t.add(r)
        }
    }, this.reach = function(e, t) {
        var i = new THREE.Vector3;
        return i.subVectors(e, this.position), i.multiplyScalar(t), i
    }, this.alignment = function(e) {
        for (var t, i = new THREE.Vector3, r = 0, n, o = 0, s = e.length; s > o; o++) Math.random() > .6 || (t = e[o], n = t.position.distanceTo(this.position), n > 0 && a >= n && (i.add(t.velocity), r++));
        if (r > 0) {
            i.divideScalar(r);
            var h = i.length();
            h > l && i.divideScalar(h / l)
        }
        return i
    }, this.cohesion = function(e) {
        for (var t, i, r = new THREE.Vector3, n = new THREE.Vector3, o = 0, s = 0, h = e.length; h > s; s++) Math.random() > .6 || (t = e[s], i = t.position.distanceTo(this.position), i > 0 && a >= i && (r.add(t.position), o++));
        o > 0 && r.divideScalar(o), n.subVectors(r, this.position);
        var u = n.length();
        return u > l && n.divideScalar(u / l), n
    }, this.separation = function(e) {
        for (var t, i, r = new THREE.Vector3, n = new THREE.Vector3, o = 0, s = e.length; s > o; o++) Math.random() > .6 || (t = e[o], i = t.position.distanceTo(this.position), i > 0 && a >= i && (n.subVectors(this.position, t.position), n.normalize(), n.divideScalar(i), r.add(n)));
        return r
    }
};
THREE.FresnelShader = {
    uniforms: {
        mRefractionRatio: {
            type: "f",
            value: 1.02
        },
        mFresnelBias: {
            type: "f",
            value: .1
        },
        mFresnelPower: {
            type: "f",
            value: 2
        },
        mFresnelScale: {
            type: "f",
            value: 1
        },
        tCube: {
            type: "t",
            value: null
        }
    },
    vertexShader: ["uniform float mRefractionRatio;", "uniform float mFresnelBias;", "uniform float mFresnelScale;", "uniform float mFresnelPower;", "varying vec3 vReflect;", "varying vec3 vRefract[3];", "varying float vReflectionFactor;", "void main() {", "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );", "vec3 I = worldPosition.xyz - cameraPosition;", "vReflect = reflect( I, worldNormal );", "vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );", "vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );", "vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );", "vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );", "gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),
    fragmentShader: ["uniform samplerCube tCube;", "varying vec3 vReflect;", "varying vec3 vRefract[3];", "varying float vReflectionFactor;", "void main() {", "vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );", "vec4 refractedColor = vec4( 1.0 );", "refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;", "refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;", "refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;", "gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );", "}"].join("\n")
}, THREE.HorizontalBlurShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null
        },
        h: {
            type: "f",
            value: 1 / 512
        }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float h;", "varying vec2 vUv;", "void main() {", "vec4 sum = vec4( 0.0 );", "sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;", "sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;", "gl_FragColor = sum;", "}"].join("\n")
}, THREE.VerticalBlurShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null
        },
        v: {
            type: "f",
            value: 1 / 512
        }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float v;", "varying vec2 vUv;", "void main() {", "vec4 sum = vec4( 0.0 );", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;", "gl_FragColor = sum;", "}"].join("\n")
}, THREE.EffectComposer = function(e, t) {
    if (this.renderer = e, this.renderTarget1 = t, void 0 === this.renderTarget1) {
        var i = window.innerWidth || 1,
            r = window.innerHeight || 1;
        this.renderTargetParameters = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            stencilBuffer: !1
        }, this.renderTarget1 = new THREE.WebGLRenderTarget(i, r, this.renderTargetParameters)
    }
    this.renderTarget2 = this.renderTarget1.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.passes = [], this.copyPass = new THREE.ShaderPass(THREE.ShaderExtras.screen)
}, THREE.EffectComposer.prototype = {
    swapBuffers: function() {
        var e = this.readBuffer;
        this.readBuffer = this.writeBuffer, this.writeBuffer = e
    },
    addPass: function(e) {
        this.passes.push(e)
    },
    render: function(e) {
        this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
        var t = !1,
            i, r, n = this.passes.length;
        for (r = 0; n > r; r++)
            if (i = this.passes[r], i.enabled) {
                if (i.render(this.renderer, this.writeBuffer, this.readBuffer, e, t), i.needsSwap) {
                    if (t) {
                        var o = this.renderer.context;
                        o.stencilFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), o.stencilFunc(o.EQUAL, 1, 4294967295)
                    }
                    this.swapBuffers()
                }
                i instanceof THREE.MaskPass ? t = !0 : i instanceof THREE.ClearMaskPass && (t = !1)
            }
    },
    reset: function(e) {
        this.renderTarget1 = e, void 0 === this.renderTarget1 && (this.renderTarget1 = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, this.renderTargetParameters)), this.renderTarget2 = this.renderTarget1.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
    }
}, THREE.EffectComposer.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), THREE.EffectComposer.quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null), THREE.EffectComposer.scene = new THREE.Scene, THREE.EffectComposer.scene.add(THREE.EffectComposer.quad), THREE.RenderPass = function(e, t, i, r, n) {
    this.scene = e, this.camera = t, this.overrideMaterial = i, this.clearColor = r, this.clearAlpha = void 0 !== n ? n : 1, this.oldClearColor = new THREE.Color, this.oldClearAlpha = 1, this.enabled = !0, this.clear = !0, this.needsSwap = !1
}, THREE.RenderPass.prototype = {
    render: function(e, t, i, r) {
        this.scene.overrideMaterial = this.overrideMaterial, this.clearColor && (this.oldClearColor.copy(e.getClearColor()), this.oldClearAlpha = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), e.render(this.scene, this.camera, i, this.clear), this.clearColor && e.setClearColor(this.oldClearColor, this.oldClearAlpha), this.scene.overrideMaterial = null
    }
}, THREE.MaskPass = function(e, t) {
    this.scene = e, this.camera = t, this.enabled = !0, this.clear = !0, this.needsSwap = !1, this.inverse = !1
}, THREE.MaskPass.prototype = {
    render: function(e, t, i, r) {
        var n = e.context;
        n.colorMask(!1, !1, !1, !1), n.depthMask(!1);
        var o, a;
        this.inverse ? (o = 0, a = 1) : (o = 1, a = 0), n.enable(n.STENCIL_TEST), n.stencilOp(n.REPLACE, n.REPLACE, n.REPLACE), n.stencilFunc(n.ALWAYS, o, 4294967295), n.clearStencil(a), e.render(this.scene, this.camera, i, this.clear), e.render(this.scene, this.camera, t, this.clear), n.colorMask(!0, !0, !0, !0), n.depthMask(!0), n.stencilFunc(n.EQUAL, 1, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP)
    }
}, THREE.ClearMaskPass = function() {
    this.enabled = !0
}, THREE.ClearMaskPass.prototype = {
    render: function(e, t, i, r) {
        var n = e.context;
        n.disable(n.STENCIL_TEST)
    }
}, THREE.BloomPass = function(e, t, i, r) {
    e = void 0 !== e ? e : 1, t = void 0 !== t ? t : 25, i = void 0 !== i ? i : 4, r = void 0 !== r ? r : 256;
    var n = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBFormat
    };
    this.renderTargetX = new THREE.WebGLRenderTarget(r, r, n), this.renderTargetY = new THREE.WebGLRenderTarget(r, r, n);
    var o = THREE.ShaderExtras.screen;
    this.screenUniforms = THREE.UniformsUtils.clone(o.uniforms), this.screenUniforms.opacity.value = e, this.materialScreen = new THREE.ShaderMaterial({
        uniforms: this.screenUniforms,
        vertexShader: o.vertexShader,
        fragmentShader: o.fragmentShader,
        blending: THREE.AdditiveBlending,
        transparent: !0
    });
    var a = THREE.ShaderExtras.convolution;
    this.convolutionUniforms = THREE.UniformsUtils.clone(a.uniforms), this.convolutionUniforms.uImageIncrement.value = THREE.BloomPass.blurx, this.convolutionUniforms.cKernel.value = THREE.ShaderExtras.buildKernel(i), this.materialConvolution = new THREE.ShaderMaterial({
        uniforms: this.convolutionUniforms,
        vertexShader: "#define KERNEL_SIZE " + t + ".0\n" + a.vertexShader,
        fragmentShader: "#define KERNEL_SIZE " + t + "\n" + a.fragmentShader
    }), this.enabled = !0, this.needsSwap = !1, this.clear = !1
}, THREE.BloomPass.prototype = {
    render: function(e, t, i, r, n) {
        n && e.context.disable(e.context.STENCIL_TEST), THREE.EffectComposer.quad.material = this.materialConvolution, this.convolutionUniforms.tDiffuse.value = i, this.convolutionUniforms.uImageIncrement.value = THREE.BloomPass.blurX, e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTargetX, !0), this.convolutionUniforms.tDiffuse.value = this.renderTargetX, this.convolutionUniforms.uImageIncrement.value = THREE.BloomPass.blurY, e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTargetY, !0), THREE.EffectComposer.quad.material = this.materialScreen, this.screenUniforms.tDiffuse.value = this.renderTargetY, n && e.context.enable(e.context.STENCIL_TEST), e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, i, this.clear)
    }
}, THREE.BloomPass.blurX = new THREE.Vector2(.001953125, 0), THREE.BloomPass.blurY = new THREE.Vector2(0, .001953125), THREE.ShaderPass = function(e, t) {
    this.textureID = void 0 !== t ? t : "tDiffuse", this.uniforms = THREE.UniformsUtils.clone(e.uniforms), this.material = new THREE.ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: e.vertexShader,
        fragmentShader: e.fragmentShader
    }), this.renderToScreen = !1, this.enabled = !0, this.needsSwap = !0, this.clear = !1
}, THREE.ShaderPass.prototype = {
    render: function(e, t, i, r) {
        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i), THREE.EffectComposer.quad.material = this.material, this.renderToScreen ? e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera) : e.render(THREE.EffectComposer.scene, THREE.EffectComposer.camera, t, this.clear)
    }
}, THREE.FocusShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null
        },
        screenWidth: {
            type: "f",
            value: 1024
        },
        screenHeight: {
            type: "f",
            value: 1024
        },
        sampleDistance: {
            type: "f",
            value: .94
        },
        waveFactor: {
            type: "f",
            value: .00125
        }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: ["uniform float screenWidth;", "uniform float screenHeight;", "uniform float sampleDistance;", "uniform float waveFactor;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 color, org, tmp, add;", "float sample_dist, f;", "vec2 vin;", "vec2 uv = vUv;", "add = color = org = texture2D( tDiffuse, uv );", "vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );", "sample_dist = dot( vin, vin ) * 2.0;", "f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;", "vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );", "add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );", "color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );", "gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );", "}"].join("\n")
}, THREE.RGBShiftShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null
        },
        amount: {
            type: "f",
            value: .005
        },
        angle: {
            type: "f",
            value: 0
        }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float amount;", "uniform float angle;", "varying vec2 vUv;", "void main() {", "vec2 offset = amount * vec2( cos(angle), sin(angle));", "vec4 cr = texture2D(tDiffuse, vUv + offset);", "vec4 cga = texture2D(tDiffuse, vUv);", "vec4 cb = texture2D(tDiffuse, vUv - offset);", "gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);", "}"].join("\n")
}, THREE.VignetteShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null
        },
        offset: {
            type: "f",
            value: 1
        },
        darkness: {
            type: "f",
            value: 1
        }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: ["uniform float offset;", "uniform float darkness;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );", "gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );", "}"].join("\n")
};
var OMM = OMM || {};
OMM.World = function() {
    this.renderer, this.camera, this.scene, this.container, this.mouseX = 0, this.mouseY = 0, this.renderTargetParameters, this.renderTarget, this.effectBloom, this.composer, this.bgScaleOffset = 0, this.bgScaleOffset2 = 2, this.leapTimeOut, this.isLeapConnected = !1, this.pointables = [], this.fingerParticles = [], this.perlin = new ImprovedNoise, this.rgbAmount = 0, this.boomTime = 1, this.canTouch = !0, this.isChap1Done = !1, this.init()
}, OMM.World.prototype = {
    init: function() {
        var e = this;
        this.mainEl = (new H.Element).addStyle({
            position: "absolute",
            top: "0px",
            left: "0px",
            width: "100%",
            height: "100%",
            opacity: "0"
        }), this.renderer = new THREE.WebGLRenderer, this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 2e4), this.scene = new THREE.Scene, this.camera.position.z = 1e3, this.camera.position.y = 0, this.camera.lookAt(new THREE.Vector3), this.renderer.setSize(window.innerWidth, window.innerHeight), this.mainEl.add(this.renderer.domElement), this.renderer.autoClear = !1, this.renderer.setClearColor(0), this.renderModel = new THREE.RenderPass(this.scene, this.camera), this.effectBloom = new THREE.BloomPass(.9), this.RGBShiftPass = new THREE.ShaderPass(THREE.RGBShiftShader), this.vignettePass = new THREE.ShaderPass(THREE.VignetteShader), this.hBlurShader = new THREE.ShaderPass(THREE.HorizontalBlurShader), this.vBlurShader = new THREE.ShaderPass(THREE.VerticalBlurShader), this.hBlurShader.uniforms.h.value = 0, this.vBlurShader.uniforms.v.value = 0, this.effectScreen = new THREE.ShaderPass(THREE.ShaderExtras.screen), this.vignettePass.uniforms.darkness.value = 2, this.RGBShiftPass.uniforms.amount.value = 0, this.effectScreen.renderToScreen = !0, this.composer = new THREE.EffectComposer(this.renderer), this.composer.addPass(this.renderModel), this.composer.addPass(this.effectBloom), this.composer.addPass(this.RGBShiftPass), this.composer.addPass(this.vignettePass), this.composer.addPass(this.hBlurShader), this.composer.addPass(this.vBlurShader), this.composer.addPass(this.effectScreen);
        var t = "./assets/skybox/fresnel/",
            i = ".jpg",
            r = [t + "px" + i, t + "nx" + i, t + "py" + i, t + "ny" + i, t + "pz" + i, t + "nz" + i];
        this.envMap = THREE.ImageUtils.loadTextureCube(r), this.envMap.format = THREE.RGBFormat;
        var n = new THREE.Color(16777215),
            o = site.loaderTexLens1.texture,
            a = site.loaderTexLens2.texture,
            s = site.loaderTexLens3.texture;
        this.lensFlare = new THREE.LensFlare(o, 350, 0, THREE.AdditiveBlending, n), this.lensFlare.add(s, 60, .7, THREE.AdditiveBlending), this.lensFlare.add(s, 100, .9, THREE.AdditiveBlending), this.lensFlare.add(s, 70, 1, THREE.AdditiveBlending), this.lensFlare.position.x = -530, this.lensFlare.position.y = 500, this.lensFlare.position.z = -1e3, this.scene.add(this.lensFlare), this.bg = new THREE.Mesh(new THREE.PlaneBufferGeometry(1200, 750, 1, 1), new THREE.MeshBasicMaterial({
            map: site.loaderTexBg1.texture,
            transparent: !0
        })), this.bg2 = new THREE.Mesh(new THREE.PlaneBufferGeometry(1200, 750, 1, 1), new THREE.MeshBasicMaterial({
            map: site.loaderTexBg2.texture,
            opacity: 0,
            transparent: !0
        })), this.bg.position.set(0, 0, -3e3), this.bg.scale.x = 10, this.bg.scale.y = 10, this.bg.scale.z = 10, this.scene.add(this.bg), this.bg2.position.set(0, 0, -3010), this.bg2.scale.x = 10, this.bg2.scale.y = 10, this.bg2.scale.z = 10, this.scene.add(this.bg2), this.light = new THREE.PointLight(5930622, 30), this.light.position.y = -2e4, this.light.position.x = 2e4, this.light.position.z = -15e3, this.scene.add(this.light), this.light2 = new THREE.PointLight(16380083, 40), this.light2.position.y = 5e3, this.light2.position.x = -5e3, this.light2.position.z = -6e3, this.scene.add(this.light2), this.mouse = new THREE.Vector2, this.raycaster = new THREE.Raycaster, $(window).mousemove($.proxy(this.onDocumentMouseMove, this))
    },
    blur: function() {
        TweenMax.to(this.hBlurShader.uniforms.h, 1, {
            value: 1 / window.innerWidth * 5,
            ease: Expo.easeInOut
        }), TweenMax.to(this.vBlurShader.uniforms.v, 1, {
            value: 1 / window.innerHeight * 5,
            ease: Expo.easeInOut
        })
    },
    unblur: function() {
        TweenMax.to(this.hBlurShader.uniforms.h, 1, {
            value: 0,
            ease: Expo.easeInOut
        }), TweenMax.to(this.vBlurShader.uniforms.v, 1, {
            value: 0,
            ease: Expo.easeInOut
        })
    },
    rgbEffect: function() {
        var e = this;
        e.rgbAmount = .05 * Math.random(), setTimeout(function() {
            e.rgbAmount = .05 * Math.random()
        }, 500 * Math.random())
    },
    onDocumentMouseMove: function(e) {
        this.mouseX = (e.clientX - window.innerWidth / 2) / 2, this.mouseY = (e.clientY - window.innerHeight / 2) / 2, this.mouse.x = e.clientX / window.innerWidth * 2 - 1, this.mouse.y = 2 * -(e.clientY / window.innerHeight) + 1
    },
    loop: function() {
        var e = this;
        this.camera.position.x += .05 * (this.mouseX - this.camera.position.x), this.camera.position.y += .05 * (-this.mouseY - this.camera.position.y), this.camera.lookAt(this.scene.position);
        var t = 3 * -this.camera.position.x,
            i = 3 * -this.camera.position.y;
        this.bg.position.set(t, i, -3e3), this.bg.lookAt(this.camera.position), this.bg2.position.set(t, i, -3010), this.bg2.lookAt(this.camera.position), e.rgbAmount += .1 * -e.rgbAmount, this.RGBShiftPass.uniforms.amount.value = e.rgbAmount, this.renderer.clear(), this.composer.render(), this.raycaster.setFromCamera(this.mouse, this.camera)
    },
    resize: function(e) {
        this.renderer.setSize(window.innerWidth, window.innerHeight), this.camera.aspect = window.innerWidth / window.innerHeight, this.camera.updateProjectionMatrix(), this.composer.reset()
    }
};
var OMM = OMM || {};
OMM.Chapter1 = function() {
    this.ballNoiseOffX = 0, this.noiseSpeed = .001, this.ballNoiseAmount = .01, this.rotSpeed = .05, this.noiseAmount = 0, this.noiseOffsetX = 0, this.noiseOffsetY = Math.random(), this.noiseOffsetZ = Math.random(), this.perlin = new ImprovedNoise, this.init()
}, OMM.Chapter1.prototype = {
    init: function() {
        var e = this;
        this.mainEl = new THREE.Object3D, this.sphereGeom = new THREE.SphereGeometry(380, 20, 20), this.sphereGeom.dynamic = !0, this.orVertices = [];
        for (var t = this.sphereGeom.vertices.length; t--;) e.orVertices.push(e.sphereGeom.vertices[t].clone());
        this.sphereMat = new THREE.MeshPhongMaterial({
            color: 1052688,
            envMap: site.world.envMap,
            bumpMap: site.loaderTexDirt.texture,
            bumpScale: 2,
            shininess: .7,
            reflectivity: .05,
            combine: THREE.MixOperation,
            shading: THREE.SmoothShading,
            side: THREE.DoubleSide,
            opacity: 1
        }), this.sphere = new THREE.Mesh(this.sphereGeom, this.sphereMat), this.mainEl.add(this.sphere), this.pArray = [];
        for (var i = new THREE.MeshPhongMaterial({
                color: 0,
                shininess: 0
            }), r = 0; 100 > r; r++) {
            for (var n = 10 * Math.random() + 1, o = new THREE.BoxGeometry(n, n, n), a = 0; a < o.vertices.length; a++) o.vertices[a].x += (Math.random() - .5) * n, o.vertices[a].y += (Math.random() - .5) * n, o.vertices[a].z += (Math.random() - .5) * n;
            var s = new THREE.Mesh(o, i);
            s.position.x = 2e3 * (Math.random() - .5), s.position.y = 2e3 * (Math.random() - .5), s.position.z = 2e3 * (Math.random() - .5), e.mainEl.add(s), e.pArray.push({
                velY: 2 * Math.random() + .5,
                rotX: .05 * Math.random(),
                rotY: .05 * Math.random(),
                mesh: s
            })
        }
        this.shouldLoop = !0
    },
    animateIn: function(e) {
        var t = this;
        this.callback = e, $(window).click(function() {
            t.onClick()
        }), $(window).bind("touchstart", function() {
            t.onClick()
        }), this.loop1Playing = !0
    },
    animateOut: function() {
        var e = this;
        $(window).unbind("click"), $(window).unbind("touchstart");
        for (var t = 0; t < this.pArray.length; t++) TweenMax.to(e.pArray[t].mesh.position, 2, {
            x: 0,
            y: 0,
            z: 0,
            ease: Back.easeIn
        });
        TweenMax.to(this.sphere.position, 2, {
            x: 0,
            y: 0,
            z: 0,
            ease: Back.easeIn
        }), TweenMax.to(this.sphere.scale, 2, {
            x: .1,
            y: .1,
            z: .1,
            ease: Back.easeIn,
            onComplete: function() {
                e.mainEl.remove(e.sphere);
                for (var t = 0; t < e.pArray.length; t++) e.mainEl.remove(e.pArray[t].mesh);
                e.shouldLoop = !1
            }
        }), soundManager.play("chap1Over2"), TweenMax.delayedCall(.5, function() {
            soundManager.stop("chap1Loop3"), soundManager.play("chap1Out")
        })
    },
    onClick: function() {
        var e = this;
        TweenMax.to(this, .3, {
            ballNoiseAmount: this.ballNoiseAmount + .06,
            noiseSpeed: this.noiseSpeed + .001
        }), TweenMax.to(this, .3, {
            noiseAmount: this.noiseAmount + 12
        }), TweenMax.to(site.world.vignettePass.uniforms.darkness, .3, {
            value: site.world.vignettePass.uniforms.darkness.value - .03
        }), TweenMax.to(this.sphere.scale, .3, {
            x: e.sphere.scale.x - .005,
            y: e.sphere.scale.y - .005,
            z: e.sphere.scale.z - .005
        }), (Math.random() > .9 || !this.hasClicked) && (soundManager.play("chap1Over"), site.world.rgbEffect(), this.hasClicked = !0)
    },
    generateNoise: function(e, t) {
        for (var i = this, r = e * t, n = new Float32Array(r), o = new ImprovedNoise, a = 1, s = 0, l = 0; r > l; l++) n[l] = 0;
        for (var h = 0; 4 > h; h++) {
            for (var l = 0; r > l; l++) {
                var u = l % e,
                    c = ~~(l / e);
                n[l] += o.noise(20 * u / a + i.ballNoiseOffX, 20 * c / a + i.ballNoiseOffX, s) * a * 1.75
            }
            a *= 5
        }
        return this.ballNoiseOffX += this.noiseSpeed, n
    },
    loop: function() {
        var e = this;
        if (this.shouldLoop) {
            for (var t = this.generateNoise(21, 21), i = this.sphereGeom.vertices.length; i--;) {
                var r = e.sphereGeom.vertices[i],
                    n = i;
                i > this.sphereGeom.vertices.length - 21 && (n = this.sphereGeom.vertices.length - 1), 17 > i && (n = 0), e.sphereGeom.vertices[i] = e.orVertices[i].clone(), e.sphereGeom.vertices[i].add(e.orVertices[i].clone().normalize().multiplyScalar(t[n] * e.ballNoiseAmount))
            }
            this.sphere.geometry.verticesNeedUpdate = !0, this.sphere.geometry.normalsNeedUpdate = !0, this.sphere.geometry.computeFaceNormals(), this.sphere.geometry.computeVertexNormals(), this.sphere.rotation.y += this.rotSpeed, this.rotSpeed += .2 * (.005 - this.rotSpeed);
            var o = new THREE.Vector3(this.perlin.noise(this.noiseOffsetX, 0, 0) * this.noiseAmount, this.perlin.noise(this.noiseOffsetY, 0, 0) * this.noiseAmount, this.perlin.noise(this.noiseOffsetZ, 0, 0) * this.noiseAmount);
            if (this.noiseOffsetX += this.noiseSpeed, this.noiseOffsetY += this.noiseSpeed, this.noiseOffsetZ += this.noiseSpeed, this.sphere.position.x = o.x, this.sphere.position.y = o.y, this.sphere.position.z = o.z, !this.isExploding)
                for (var a = 0; a < this.pArray.length; a++) {
                    var s = e.pArray[a].mesh,
                        l = e.pArray[a].velY,
                        h = e.pArray[a].rotX,
                        u = e.pArray[a].rotY;
                    s.rotation.x += h, s.rotation.y += u, s.position.y += l, s.position.y > 1e3 && (s.position.y = -1e3)
                }
            e.noiseAmount >= 266 ? this.loop3Playing || (this.loop1Playing && (soundManager.stop("chap1Loop1"), this.loop1Playing = !1, soundManager.play("chap1Loop3", {
                loops: 1e4
            })), this.loop2Playing && (soundManager.stop("chap1Loop2"), this.loop2Playing = !1, soundManager.play("chap1Loop3", {
                loops: 1e4
            }), soundManager.play("chap1Over")), this.loop3Playing = !0) : e.noiseAmount >= 133 ? this.loop2Playing || (this.loop1Playing && (console.log("stop loop1"), soundManager.stop("chap1Loop1"), this.loop1Playing = !1, soundManager.play("chap1Loop2", {
                loops: 1e4
            }), soundManager.play("chap1Over")), this.loop3Playing && (soundManager.stop("chap1Loop3"), this.loop3Playing = !1, soundManager.play("chap1Loop2", {
                loops: 1e4
            })), this.loop2Playing = !0, console.log("play loop2")) : this.loop1Playing || (this.loop2Playing && (soundManager.stop("chap1Loop2"), this.loop2Playing = !1, soundManager.play("chap1Loop1", {
                loops: 1e4
            })), this.loop3Playing && (soundManager.stop("chap1Loop3"), this.loop3Playing = !1, soundManager.play("chap1Loop1", {
                loops: 1e4
            })), this.loop1Playing = !0), e.noiseAmount < 400 ? site.updateProgress(e.noiseAmount / 400 / 3) : e.isExploding || (console.log("boom"), e.isExploding = !0, this.callback.call(), site.updateProgress(1 / 3))
        }
    }
};
var OMM = OMM || {};
OMM.Chapter2 = function() {
    this.numFlocks = 160, this.ballNoiseOffX = 0, this.noiseSpeed = .01, this.flockOverCount = 0, this.sphereMergeCount = 0, this.flocks = [], this.boids = [], this.lines = [], this.init()
}, OMM.Chapter2.prototype = {
    init: function() {
        var e = this;
        this.mainEl = new THREE.Object3D;
        for (var t = new THREE.MeshPhongMaterial({
                color: 0,
                shading: THREE.FlatShading
            }), i = 0; i < this.numFlocks; i++) {
            var r = new OMM.Flock(e, i);
            e.flocks.push(r), e.mainEl.add(r.mainEl)
        }
    },
    generateNoise: function(e, t) {
        for (var i = this, r = e * t, n = new Float32Array(r), o = new ImprovedNoise, a = 1, s = 0, l = 0; r > l; l++) n[l] = 0;
        for (var h = 0; 4 > h; h++) {
            for (var l = 0; r > l; l++) {
                var u = l % e,
                    c = ~~(l / e);
                n[l] += o.noise(21 * u / a + i.ballNoiseOffX, 21 * c / a + i.ballNoiseOffX, s) * a * 1.75
            }
            a *= 5
        }
        return this.ballNoiseOffX += this.noiseSpeed, n
    },
    onSphereOver: function(e) {
        var t = this;
        if (!this.isEnd)
            if (this.selectedSphere) {
                if (!this.selectedSphere2) {
                    this.selectedFlock2 = e, this.selectedSphere2 = e.sphere, TweenMax.killTweensOf([this.selectedSphere2, this.selectedSphere]);
                    var i;
                    i = 6 == this.sphereMergeCount ? new THREE.Vector3(0, 0, 0) : new THREE.Vector3((this.selectedSphere2.position.x - this.selectedSphere.position.x) / 2 + this.selectedSphere.position.x, (this.selectedSphere2.position.y - this.selectedSphere.position.y) / 2 + this.selectedSphere.position.y, (this.selectedSphere2.position.z - this.selectedSphere.position.z) / 2 + this.selectedSphere.position.z);
                    var r = this.selectedFlock,
                        n = this.selectedFlock2;
                    this.selectedSphere2.scale.x > this.selectedSphere.scale.x && (r = this.selectedFlock2, n = this.selectedFlock), TweenMax.to([r.sphere.scale], 1, {
                        x: r.sphere.scale.x + .5 * n.sphere.scale.x,
                        y: r.sphere.scale.y + .5 * n.sphere.scale.y,
                        z: r.sphere.scale.z + .5 * n.sphere.scale.z,
                        ease: Expo.easeOut,
                        delay: 1
                    }), TweenMax.to([this.selectedSphere.rotation, this.selectedSphere2.rotation], 2, {
                        y: Math.random() * Math.PI * 2,
                        ease: Expo.easeInOut
                    }), TweenMax.to([this.selectedSphere.position, this.selectedSphere2.position], 2, {
                        x: i.x,
                        y: i.y,
                        z: i.z,
                        ease: Expo.easeInOut,
                        onComplete: function() {
                            t.selectedSphere2 = null, t.selectedSphere = null, t.selectedFlock = null, t.selectedFlock = null, t.mainEl.remove(n.mainEl), t.mainEl.remove(t.line), r.isSphereOver = !1, t.line = null
                        }
                    }), this.sphereMergeCount++, site.updateProgress(2 / 3 + this.sphereMergeCount / 7 / 3), 7 == this.sphereMergeCount ? (r.isSphereOver = !0, TweenMax.delayedCall(1.2, function() {
                        soundManager.play("chap3End")
                    }), this.isEnd = !0, site.openEnd()) : TweenMax.delayedCall(1.2, function() {
                        soundManager.play("chap3Note" + Math.floor(7 * Math.random()))
                    }), soundManager.play("chap3Note" + Math.floor(7 * Math.random()))
                }
            } else {
                for (var o = new THREE.Geometry, a = 0; 2 > a; a++) o.vertices.push(new THREE.Vector3(e.sphere.position.x, e.sphere.position.y, e.sphere.position.z));
                o.dynamic = !0, this.line = new THREE.Line(o, new THREE.LineBasicMaterial({
                    color: 0,
                    linewidth: 1,
                    opacity: .5,
                    transparent: !0
                })), this.mainEl.add(this.line), this.selectedSphere = e.sphere, this.selectedFlock = e, soundManager.play("chap3Note" + Math.floor(7 * Math.random()))
            }
    },
    removeFlock: function(e) {
        this.flocks.splice(e.ident, 1)
    },
    onFlockOver: function() {
        var e = this;
        this.flockOverCount++, site.updateProgress(1 / 3 + this.flockOverCount / 160 / 3), 160 == this.flockOverCount && (soundManager.stop("chap2Loop1"), soundManager.play("chap3Loop1", {
            loops: 1e4
        }), site.onChapter2End(), TweenMax.delayedCall(5, function() {
            site.openChap3()
        }));
        for (var t = 0; t < e.flocks.length; t++) e.flocks[t].isOver || e.flocks[t].onFlockOver()
    },
    getChap21: function() {
        var e = this;
        e.isChapter21Done = !0, e.hitPlane = new THREE.Mesh(new THREE.PlaneGeometry(3200, 1800, 1, 1), new THREE.MeshBasicMaterial({
            color: 16711680,
            depthWrite: !1,
            depthTest: !1,
            opacity: 0,
            transparent: !0
        })), e.mainEl.add(e.hitPlane)
    },
    animateIn: function(e) {
        var t = this;
        this.callback = e, this.shouldLoop = !0, t.loop()
    },
    animateOut: function() {
        var e = this
    },
    loop: function() {
        var e = this;
        if (this.shouldLoop) {
            this.data = this.generateNoise(21, 21);
            for (var t = 0; t < e.flocks.length; t++) e.flocks[t].update();
            if (this.hitPlane)
                if (this.hitPlane.lookAt(site.world.camera.position), this.selectedSphere && !this.selectedSphere2) {
                    var i = site.world.raycaster.intersectObjects([this.hitPlane]);
                    i.length > 0 && (e.line.geometry.vertices[0].x = e.selectedSphere.position.x, e.line.geometry.vertices[0].y = e.selectedSphere.position.y, e.line.geometry.vertices[0].z = e.selectedSphere.position.z, e.line.geometry.vertices[1].x = i[0].point.x, e.line.geometry.vertices[1].y = i[0].point.y, e.line.geometry.vertices[1].z = i[0].point.z, e.line.geometry.verticesNeedUpdate = !0)
                } else this.selectedSphere2 && this.selectedSphere && (e.line.geometry.vertices[0].x = e.selectedSphere.position.x, e.line.geometry.vertices[0].y = e.selectedSphere.position.y, e.line.geometry.vertices[0].z = e.selectedSphere.position.z, e.line.geometry.vertices[1].x = e.selectedSphere2.position.x, e.line.geometry.vertices[1].y = e.selectedSphere2.position.y, e.line.geometry.vertices[1].z = e.selectedSphere2.position.z, e.line.geometry.verticesNeedUpdate = !0)
        }
    }
};
var OMM = OMM || {};
OMM.Flock = function(e, t) {
    this.ctx = e, this.ident = t, this.init()
}, OMM.Flock.prototype = {
    init: function() {
        var e = this;
        this.mainEl = new THREE.Object3D;
        for (var t = new THREE.MeshPhongMaterial({
                color: 0,
                shading: THREE.FlatShading,
                transparent: !0
            }), i = 20 * Math.random() + 7, r = new THREE.BoxGeometry(i, i, i), n = 0; n < r.vertices.length; n++) r.vertices[n].x += (Math.random() - .5) * i, r.vertices[n].y += (Math.random() - .5) * i, r.vertices[n].z += (Math.random() - .5) * i;
        r.computeFaceNormals(), r.computeVertexNormals(), this.mesh = new THREE.Mesh(r, t), e.mainEl.add(this.mesh), this.hitMesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(50, 50, 1, 1), new THREE.MeshBasicMaterial({
            color: 16711680,
            opacity: 0,
            transparent: !0
        })), this.mainEl.add(this.hitMesh), this.boid = new Boid, this.boid.position.x = 200 * Math.random() - 100, this.boid.position.y = 200 * Math.random() - 100, this.boid.position.z = 200 * Math.random() - 100, this.boid.velocity.x = 30 * Math.random() - 15, this.boid.velocity.y = 30 * Math.random() - 15, this.boid.velocity.z = 30 * Math.random() - 15, this.boid.setAvoidWalls(!0), this.boid.setWorldSize(600, 600, 600), this.ctx.boids.push(this.boid), this.mesh.position.x = this.boid.position.x, this.mesh.position.y = this.boid.position.y, this.mesh.position.z = this.boid.position.z, this.hitMesh.position.x = this.boid.position.x, this.hitMesh.position.y = this.boid.position.y, this.hitMesh.position.z = this.boid.position.z;
        var o = new THREE.Geometry;
        o.vertices.push(new THREE.Vector3(0, 0, 0));
        for (var a = 0; 100 > a; a++) o.vertices.push(new THREE.Vector3(0, 0, 0));
        if (o.dynamic = !0, this.line = new THREE.Line(o, new THREE.LineBasicMaterial({
                color: 0,
                linewidth: 1,
                opacity: .1,
                transparent: !0
            })), this.mainEl.add(this.line), this.ident % 20 == 0) {
            this.isLegit = !0;
            var s = THREE.FresnelShader,
                l = THREE.UniformsUtils.clone(s.uniforms);
            l.tCube.value = e.ctx.envMap;
            var h = {
                    fragmentShader: s.fragmentShader,
                    vertexShader: s.vertexShader,
                    uniforms: l
                },
                u = new THREE.MeshPhongMaterial({
                    color: 16777215,
                    transparent: !0,
                    opacity: .5,
                    shininess: 100
                });
            this.fresnelMaterial = new THREE.ShaderMaterial({
                uniforms: l,
                vertexShader: s.vertexShader,
                fragmentShader: s.fragmentShader,
                opacity: .5,
                transparent: !0
            });
            var c = new THREE.SphereGeometry(20 * Math.random() + 80, 20, 20);
            c.dynamic = !0, this.sphere = new THREE.Mesh(c, this.fresnelMaterial), this.sphere.rotation.y = Math.random() * Math.PI * 2, this.orVertices = [];
            for (var p = c.vertices.length; p--;) e.orVertices.push(c.vertices[p].clone())
        }
    },
    onFlockOver: function() {
        this.hitMesh.scale.x += .02, this.hitMesh.scale.y += .02, this.hitMesh.scale.z += .02
    },
    update: function() {
        var e = this;
        if (this.isOver) {
            if (this.isLegit) {
                for (var t = e.sphere.geometry.vertices.length; t--;) {
                    var i = e.sphere.geometry.vertices[t],
                        r = t;
                    t > e.sphere.geometry.vertices.length - 21 && (r = e.sphere.geometry.vertices.length - 1), 17 > t && (r = 0), e.sphere.geometry.vertices[t] = e.orVertices[t].clone(), e.sphere.geometry.vertices[t].add(e.orVertices[t].clone().normalize().multiplyScalar(.1 * e.ctx.data[r]))
                }
                if (this.sphere.geometry.verticesNeedUpdate = !0, this.sphere.geometry.normalsNeedUpdate = !0, this.sphere.geometry.computeFaceNormals(), this.sphere.geometry.computeVertexNormals(), this.ctx.isChapter21Done)
                    if (e.isSphereOver || this.ctx.selectedSphere && this.ctx.selectedSphere2) this.INTERSECTED = null;
                    else {
                        var n = site.world.raycaster.intersectObjects([this.sphere]);
                        n.length > 0 && this.INTERSECTED != n[0].object ? (this.INTERSECTED = n[0].object, TweenMax.killTweensOf(e.sphere), e.ctx.onSphereOver(e), e.isSphereOver = !0) : this.INTERSECTED = null
                    }
            }
        } else {
            e.boid.run(e.ctx.boids), this.mesh.rotation.y = Math.atan2(-this.boid.velocity.z, this.boid.velocity.x), this.mesh.rotation.z = Math.asin(this.boid.velocity.y / this.boid.velocity.length()), this.mesh.position.x = this.boid.position.x, this.mesh.position.y = this.boid.position.y, this.mesh.position.z = this.boid.position.z, this.hitMesh.position.x = this.boid.position.x, this.hitMesh.position.y = this.boid.position.y, this.hitMesh.position.z = this.boid.position.z;
            for (var o = 1; o < this.line.geometry.vertices.length; o++) e.line.geometry.vertices[o].x += (e.boid.position.x - e.line.geometry.vertices[o].x) * (o / e.line.geometry.vertices.length), e.line.geometry.vertices[o].y += (e.boid.position.y - e.line.geometry.vertices[o].y) * (o / e.line.geometry.vertices.length), e.line.geometry.vertices[o].z += (e.boid.position.z - e.line.geometry.vertices[o].z) * (o / e.line.geometry.vertices.length);
            if (e.line.geometry.verticesNeedUpdate = !0, e.ctx.isActive) {
                var n = site.world.raycaster.intersectObjects([this.hitMesh]);
                n.length > 0 ? this.INTERSECTED != n[0].object && (this.isOver = !0, this.vel = new THREE.Vector3(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z), this.isLegit ? (this.vel = new THREE.Vector3(1500 * (Math.random() - .5), 700 * (Math.random() - .5), 700 * (Math.random() - .5)), e.mainEl.remove(e.hitMesh), TweenMax.to([this.line.material], 2, {
                    opacity: 0,
                    delay: 2
                }), TweenMax.to(this.mesh.position, 4, {
                    x: this.vel.x,
                    y: this.vel.y,
                    z: this.vel.z,
                    ease: Circ.easeOut,
                    onUpdate: function() {
                        for (var t = 0; t < e.line.geometry.vertices.length; t++) {
                            var i = t + 1;
                            i > e.line.geometry.vertices.length && (i = e.line.geometry.vertices.length), e.line.geometry.vertices[t].x += (e.mesh.position.x - e.line.geometry.vertices[t].x) * (i / e.line.geometry.vertices.length), e.line.geometry.vertices[t].y += (e.mesh.position.y - e.line.geometry.vertices[t].y) * (i / e.line.geometry.vertices.length), e.line.geometry.vertices[t].z += (e.mesh.position.z - e.line.geometry.vertices[t].z) * (i / e.line.geometry.vertices.length)
                        }
                        e.line.geometry.verticesNeedUpdate = !0
                    },
                    onComplete: function() {
                        TweenMax.to(e.mesh.scale, 1, {
                            x: 3,
                            y: 3,
                            z: 3,
                            ease: Expo.easeOut
                        }), TweenMax.to(e.mesh.material, 1, {
                            opacity: 0,
                            ease: Expo.easeOut
                        }), e.sphere.position.x = e.mesh.position.x, e.sphere.position.y = e.mesh.position.y, e.sphere.position.z = e.mesh.position.z, soundManager.play("chap3Note" + Math.floor(7 * Math.random())), TweenMax.fromTo(e.sphere.scale, 1, {
                            x: .1,
                            y: .1,
                            z: .1
                        }, {
                            x: 1,
                            y: 1,
                            z: 1,
                            ease: Expo.easeOut
                        }), e.mainEl.add(e.sphere), e.mainEl.remove(e.line), TweenMax.to(e.sphere.position, 10, {
                            bezier: {
                                type: "soft",
                                values: [{
                                    x: e.vel.x + 600 * (Math.random() - .5),
                                    y: .7 * e.vel.y + 200 * (Math.random() - .5),
                                    z: .7 * e.vel.z + 400 * (Math.random() - .5)
                                }, {
                                    x: e.vel.x + 600 * (Math.random() - .5),
                                    y: .7 * e.vel.y + 200 * (Math.random() - .5),
                                    z: .7 * e.vel.z + 400 * (Math.random() - .5)
                                }, {
                                    x: e.vel.x + 600 * (Math.random() - .5),
                                    y: .7 * e.vel.y + 200 * (Math.random() - .5),
                                    z: .7 * e.vel.z + 400 * (Math.random() - .5)
                                }, {
                                    x: e.vel.x,
                                    y: e.vel.y,
                                    z: e.vel.z
                                }]
                            },
                            repeat: -1,
                            ease: Sine.easeInOut
                        })
                    }
                })) : (this.vel.normalize().multiplyScalar(1500), e.mainEl.remove(e.hitMesh), TweenMax.to([this.mesh.material, this.line.material], 2, {
                    opacity: 0,
                    delay: 1
                }), TweenMax.to(this.mesh.position, 3, {
                    x: this.vel.x,
                    y: this.vel.y,
                    z: this.vel.z,
                    ease: Circ.easeOut,
                    onUpdate: function() {
                        for (var t = 0; t < e.line.geometry.vertices.length; t++) {
                            var i = t + 1;
                            i > e.line.geometry.vertices.length && (i = e.line.geometry.vertices.length), e.line.geometry.vertices[t].x += (e.mesh.position.x - e.line.geometry.vertices[t].x) * (i / e.line.geometry.vertices.length), e.line.geometry.vertices[t].y += (e.mesh.position.y - e.line.geometry.vertices[t].y) * (i / e.line.geometry.vertices.length), e.line.geometry.vertices[t].z += (e.mesh.position.z - e.line.geometry.vertices[t].z) * (i / e.line.geometry.vertices.length)
                        }
                        e.line.geometry.verticesNeedUpdate = !0
                    },
                    onComplete: function() {
                        e.mainEl.remove(e.mesh), e.mainEl.remove(e.line)
                    }
                })), this.INTERSECTED = n[0].object, e.ctx.onFlockOver()) : this.INTERSECTED = null
            }
        }
    }
};
var OMM = OMM || {};
OMM.Site = function() {
    this.init()
}, OMM.Site.prototype = {
    init: function() {
        var e = this;
        this.loader = new PxLoader, this.wrapper = (new H.Element).addStyle({
            position: "absolute",
            top: "0px",
            left: "0px",
            width: "100%",
            height: "100%",
            overflow: "hidden"
        }).addTo(document.body), this.loaderTexBg1 = this.loader.addTexture("assets/bg/bg1.jpg"), this.loaderTexBg2 = this.loader.addTexture("assets/bg/bg22.jpg"), this.loaderTexDirt = this.loader.addTexture("assets/textures/dirt_spec.jpg"), this.loaderTexLens1 = this.loader.addTexture("assets/textures/lensflare/lensflare0.png"), this.loaderTexLens2 = this.loader.addTexture("assets/textures/lensflare/lensflare2.png"), this.loaderTexLens3 = this.loader.addTexture("assets/textures/lensflare/hexangle.png"), soundManager.setup({
            url: "js/libs/soundManager2/",
            flashVersion: 9,
            useHighPerformance: !0,
            flashLoadTimeout: 500,
            debugMode: !1,
            onready: function() {
                soundManager.createSound({
                    id: "chap1Intro",
                    url: "assets/audio/chapter1/FXIntroOmm2" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap1Intro2",
                    url: "assets/audio/chapter1/FXIntroOmm4" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap1Loop1",
                    url: "assets/audio/chapter1/introOmm" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap1Loop2",
                    url: "assets/audio/chapter1/introOmm3" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap1Loop3",
                    url: "assets/audio/chapter1/introOmm5" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap1Out",
                    url: "assets/audio/chapter1/FxintroOmm4" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap1chap2",
                    url: "assets/audio/chapter1/pajaro1omm" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap1Over",
                    url: "assets/audio/chapter1/FXloop1" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap1Over2",
                    url: "assets/audio/chapter1/FXloop5" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap2Loop1",
                    url: "assets/audio/chapter2/Part2ommLoop" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap3Loop1",
                    url: "assets/audio/chapter3/loopPianoOMM" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap3Note0",
                    url: "assets/audio/chapter3/Do1" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap3Note1",
                    url: "assets/audio/chapter3/Fa1" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap3Note2",
                    url: "assets/audio/chapter3/La1" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap3Note3",
                    url: "assets/audio/chapter3/Mi1" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap3Note4",
                    url: "assets/audio/chapter3/Re1" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap3Note5",
                    url: "assets/audio/chapter3/Si1" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap3Note6",
                    url: "assets/audio/chapter3/Sol1" + H.soundExt,
                    autoLoad: !0
                }), soundManager.createSound({
                    id: "chap3End",
                    url: "assets/audio/chapter3/notaPianoLoopOMM" + H.soundExt,
                    autoLoad: !0
                }), e.loader.start()
            },
            ontimeout: function() {
                soundManager.useHTML5Audio = !0, soundManager.preferFlash = !1, soundManager.reboot()
            }
        }), soundManager.defaultOptions = {
            multiShot: !0
        }, this.loader.addCompletionListener($.proxy(this.onLoaded, this)), this.loader.addProgressListener(function(e) {
            var t = e.completedCount / e.totalCount
        }), console.log(""), console.log(""), console.log(" .oOOOo.  Oo      oO Oo      oO"), console.log(".O     o. O O    o o O O    o o"), console.log("O       o o  o  O  O o  o  O  O"), console.log("o       O O   Oo   O O   Oo   O"), console.log("O       o O        o O        o"), console.log("o       O o        O o        O"), console.log("`o     O' o        O o        O"), console.log(" `OoooO'  O        o O        o"), console.log(""), console.log("J e a n   H e l f e  n s t e i n"), console.log(""), console.log("")
    },
    onLoaded: function() {
        var e = this;
        this.world = new OMM.World, this.wrapper.add(this.world.mainEl), this.chapter1 = new OMM.Chapter1, this.world.scene.add(this.chapter1.mainEl), this.chap1Overlay = (new H.Element).addStyle({
            position: "absolute",
            top: "0px",
            left: "0px",
            width: "100%",
            height: "100%",
            backgroundColor: "#000000",
            zIndex: "9999",
            opacity: "0",
            visibility: "hidden"
        }).addTo(this.wrapper), this.chap1Title = (new H.Element).addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            width: "500px",
            marginLeft: "-250px",
            color: "rgba(255,255,255,0.6)",
            fontFamily: "Roboto Slab,serif",
            fontWeight: "100",
            fontSize: "20px",
            letterSpacing: "2px",
            textAlign: "center",
            marginTop: "-200px"
        }).addTo(this.chap1Overlay), this.chap1Title.el.innerHTML = "Chapter I", this.chap1SubTitle = (new H.Element).addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            width: "500px",
            marginLeft: "-250px",
            color: "rgba(255,255,255,1)",
            fontFamily: "Roboto Slab,serif",
            fontWeight: "100",
            fontSize: "36px",
            letterSpacing: "5px",
            textAlign: "center",
            marginTop: "-170px"
        }).addTo(this.chap1Overlay), this.chap1SubTitle.el.innerHTML = "Extract", this.chap1Quote = (new H.Element).addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            width: "500px",
            marginLeft: "-250px",
            color: "rgba(255,255,255,0.5)",
            fontStyle: "italic",
            fontFamily: "Roboto Slab,serif",
            fontWeight: "100",
            fontSize: "16px",
            letterSpacing: "5px",
            textAlign: "center",
            marginTop: "-20px"
        }).addTo(this.chap1Overlay), this.chap1Quote.el.innerHTML = '"Everyactof creation is first of all anactof destruction."', this.chap1QuoteAuthor = (new H.Element).addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            width: "500px",
            marginLeft: "-250px",
            color: "rgba(255,255,255,1)",
            fontStyle: "italic",
            fontFamily: "Roboto Slab,serif",
            fontWeight: "100",
            fontSize: "12px",
            letterSpacing: "5px",
            textAlign: "center",
            marginTop: "40px"
        }).addTo(this.chap1Overlay), this.chap1QuoteAuthor.el.innerHTML = "- Pablo Picasso", this.chap1Cursor = (new H.Element).addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            marginLeft: "-21px",
            marginTop: "110px"
        }).addTo(this.chap1Overlay), this.chap1CursorCircle = (new H.Element).addStyle({
            position: "absolute",
            top: "-12px",
            left: "-3px",
            width: "30px",
            height: "30px",
            borderRadius: "50%",
            border: "4px solid #fff"
        }).addTo(this.chap1Cursor), this.chap1CursorIcon = new H.ImageElement("assets/cursor.png").addStyle({
            position: "absolute"
        }).addTo(this.chap1Cursor), this.chap1CursorInfos = (new H.Element).addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            width: "500px",
            marginLeft: "-250px",
            color: "rgba(255,255,255,0.5)",
            fontFamily: "Roboto Slab,serif",
            fontWeight: "100",
            fontSize: "11px",
            letterSpacing: "2px",
            textAlign: "center",
            marginTop: "170px"
        }).addTo(this.chap1Overlay), this.chap1CursorInfos.el.innerHTML = "Click Repeatedly", this.chap2Cursor = (new H.Element).addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            marginLeft: "-21px",
            marginTop: "110px"
        }), this.chap2CursorPart1 = new H.ImageElement("assets/particle1.png").addStyle({
            position: "absolute",
            top: "-20px",
            left: "-50px"
        }).addTo(this.chap2Cursor), this.chap2CursorPart2 = new H.ImageElement("assets/particle2.png").addStyle({
            position: "absolute",
            top: "10px",
            left: "55px"
        }).addTo(this.chap2Cursor), this.chap2CursorIcon = new H.ImageElement("assets/cursor.png").addStyle({
            position: "absolute"
        }).addTo(this.chap2Cursor), this.chap2CursorInfos = (new H.Element).addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            width: "500px",
            marginLeft: "-250px",
            color: "rgba(255,255,255,0.5)",
            fontFamily: "Roboto Slab,serif",
            fontWeight: "100",
            fontSize: "11px",
            letterSpacing: "2px",
            textAlign: "center",
            marginTop: "170px"
        }), this.chap2CursorInfos.el.innerHTML = "Mouse Over Particles", this.chap3Cursor = (new H.Element).addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            marginLeft: "-21px",
            marginTop: "110px"
        }), this.chap3CursorPart1 = new H.ImageElement("assets/buble1.png").addStyle({
            position: "absolute",
            top: "-20px",
            left: "-30px",
            marginLeft: "-20px",
            marginTop: "-20px"
        }).addTo(this.chap3Cursor), this.chap3CursorPart2 = new H.ImageElement("assets/buble2.png").addStyle({
            position: "absolute",
            top: "-20px",
            left: "70px",
            marginLeft: "-20px",
            marginTop: "-20px"
        }).addTo(this.chap3Cursor), this.chap3CursorIcon = new H.ImageElement("assets/cursor.png").addStyle({
            position: "absolute"
        }).addTo(this.chap3Cursor), this.chap3CursorInfos = (new H.Element).addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            width: "500px",
            marginLeft: "-250px",
            color: "rgba(255,255,255,0.5)",
            fontFamily: "Roboto Slab,serif",
            fontWeight: "100",
            fontSize: "11px",
            letterSpacing: "2px",
            textAlign: "center",
            marginTop: "170px"
        }), this.chap3CursorInfos.el.innerHTML = "Mouse Over 2 Bubles to Connect", this.chapter2 = new OMM.Chapter2, this.logo = new H.ImageElement("assets/logo.png").addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            marginLeft: "-300px",
            marginTop: "-30px",
            zIndex: "999",
            opacity: "0"
        }).addTo(this.wrapper), this.logoBlack = new H.ImageElement("assets/logoBlack.png").addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            marginLeft: "-100px",
            marginTop: "-30px",
            zIndex: "999",
            opacity: "0",
            visibility: "hidden"
        }).addTo(this.wrapper), this.by = (new H.Element).addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            width: "500px",
            marginLeft: "-250px",
            marginTop: "50px",
            zIndex: "999",
            color: "rgba(0,0,0,0.5)",
            fontFamily: "Futura,sans-serif",
            fontSize: "13px",
            letterSpacing: "3px",
            textAlign: "center",
            fontWeight: "100",
            opacity: "0",
            visibility: "hidden",
            cursor: "pointer"
        }).addTo(this.wrapper), this.by.el.innerHTML = "BY JEAN HELFENSTEIN", $(this.by.el).hover(function() {
            TweenMax.to(this, .5, {
                color: "rgba(0,0,0,1)"
            })
        }, function() {
            TweenMax.to(this, .5, {
                color: "rgba(0,0,0,0.5)"
            })
        }), $(this.by.el).click(function() {
            window.open("http://www.jeanhelfenstein.com/", "_blank")
        }), this.bestChrome = (new H.Element).addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            width: "500px",
            marginLeft: "-248px",
            marginTop: "50px",
            zIndex: "999",
            color: "rgba(255,255,255,0.5)",
            fontFamily: "Futura,sans-serif",
            fontSize: "11px",
            letterSpacing: "3px",
            textAlign: "center",
            fontWeight: "100",
            opacity: "0",
            visibility: "hidden"
        }).addTo(this.wrapper), this.bestChrome.el.innerHTML = "BEST VIEWED IN CHROME", isMobile.any() && (this.bestChrome.el.innerHTML = "OPTIMIZED FOR DESKTOP"), this.creditsBtn = (new H.Element).addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            width: "500px",
            marginLeft: "-250px",
            marginTop: "90px",
            zIndex: "999",
            color: "rgba(0,0,0,1)",
            fontFamily: "Futura,sans-serif",
            fontSize: "13px",
            letterSpacing: "3px",
            textAlign: "center",
            fontWeight: "100",
            cursor: "pointer",
            opacity: "0",
            visibility: "hidden"
        }).addTo(this.wrapper), this.creditsBtn.el.innerHTML = "+ CREDITS", $(this.creditsBtn.el).click(function() {
            e.isCreditOpen ? (e.isCreditOpen = !1, TweenMax.to(e.logoBlack.el, 1, {
                marginTop: "-30px",
                ease: Expo.easeInOut
            }), TweenMax.to(e.by.el, 1, {
                marginTop: "50px",
                ease: Expo.easeInOut
            }), TweenMax.to(e.credits.el, 1, {
                marginTop: "80px",
                height: "0px",
                ease: Expo.easeInOut
            }), TweenMax.to(e.creditsBtn.el, 1, {
                marginTop: "90px",
                ease: Expo.easeInOut
            }), e.creditsBtn.el.innerHTML = "+ CREDITS", e.world.unblur()) : (e.isCreditOpen = !0, TweenMax.to(e.logoBlack.el, 1, {
                marginTop: "-310px",
                ease: Expo.easeInOut
            }), TweenMax.to(e.by.el, 1, {
                marginTop: "-230px",
                ease: Expo.easeInOut
            }), TweenMax.to(e.credits.el, 1, {
                marginTop: "-250px",
                height: "500px",
                ease: Expo.easeInOut
            }), TweenMax.to(e.creditsBtn.el, 1, {
                marginTop: "210px",
                ease: Expo.easeInOut
            }), e.creditsBtn.el.innerHTML = "- CREDITS", TweenMax.set(e.credits.el, {
                autoAlpha: 1
            }), e.world.blur())
        }), $(this.creditsBtn.el).hover(function() {
            TweenMax.to(e.creditsBtn.el, .5, {
                opacity: .5
            })
        }, function() {
            TweenMax.to(e.creditsBtn.el, .5, {
                opacity: 1
            })
        }), this.credits = (new H.Element).addStyle({
            position: "absolute",
            top: "50%",
            left: "50%",
            width: "500px",
            marginLeft: "-250px",
            marginTop: "80px",
            zIndex: "990",
            color: "rgba(255,255,255,1)",
            fontFamily: "Futura,sans-serif",
            fontSize: "13px",
            letterSpacing: "3px",
            textAlign: "center",
            fontWeight: "100",
            overflow: "hidden",
            height: "0px",
            opacity: "0",
            visibility: "hidden"
        }).addTo(this.wrapper), this.creditsContainer = (new H.Element).addStyle({
            position: "absolute",
            width: "500px",
            height: "500px",
            left: "0px",
            top: "50%",
            marginTop: "-250px"
        }).addTo(this.credits), this.musicBy = (new H.Element).addStyle({
            position: "relative",
            width: "100%",
            textAlign: "center",
            fontFamily: "Futura,sans-serif",
            fontSize: "13px",
            color: "#000",
            fontWeight: "200",
            letterspacing: "2px",
            marginTop: "80px"
        }).addTo(this.creditsContainer), this.musicBy.el.innerHTML = "SOUND DESIGN BY", this.musicAuthor = (new H.Element).addStyle({
            position: "relative",
            width: "100%",
            textAlign: "center",
            fontFamily: "Futura,sans-serif",
            fontSize: "13px",
            color: "rgba(0,0,0,0.5)",
            fontWeight: "200",
            letterspacing: "2px",
            marginTop: "20px",
            textTransform: "uppercase",
            cursor: "pointer"
        }).addTo(this.creditsContainer), this.musicAuthor.el.innerHTML = "Carlos Torrecilla", $(this.musicAuthor.el).hover(function() {
            TweenMax.to(this, .5, {
                color: "rgba(0,0,0,1)"
            })
        }, function() {
            TweenMax.to(this, .5, {
                color: "rgba(0,0,0,0.5)"
            })
        }), $(this.musicAuthor.el).click(function() {
            window.open("http://www.carlostorrecilla.es/", "_blank")
        }), this.library = (new H.Element).addStyle({
            position: "relative",
            width: "100%",
            textAlign: "center",
            fontFamily: "Futura,sans-serif",
            fontSize: "13px",
            color: "#000",
            fontWeight: "200",
            letterspacing: "2px",
            marginTop: "50px"
        }).addTo(this.creditsContainer), this.library.el.innerHTML = "LIBRARIES USED", this.library1 = (new H.Element).addStyle({
            position: "relative",
            width: "100%",
            textAlign: "center",
            fontFamily: "Futura,sans-serif",
            fontSize: "13px",
            color: "rgba(0,0,0,0.5)",
            fontWeight: "200",
            letterspacing: "2px",
            marginTop: "20px",
            textTransform: "uppercase",
            cursor: "pointer"
        }).addTo(this.creditsContainer), this.library1.el.innerHTML = "MR DOOB'S THREE.JS", $(this.library1.el).hover(function() {
            TweenMax.to(this, .5, {
                color: "rgba(0,0,0,1)"
            })
        }, function() {
            TweenMax.to(this, .5, {
                color: "rgba(0,0,0,0.5)"
            })
        }), $(this.library1.el).click(function() {
            window.open("http://threejs.org/", "_blank")
        }), this.library2 = (new H.Element).addStyle({
            position: "relative",
            width: "100%",
            textAlign: "center",
            fontFamily: "Futura,sans-serif",
            fontSize: "13px",
            color: "rgba(0,0,0,0.5)",
            fontWeight: "200",
            letterspacing: "2px",
            marginTop: "10px",
            textTransform: "uppercase",
            cursor: "pointer"
        }).addTo(this.creditsContainer), this.library2.el.innerHTML = "GREENSOCK TWEENMAX", $(this.library2.el).hover(function() {
            TweenMax.to(this, .5, {
                color: "rgba(0,0,0,1)"
            })
        }, function() {
            TweenMax.to(this, .5, {
                color: "rgba(0,0,0,0.5)"
            })
        }), $(this.library2.el).click(function() {
            window.open("http://greensock.com/tweenmax", "_blank")
        }), this.thanks = (new H.Element).addStyle({
            position: "relative",
            width: "100%",
            textAlign: "center",
            fontFamily: "Futura,sans-serif",
            fontSize: "13px",
            color: "#000",
            fontWeight: "200",
            letterspacing: "2px",
            marginTop: "50px"
        }).addTo(this.creditsContainer), this.thanks.el.innerHTML = "SPECIAL THANKS TO", this.thanks1 = (new H.Element).addStyle({
            position: "relative",
            width: "100%",
            textAlign: "center",
            fontFamily: "Futura,sans-serif",
            fontSize: "13px",
            color: "rgba(0,0,0,0.5)",
            fontWeight: "200",
            letterspacing: "2px",
            marginTop: "20px",
            textTransform: "uppercase",
            cursor: "pointer"
        }).addTo(this.creditsContainer), this.thanks1.el.innerHTML = "IVA ILIEVA", $(this.thanks1.el).hover(function() {
            TweenMax.to(this, .5, {
                color: "rgba(0,0,0,1)"
            })
        }, function() {
            TweenMax.to(this, .5, {
                color: "rgba(0,0,0,0.5)"
            })
        }), $(this.thanks1.el).click(function() {
            window.open("http://ivailieva.com/", "_blank")
        }), this.thanks2 = (new H.Element).addStyle({
            position: "relative",
            width: "100%",
            textAlign: "center",
            fontFamily: "Futura,sans-serif",
            fontSize: "13px",
            color: "rgba(0,0,0,0.5)",
            fontWeight: "200",
            letterspacing: "2px",
            marginTop: "10px",
            textTransform: "uppercase",
            cursor: "pointer"
        }).addTo(this.creditsContainer), this.thanks2.el.innerHTML = "HERRAIZ SOTO & CO.", $(this.thanks2.el).hover(function() {
            TweenMax.to(this, .5, {
                color: "rgba(0,0,0,1)"
            })
        }, function() {
            TweenMax.to(this, .5, {
                color: "rgba(0,0,0,0.5)"
            })
        }), $(this.thanks2.el).click(function() {
            window.open("http://www.herraizsoto.com/", "_blank")
        }), this.timeline = (new H.Element).addStyle({
            position: "absolute",
            bottom: "30px",
            left: "10%",
            width: "80%",
            zIndex: "999",
            opacity: "0",
            visibility: "hidden"
        }).addTo(this.wrapper), this.timelineC1 = (new H.Element).addStyle({
            position: "absolute",
            top: "-36px",
            left: "16.66666%",
            color: "rgba(255,255,255,0.3)",
            fontFamily: "Roboto Slab,serif",
            fontWeight: "100",
            fontSize: "16px",
            letterSpacing: "2px",
            textAlign: "center",
            width: "100px",
            marginLeft: "-50px",
            pointerEvents: "none"
        }).addTo(this.timeline).addClass("unselect"), this.timelineC1.el.innerHTML = "I", this.timelineC2 = (new H.Element).addStyle({
            position: "absolute",
            top: "-36px",
            left: "50%",
            color: "rgba(255,255,255,0.3)",
            fontFamily: "Roboto Slab,serif",
            fontWeight: "100",
            fontSize: "16px",
            letterSpacing: "2px",
            textAlign: "center",
            width: "100px",
            marginLeft: "-50px",
            pointerEvents: "none"
        }).addTo(this.timeline).addClass("unselect"), this.timelineC2.el.innerHTML = "II", this.timelineC3 = (new H.Element).addStyle({
            position: "absolute",
            top: "-36px",
            left: "83.33333333%",
            color: "rgba(255,255,255,0.3)",
            fontFamily: "Roboto Slab,serif",
            fontWeight: "100",
            fontSize: "16px",
            letterSpacing: "2px",
            textAlign: "center",
            width: "100px",
            marginLeft: "-50px",
            pointerEvents: "none"
        }).addTo(this.timeline).addClass("unselect"), this.timelineC3.el.innerHTML = "III", this.timelineBG = (new H.Element).addStyle({
            position: "absolute",
            width: "100%",
            height: "1px",
            backgroundColor: "rgba(220,220,220,0.2)"
        }).addTo(this.timeline), this.timelineProg = (new H.Element).addStyle({
            position: "absolute",
            width: "0%",
            height: "1px",
            backgroundColor: "rgba(220,220,220,1)"
        }).addTo(this.timeline), this.timelineDot1 = (new H.Element).addStyle({
            position: "absolute",
            top: "0px",
            left: "0%",
            width: "8px",
            height: "8px",
            marginLeft: "-4px",
            marginTop: "-4px",
            borderRadius: "50%",
            backgroundColor: "rgba(220,220,220,1)"
        }).addTo(this.timeline), this.timelineDot2 = (new H.Element).addStyle({
            position: "absolute",
            top: "0px",
            left: "33.33333%",
            width: "4px",
            height: "4px",
            marginLeft: "-2px",
            marginTop: "-2px",
            borderRadius: "50%",
            backgroundColor: "rgba(220,220,220,1)"
        }).addTo(this.timeline), this.timelineDot3 = (new H.Element).addStyle({
            position: "absolute",
            top: "0px",
            left: "66.666666%",
            width: "4px",
            height: "4px",
            marginLeft: "-2px",
            marginTop: "-2px",
            borderRadius: "50%",
            backgroundColor: "rgba(220,220,220,1)"
        }).addTo(this.timeline), this.timelineDot4 = (new H.Element).addStyle({
            position: "absolute",
            top: "0px",
            left: "100%",
            width: "4px",
            height: "4px",
            marginLeft: "-2px",
            marginTop: "-2px",
            borderRadius: "50%",
            backgroundColor: "rgba(220,220,220,1)"
        }).addTo(this.timeline), $(window).resize($.proxy(this.resize, this)), this.resize(), this.shouldLoop = !0, this.loop(), TweenMax.to(this.logo.el, 2, {
            opacity: 1
        }), TweenMax.to(this.world.mainEl.el, 4, {
            opacity: 1,
            delay: 3
        }), TweenMax.to(this.logo.el, 2, {
            autoAlpha: 0,
            delay: 9
        }), ("webkit" != H.vendor || H.isSafari || isMobile.any()) && (TweenMax.to(this.bestChrome.el, 2, {
            autoAlpha: 1,
            delay: .5
        }), TweenMax.to(this.bestChrome.el, 2, {
            autoAlpha: 0,
            delay: 9
        })), TweenMax.delayedCall(14, function() {
            soundManager.play("chap1Intro2"), TweenMax.fromTo(e.chap1CursorCircle.el, 1, {
                opacity: 1,
                scale: 0
            }, {
                opacity: 0,
                scale: 1,
                ease: Sine.easeOut,
                repeat: -1
            }), TweenMax.to(e.chap1Overlay.el, 1, {
                autoAlpha: 1
            }), TweenMax.fromTo(e.chap1Title.el, 2, {
                autoAlpha: 0,
                y: 30
            }, {
                autoAlpha: 1,
                y: 0,
                ease: Expo.easeOut,
                delay: 1
            }), TweenMax.fromTo(e.chap1SubTitle.el, 2, {
                autoAlpha: 0,
                y: 30
            }, {
                autoAlpha: 1,
                y: 0,
                ease: Expo.easeOut,
                delay: 1.1
            }), TweenMax.fromTo(e.chap1Quote.el, 2, {
                autoAlpha: 0,
                y: 30
            }, {
                autoAlpha: 1,
                y: 0,
                ease: Expo.easeOut,
                delay: 1.2
            }), TweenMax.fromTo(e.chap1QuoteAuthor.el, 2, {
                autoAlpha: 0,
                y: 30
            }, {
                autoAlpha: 1,
                y: 0,
                ease: Expo.easeOut,
                delay: 1.3
            }), TweenMax.fromTo(e.chap1Cursor.el, 2, {
                autoAlpha: 0,
                y: 30
            }, {
                autoAlpha: 1,
                y: 0,
                ease: Expo.easeOut,
                delay: 1.4
            }), TweenMax.fromTo(e.chap1CursorInfos.el, 2, {
                autoAlpha: 0,
                y: 30
            }, {
                autoAlpha: 1,
                y: 0,
                ease: Expo.easeOut,
                delay: 1.4
            }), TweenMax.to(e.chap1Title.el, 2, {
                autoAlpha: 0,
                y: -30,
                ease: Expo.easeOut,
                delay: 12
            }), TweenMax.to(e.chap1SubTitle.el, 2, {
                autoAlpha: 0,
                y: -30,
                ease: Expo.easeOut,
                delay: 12.1
            }), TweenMax.to(e.chap1Quote.el, 2, {
                autoAlpha: 0,
                y: -30,
                ease: Expo.easeOut,
                delay: 12.2
            }), TweenMax.to(e.chap1QuoteAuthor.el, 2, {
                autoAlpha: 0,
                y: -30,
                ease: Expo.easeOut,
                delay: 12.3
            }), TweenMax.to(e.chap1Cursor.el, 2, {
                autoAlpha: 0,
                y: -30,
                ease: Expo.easeOut,
                delay: 12.4
            }), TweenMax.to(e.chap1CursorInfos.el, 2, {
                autoAlpha: 0,
                y: -30,
                ease: Expo.easeOut,
                delay: 12.4
            }), TweenMax.delayedCall(13, function() {
                soundManager.play("chap1Intro")
            }), TweenMax.to(e.chap1Overlay.el, 1, {
                autoAlpha: 0,
                delay: 13,
                onComplete: function() {
                    TweenMax.killTweensOf(e.chap1CursorCircle.el), TweenMax.to(e.timeline.el, 2, {
                        autoAlpha: 1
                    }), e.chapter1.animateIn(function() {
                        e.onChapter1End()
                    })
                }
            })
        }), TweenMax.delayedCall(3, function() {
            soundManager.play("chap1Intro"), soundManager.play("chap1Loop1", {
                loops: 1e4
            })
        })
    },
    playChap2Cursor: function() {
        var e = this;
        TweenMax.to(e.chap2CursorIcon.el, .5, {
            x: -45,
            y: -18,
            ease: Expo.easeOut,
            onComplete: function() {
                TweenMax.to(e.chap2CursorPart1.el, .5, {
                    x: -40,
                    y: -15,
                    opacity: 0,
                    ease: Expo.easeOut
                }), TweenMax.to(e.chap2CursorIcon.el, .7, {
                    x: 45,
                    y: 17,
                    delay: .5,
                    ease: Expo.easeOut,
                    onComplete: function() {
                        TweenMax.to(e.chap2CursorPart2.el, .5, {
                            x: 40,
                            y: 15,
                            opacity: 0,
                            ease: Expo.easeOut
                        }), TweenMax.to(e.chap2CursorIcon.el, .7, {
                            x: 0,
                            y: 0,
                            ease: Expo.easeOut,
                            delay: .5,
                            onComplete: function() {
                                TweenMax.set([e.chap2CursorPart2.el, e.chap2CursorPart1.el], {
                                    x: 0,
                                    y: 0
                                }), TweenMax.to([e.chap2CursorPart2.el, e.chap2CursorPart1.el], .5, {
                                    opacity: 1,
                                    delay: .5,
                                    onComplete: function() {
                                        e.playChap2Cursor()
                                    }
                                })
                            }
                        })
                    }
                })
            }
        })
    },
    playChap3Cursor: function() {
        var e = this;
        TweenMax.to(e.chap3CursorIcon.el, .5, {
            x: -55,
            y: -25,
            ease: Expo.easeOut,
            onComplete: function() {
                TweenMax.to(e.chap3CursorIcon.el, .7, {
                    x: 55,
                    y: -25,
                    delay: .5,
                    ease: Expo.easeOut,
                    onComplete: function() {
                        TweenMax.to(e.chap3CursorPart2.el, .7, {
                            x: -45,
                            scale: 1.1,
                            ease: Expo.easeInOut
                        }), TweenMax.to(e.chap3CursorPart1.el, .7, {
                            x: 50,
                            opacity: 0,
                            ease: Expo.easeInOut
                        }), TweenMax.to(e.chap3CursorIcon.el, .7, {
                            x: 0,
                            y: 0,
                            ease: Expo.easeOut,
                            delay: .5,
                            onComplete: function() {
                                TweenMax.to([e.chap3CursorPart2.el, e.chap3CursorPart1.el], .5, {
                                    opacity: 0,
                                    delay: .5,
                                    onComplete: function() {
                                        TweenMax.set([e.chap3CursorPart2.el, e.chap3CursorPart1.el], {
                                            x: 0,
                                            y: 0,
                                            scale: 1
                                        }), TweenMax.to([e.chap3CursorPart2.el, e.chap3CursorPart1.el], .5, {
                                            opacity: 1,
                                            delay: .5,
                                            onComplete: function() {
                                                e.playChap3Cursor()
                                            }
                                        })
                                    }
                                })
                            }
                        })
                    }
                })
            }
        })
    },
    updateProgress: function(e) {
        this.timelineProg.addStyle({
            width: 100 * e + "%"
        })
    },
    openChap2: function() {
        var e = this;
        this.chap1Title.el.innerHTML = "Chapter II", this.chap1SubTitle.el.innerHTML = "Sort", this.chap1Quote.el.innerHTML = '"Creativity is the ability to introduce order into the randomness of nature."', this.chap1QuoteAuthor.el.innerHTML = "- Eric Hoffer", this.chap1Overlay.el.removeChild(this.chap1Cursor.el), this.chap1Overlay.el.removeChild(this.chap1CursorInfos.el), this.chap1Overlay.el.appendChild(this.chap2Cursor.el), this.chap1Overlay.el.appendChild(this.chap2CursorInfos.el), soundManager.play("chap1Intro2"), TweenMax.delayedCall(3.5, function() {
            e.playChap2Cursor()
        }), TweenMax.to(e.chap1Overlay.el, 1, {
            autoAlpha: 1
        }), TweenMax.fromTo(e.chap1Title.el, 2, {
            autoAlpha: 0,
            y: 30
        }, {
            autoAlpha: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: 1
        }), TweenMax.fromTo(e.chap1SubTitle.el, 2, {
            autoAlpha: 0,
            y: 30
        }, {
            autoAlpha: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: 1.1
        }), TweenMax.fromTo(e.chap1Quote.el, 2, {
            autoAlpha: 0,
            y: 30
        }, {
            autoAlpha: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: 1.2
        }), TweenMax.fromTo(e.chap1QuoteAuthor.el, 2, {
            autoAlpha: 0,
            y: 30
        }, {
            autoAlpha: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: 1.3
        }), TweenMax.fromTo(e.chap2Cursor.el, 2, {
            autoAlpha: 0,
            y: 30
        }, {
            autoAlpha: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: 1.4
        }), TweenMax.fromTo(e.chap2CursorInfos.el, 2, {
            autoAlpha: 0,
            y: 30
        }, {
            autoAlpha: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: 1.4
        }), TweenMax.to(e.chap1Title.el, 2, {
            autoAlpha: 0,
            y: -30,
            ease: Expo.easeOut,
            delay: 12
        }), TweenMax.to(e.chap1SubTitle.el, 2, {
            autoAlpha: 0,
            y: -30,
            ease: Expo.easeOut,
            delay: 12.1
        }), TweenMax.to(e.chap1Quote.el, 2, {
            autoAlpha: 0,
            y: -30,
            ease: Expo.easeOut,
            delay: 12.2
        }), TweenMax.to(e.chap1QuoteAuthor.el, 2, {
            autoAlpha: 0,
            y: -30,
            ease: Expo.easeOut,
            delay: 12.3
        }), TweenMax.to(e.chap2Cursor.el, 2, {
            autoAlpha: 0,
            y: -30,
            ease: Expo.easeOut,
            delay: 12.4
        }), TweenMax.to(e.chap2CursorInfos.el, 2, {
            autoAlpha: 0,
            y: -30,
            ease: Expo.easeOut,
            delay: 12.4
        }), TweenMax.delayedCall(13, function() {
            soundManager.play("chap1Intro")
        }), TweenMax.to(e.chap1Overlay.el, 1, {
            autoAlpha: 0,
            delay: 13,
            onComplete: function() {
                e.chapter2.isActive = !0, TweenMax.killTweensOf([e.chap2CursorIcon, e.chap2CursorPart2, e.chap2CursorPart1])
            }
        })
    },
    openChap3: function() {
        var e = this;
        this.chap1Title.el.innerHTML = "Chapter III", this.chap1SubTitle.el.innerHTML = "Connect", this.chap1Quote.el.innerHTML = '"Creativity is just connecting things."', this.chap1QuoteAuthor.el.innerHTML = "- Steve Jobs", this.chap1Overlay.el.removeChild(this.chap2Cursor.el), this.chap1Overlay.el.removeChild(this.chap2CursorInfos.el), this.chap1Overlay.el.appendChild(this.chap3Cursor.el), this.chap1Overlay.el.appendChild(this.chap3CursorInfos.el), soundManager.play("chap1Intro2"), TweenMax.delayedCall(3.5, function() {
            e.playChap3Cursor()
        }), TweenMax.to(e.chap1Overlay.el, 1, {
            autoAlpha: 1
        }), TweenMax.fromTo(e.chap1Title.el, 2, {
            autoAlpha: 0,
            y: 30
        }, {
            autoAlpha: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: 1
        }), TweenMax.fromTo(e.chap1SubTitle.el, 2, {
            autoAlpha: 0,
            y: 30
        }, {
            autoAlpha: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: 1.1
        }), TweenMax.fromTo(e.chap1Quote.el, 2, {
            autoAlpha: 0,
            y: 30
        }, {
            autoAlpha: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: 1.2
        }), TweenMax.fromTo(e.chap1QuoteAuthor.el, 2, {
            autoAlpha: 0,
            y: 30
        }, {
            autoAlpha: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: 1.3
        }), TweenMax.fromTo(e.chap3Cursor.el, 2, {
            autoAlpha: 0,
            y: 30
        }, {
            autoAlpha: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: 1.4
        }), TweenMax.fromTo(e.chap3CursorInfos.el, 2, {
            autoAlpha: 0,
            y: 30
        }, {
            autoAlpha: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: 1.4
        }), TweenMax.to(e.chap1Title.el, 2, {
            autoAlpha: 0,
            y: -30,
            ease: Expo.easeOut,
            delay: 12
        }), TweenMax.to(e.chap1SubTitle.el, 2, {
            autoAlpha: 0,
            y: -30,
            ease: Expo.easeOut,
            delay: 12.1
        }), TweenMax.to(e.chap1Quote.el, 2, {
            autoAlpha: 0,
            y: -30,
            ease: Expo.easeOut,
            delay: 12.2
        }), TweenMax.to(e.chap1QuoteAuthor.el, 2, {
            autoAlpha: 0,
            y: -30,
            ease: Expo.easeOut,
            delay: 12.3
        }), TweenMax.to(e.chap3Cursor.el, 2, {
            autoAlpha: 0,
            y: -30,
            ease: Expo.easeOut,
            delay: 12.4
        }), TweenMax.to(e.chap3CursorInfos.el, 2, {
            autoAlpha: 0,
            y: -30,
            ease: Expo.easeOut,
            delay: 12.4
        }), TweenMax.delayedCall(13, function() {
            soundManager.play("chap1Intro")
        }), TweenMax.to(e.chap1Overlay.el, 1, {
            autoAlpha: 0,
            delay: 13,
            onComplete: function() {
                e.chapter2.getChap21()
            }
        })
    },
    openEnd: function() {
        TweenMax.to(this.logoBlack.el, 2, {
            autoAlpha: 1,
            delay: 4
        }), TweenMax.to(this.by.el, 2, {
            autoAlpha: 1,
            delay: 6
        }), TweenMax.to(this.creditsBtn.el, 2, {
            autoAlpha: 1,
            delay: 8
        }), TweenMax.to(this.timelineDot4.el, .5, {
            scale: 2,
            ease: Expo.easeOut
        }), TweenMax.to(this.timeline.el, 2, {
            autoAlpha: 0,
            delay: 4
        })
    },
    onChapter1End: function() {
        var e = this;
        TweenMax.to(this.timelineDot2.el, .5, {
            scale: 2,
            ease: Expo.easeOut
        }), e.chapter1.animateOut(), TweenMax.delayedCall(2.5, function() {
            soundManager.play("chap1chap2"), soundManager.play("chap2Loop1", {
                loops: 1e4
            }), e.world.scene.add(e.chapter2.mainEl), e.chapter2.animateIn(), TweenMax.delayedCall(3, function() {
                e.openChap2()
            })
        }), TweenMax.to(this.world.bg.material, 1, {
            opacity: 0,
            delay: 2.5
        }), TweenMax.to(this.world.bg2.material, 1, {
            opacity: 1,
            delay: 2.5
        }), TweenMax.to(this.world.effectBloom.screenUniforms.opacity, 1, {
            value: 2,
            ease: Expo.easeOut,
            delay: 2.5,
            onComplete: function() {}
        }), TweenMax.to(this.world.effectBloom.screenUniforms.opacity, 4, {
            value: .2,
            ease: Expo.easeOut,
            delay: 3.5
        })
    },
    onChapter2End: function() {
        TweenMax.to(this.timelineDot3.el, .5, {
            scale: 2,
            ease: Expo.easeOut
        })
    },
    loop: function() {
        this.shouldLoop && (requestAnimationFrame($.proxy(this.loop, this)), this.world.loop(), this.chapter1.loop(), this.chapter2.loop())
    },
    resize: function() {
        this.world.resize()
    }
};
var site;
$(document).ready(function() {
    site = new OMM.Site
});